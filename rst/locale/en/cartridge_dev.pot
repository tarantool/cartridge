# SOME DESCRIPTIVE TITLE.
# Copyright (C) 
# This file is distributed under the same license as the Cartridge package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Cartridge 2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-04 09:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Developer's guide"
msgstr ""

msgid "For a quick start, skip the details below and jump right away to the `Cartridge getting started guide <https://www.tarantool.io/en/doc/latest/getting_started/getting_started_cartridge/>`_."
msgstr ""

msgid "For a deep dive into what you can develop with Tarantool Cartridge, go on with the Cartridge developer's guide."
msgstr ""

msgid "Introduction"
msgstr ""

msgid "To develop and start an application, in short, you need to go through the following steps:"
msgstr ""

msgid ":ref:`Install <cartridge-install-dev>` Tarantool Cartridge and other components of the development environment."
msgstr ""

msgid ":ref:`Create a project <cartridge-project>`."
msgstr ""

msgid "Develop the application. In case it is a cluster-aware application, implement its logic in a custom (user-defined) :ref:`cluster role <cartridge-roles>` to initialize the database in a cluster environment."
msgstr ""

msgid ":ref:`Deploy <cartridge-deploy>` the application to target server(s). This includes :ref:`configuring <cartridge-config>` and :ref:`starting <cartridge-run>` the instance(s)."
msgstr ""

msgid "In case it is a cluster-aware application, :ref:`deploy the cluster <cartridge-deployment>`."
msgstr ""

msgid "The following sections provide details for each of these steps."
msgstr ""

msgid "Installing Tarantool Cartridge"
msgstr ""

msgid "`Install <https://github.com/tarantool/cartridge-cli#installation>`__ ``cartridge-cli``, a command-line tool for developing, deploying, and managing Tarantool applications."
msgstr ""

msgid "`Install <https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>`__ ``git``, a version control system."
msgstr ""

msgid "`Install <https://www.npmjs.com/get-npm>`__ ``npm``, a package manager for ``node.js``."
msgstr ""

msgid "`Install <https://linuxize.com/post/how-to-unzip-files-in-linux/>`__ the ``unzip`` utility."
msgstr ""

msgid "Creating a project"
msgstr ""

msgid "To set up your development environment, create a project using the Tarantool Cartridge project template. In any directory, say:"
msgstr ""

msgid "This will automatically set up a Git repository in a new ``/path/to/<app_name>/`` directory, tag it with :ref:`version <cartridge-versioning>` ``0.1.0``, and put the necessary files into it."
msgstr ""

msgid "In this Git repository, you can develop the application (by simply editing the default files provided by the template), plug the necessary modules, and then easily pack everything to deploy on your server(s)."
msgstr ""

msgid "The project template creates the ``<app_name>/`` directory with the following contents:"
msgstr ""

msgid "``<app_name>-scm-1.rockspec`` file where you can specify the application dependencies."
msgstr ""

msgid "``deps.sh`` script that resolves dependencies from the ``.rockspec`` file."
msgstr ""

msgid "``init.lua`` file which is the entry point for your application."
msgstr ""

msgid "``.git`` file necessary for a Git repository."
msgstr ""

msgid "``.gitignore`` file to ignore the unnecessary files."
msgstr ""

msgid "``env.lua`` file that sets common rock paths so that the application can be started from any directory."
msgstr ""

msgid "``custom-role.lua`` file that is a placeholder for a custom (user-defined) :ref:`cluster role <cartridge-roles>`."
msgstr ""

msgid "The entry point file (``init.lua``), among other things, loads the ``cartridge`` module and calls its initialization function:"
msgstr ""

msgid "The ``cartridge.cfg()`` call renders the instance operable via the administrative console but does not call ``box.cfg()`` to configure instances."
msgstr ""

msgid "Calling the ``box.cfg()`` function is forbidden."
msgstr ""

msgid "The cluster itself will do it for you when it is time to:"
msgstr ""

msgid "bootstrap the current instance once you:"
msgstr ""

msgid "run ``cartridge.bootstrap()`` via the administrative console, or"
msgstr ""

msgid "click **Create** in the web interface;"
msgstr ""

msgid "join the instance to an existing cluster once you:"
msgstr ""

msgid "run ``cartridge.join_server({uri = 'other_instance_uri'})`` via the console, or"
msgstr ""

msgid "click **Join** (an existing replica set) or **Create** (a new replica set) in the web interface."
msgstr ""

msgid "Notice that you can specify a cookie for the cluster (``cluster_cookie`` parameter) if you need to run several clusters in the same network. The cookie can be any string value."
msgstr ""

msgid "Now you can develop an application that will run on a single or multiple independent Tarantool instances (e.g. acting as a proxy to third-party databases) -- or will run in a cluster."
msgstr ""

msgid "If you plan to develop a cluster-aware application, first familiarize yourself with the notion of :ref:`cluster roles <cartridge-roles>`."
msgstr ""

msgid "Cluster roles"
msgstr ""

msgid "**Cluster roles** are Lua modules that implement some specific functions and/or logic. In other words, a Tarantool Cartridge cluster segregates instance functionality in a role-based way."
msgstr ""

msgid "Since all instances running cluster applications use the same source code and are aware of all the defined roles (and plugged modules), you can dynamically enable and disable multiple different roles without restarts, even during cluster operation."
msgstr ""

msgid "Note that every instance in a replica set performs the same roles and you cannot enable/disable roles individually on some instances. In other words, configuration of enabled roles is set up *per replica set*. See a step-by-step configuration example in :ref:`this guide <cartridge-deployment>`."
msgstr ""

msgid "Built-in roles"
msgstr ""

msgid "The ``cartridge`` module comes with two *built-in* roles that implement automatic sharding:"
msgstr ""

msgid "``vshard-router`` that handles the ``vshard``'s *compute-intensive* workload: routes requests to storage nodes."
msgstr ""

msgid "``vshard-storage`` that handles the ``vshard``'s *transaction-intensive* workload: stores and manages a subset of a dataset."
msgstr ""

msgid "For more information on sharding, see the `vshard module documentation <https://www.tarantool.io/en/doc/latest/reference/reference_rock/vshard/>`_."
msgstr ""

msgid "With the built-in and :ref:`custom roles <cartridge-custom-roles>`, you can develop applications with separated compute and transaction handling -- and enable relevant workload-specific roles on different instances running on physical servers with workload-dedicated hardware."
msgstr ""

msgid "Custom roles"
msgstr ""

msgid "You can implement custom roles for any purposes, for example:"
msgstr ""

msgid "define stored procedures;"
msgstr ""

msgid "implement extra features on top of ``vshard``;"
msgstr ""

msgid "go without ``vshard`` at all;"
msgstr ""

msgid "implement one or multiple supplementary services such as e-mail notifier, replicator, etc."
msgstr ""

msgid "To implement a custom cluster role, do the following:"
msgstr ""

msgid "Take the ``app/roles/custom.lua`` file in your project as a sample. Rename this file as you wish, e.g. ``app/roles/custom-role.lua``, and implement the role's logic. For example:"
msgstr ""

msgid "Here the ``role_name`` value may differ from the module name passed to the ``cartridge.cfg()`` function. If the ``role_name`` variable is not specified, the module name is the default value."
msgstr ""

msgid "Role names must be unique as it is impossible to register multiple roles with the same name."
msgstr ""

msgid "Register the new role in the cluster by modifying the ``cartridge.cfg()`` call in the ``init.lua`` entry point file:"
msgstr ""

msgid "where ``custom-role`` is the name of the Lua module to be loaded."
msgstr ""

msgid "The role module does not have required functions, but the cluster may execute the following ones during the :ref:`role's life cycle <cartridge-role-lifecycle>`:"
msgstr ""

msgid "``init()`` is the role's *initialization* function."
msgstr ""

msgid "Inside the function's body you can call any `box <https://www.tarantool.io/en/doc/latest/reference/reference_lua/box/>`_ functions: create spaces, indexes, grant permissions, etc. Here is what the initialization function may look like:"
msgstr ""

msgid "Neither ``vshard-router`` nor ``vshard-storage`` manage spaces, indexes, or formats. You should do it within a *custom* role: add a ``box.schema.space.create()`` call to your first cluster role, as shown in the example above."
msgstr ""

msgid "The function's body is wrapped in a conditional statement that lets you call ``box`` functions on masters only. This protects against replication collisions as data propagates to replicas automatically."
msgstr ""

msgid "``stop()`` is the role's *termination* function. Implement it if initialization starts a fiber that has to be stopped or does any job that needs to be undone on termination."
msgstr ""

msgid "``validate_config()`` and ``apply_config()`` are functions that *validate* and *apply* the role's configuration. Implement them if some configuration data needs to be stored cluster-wide."
msgstr ""

msgid "Next, get a grip on the :ref:`role's life cycle <cartridge-role-lifecycle>` to implement the functions you need."
msgstr ""

msgid "Defining role dependencies"
msgstr ""

msgid "You can instruct the cluster to apply some other roles if your custom role is enabled."
msgstr ""

msgid "For example:"
msgstr ""

msgid "Here ``vshard-router`` role will be initialized automatically for every instance with ``custom-role`` enabled."
msgstr ""

msgid "Using multiple vshard storage groups"
msgstr ""

msgid "Replica sets with ``vshard-storage`` roles can belong to different *groups*. For example, ``hot`` or ``cold`` groups meant to independently process hot and cold data."
msgstr ""

msgid "Groups are specified in the cluster's configuration:"
msgstr ""

msgid "If no groups are specified, the cluster assumes that all replica sets belong to the ``default`` group."
msgstr ""

msgid "With multiple groups enabled, every replica set with a ``vshard-storage`` role enabled must be assigned to a particular group. The assignment can never be changed."
msgstr ""

msgid "Another limitation is that you cannot add groups dynamically (this will become available in future)."
msgstr ""

msgid "Finally, mind the syntax for router access. Every instance with a ``vshard-router`` role enabled initializes multiple routers. All of them are accessible through the role:"
msgstr ""

msgid "If you have no roles specified, you can access a static router as before (when Tarantool Cartridge was unaware of groups):"
msgstr ""

msgid "However, when using the current group-aware API, you must call a static router with a colon:"
msgstr ""

msgid "Role's life cycle (and the order of function execution)"
msgstr ""

msgid "The cluster displays the names of all custom roles along with the built-in ``vshard-*`` roles in the :ref:`web interface <cartridge-deployment>`. Cluster administrators can enable and disable them for particular instances -- either via the web interface or via the cluster `public API <https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.admin/#edit-topology-args>`_. For example:"
msgstr ""

msgid "If you enable multiple roles on an instance at the same time, the cluster first initializes the built-in roles (if any) and then the custom ones (if any) in the order the latter were listed in ``cartridge.cfg()``."
msgstr ""

msgid "If a custom role has dependent roles, the dependencies are registered and validated first, *prior* to the role itself."
msgstr ""

msgid "The cluster calls the role's functions in the following circumstances:"
msgstr ""

msgid "The ``init()`` function, typically, once: either when the role is enabled by the administrator or at the instance restart. Enabling a role once is normally enough."
msgstr ""

msgid "The ``stop()`` function -- only when the administrator disables the role, not on instance termination."
msgstr ""

msgid "The ``validate_config()`` function, first, before the automatic ``box.cfg()`` call (database initialization), then -- upon every configuration update."
msgstr ""

msgid "The ``apply_config()`` function upon every configuration update."
msgstr ""

msgid "As a tryout, let's task the cluster with some actions and see the order of executing the role's functions:"
msgstr ""

msgid "Join an instance or create a replica set, both with an enabled role:"
msgstr ""

msgid "``validate_config()``"
msgstr ""

msgid "``init()``"
msgstr ""

msgid "``apply_config()``"
msgstr ""

msgid "Restart an instance with an enabled role:"
msgstr ""

msgid "Disable role: ``stop()``."
msgstr ""

msgid "Upon the ``cartridge.confapplier.patch_clusterwide()`` call:"
msgstr ""

msgid "Upon a triggered failover:"
msgstr ""

msgid "Considering the described behavior:"
msgstr ""

msgid "The ``init()`` function may:"
msgstr ""

msgid "Call ``box`` functions."
msgstr ""

msgid "Start a fiber and, in this case, the ``stop()`` function should take care of the fiber's termination."
msgstr ""

msgid "Configure the built-in :ref:`HTTP server <cartridge-httpd-instance>`."
msgstr ""

msgid "Execute any code related to the role's initialization."
msgstr ""

msgid "The ``stop()`` functions must undo any job that needs to be undone on role's termination."
msgstr ""

msgid "The ``validate_config()`` function must validate any configuration change."
msgstr ""

msgid "The ``apply_config()`` function may execute any code related to a configuration change, e.g., take care of an ``expirationd`` fiber."
msgstr ""

msgid "The validation and application functions together allow you to change the cluster-wide configuration as described in the :ref:`next section <cartridge-role-config>`."
msgstr ""

msgid "Configuring custom roles"
msgstr ""

msgid "You can:"
msgstr ""

msgid "Store configurations for your custom roles as sections in cluster-wide configuration, for example:"
msgstr ""

msgid "Download and upload cluster-wide configuration using the :ref:`web interface <cartridge-ui-configuration>` or API (via GET/PUT queries to ``admin/config`` endpoint like ``curl localhost:8081/admin/config`` and ``curl -X PUT -d \"{'my_parameter': 'value'}\" localhost:8081/admin/config``)."
msgstr ""

msgid "Utilize it in your role's ``apply_config()`` function."
msgstr ""

msgid "Every instance in the cluster stores a copy of the configuration file in its working directory (configured by ``cartridge.cfg({workdir = ...})``):"
msgstr ""

msgid "``/var/lib/tarantool/<instance_name>/config.yml`` for instances deployed from RPM packages and managed by ``systemd``."
msgstr ""

msgid "``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` for instances deployed from tar+gz archives."
msgstr ""

msgid "The cluster's configuration is a Lua table, downloaded and uploaded as YAML. If some application-specific configuration data, e.g. a database schema as defined by DDL (data definition language), needs to be stored on every instance in the cluster, you can implement your own API by adding a custom section to the table. The cluster will help you spread it safely across all instances."
msgstr ""

msgid "Such section goes in the same file with topology-specific and ``vshard``-specific sections that the cluster generates automatically. Unlike the generated, the custom section's modification, validation, and application logic has to be defined."
msgstr ""

msgid "The common way is to define two functions:"
msgstr ""

msgid "``validate_config(conf_new, conf_old)`` to validate changes made in the new configuration (``conf_new``) versus the old configuration (``conf_old``)."
msgstr ""

msgid "``apply_config(conf, opts)`` to execute any code related to a configuration change. As input, this function takes the configuration to apply (``conf``, which is actually the new configuration that you validated earlier with ``validate_config()``) and options (the ``opts`` argument that includes ``is_master``, a Boolean flag described later)."
msgstr ""

msgid "The ``validate_config()`` function must detect all configuration problems that may lead to ``apply_config()`` errors. For more information, see the :ref:`next section <cartridge-role-config-apply>`."
msgstr ""

msgid "When implementing validation and application functions that call ``box`` ones for some reason, mind the following precautions:"
msgstr ""

msgid "Due to the :ref:`role's life cycle <cartridge-role-lifecycle>`, the cluster does not guarantee an automatic ``box.cfg()`` call prior to calling ``validate_config()``."
msgstr ""

msgid "If the validation function calls any ``box`` functions (e.g., to check a format), make sure the calls are wrapped in a protective conditional statement that checks if ``box.cfg()`` has already happened:"
msgstr ""

msgid "Unlike the validation function, ``apply_config()`` can call ``box`` functions freely as the cluster applies custom configuration after the automatic ``box.cfg()`` call."
msgstr ""

msgid "However, creating spaces, users, etc., can cause replication collisions when performed on both master and replica instances simultaneously. The appropriate way is to call such ``box`` functions *on masters only* and let the changes propagate to replicas automatically."
msgstr ""

msgid "Upon the ``apply_config(conf, opts)`` execution, the cluster passes an ``is_master`` flag in the ``opts`` table which you can use to wrap collision-inducing ``box`` functions in a protective conditional statement:"
msgstr ""

msgid "Custom configuration example"
msgstr ""

msgid "Consider the following code as part of the role's module (``custom-role.lua``) implementation:"
msgstr ""

msgid "Once the configuration is customized, do one of the following:"
msgstr ""

msgid "continue developing your application and pay attention to its :ref:`versioning <cartridge-versioning>`;"
msgstr ""

msgid "(optional) :ref:`enable authorization <cartridge-auth-enable>` in the web interface."
msgstr ""

msgid "in case the cluster is already deployed, :ref:`apply the configuration <cartridge-role-config-apply>` cluster-wide."
msgstr ""

msgid "Applying custom role's configuration"
msgstr ""

msgid "With the implementation showed by the :ref:`example <cartridge-role-config-example>`, you can call the ``set_secret()`` function to apply the new configuration via the administrative console -- or an HTTP endpoint if the role exports one."
msgstr ""

msgid "The ``set_secret()`` function calls ``cartridge.confapplier.patch_clusterwide()`` which performs a two-phase commit:"
msgstr ""

msgid "It patches the active configuration in memory: copies the table and replaces the ``\"custom-role\"`` section in the copy with the one given by the ``set_secret()`` function."
msgstr ""

msgid "The cluster checks if the new configuration can be applied on all instances except disabled and expelled. All instances subject to update must be healthy and ``alive`` according to the `membership module <https://www.tarantool.io/en/doc/latest/reference/reference_rock/membership/>`_."
msgstr ""

msgid "(**Preparation phase**) The cluster propagates the patched configuration. Every instance validates it with the ``validate_config()`` function of every registered role. Depending on the validation's result:"
msgstr ""

msgid "If successful (i.e., returns ``true``), the instance saves the new configuration to a temporary file named ``config.prepare.yml`` within the working directory."
msgstr ""

msgid "(**Abort phase**) Otherwise, the instance reports an error and all the other instances roll back the update: remove the file they may have already prepared."
msgstr ""

msgid "(**Commit phase**) Upon successful preparation of all instances, the cluster commits the changes. Every instance:"
msgstr ""

msgid "Creates the active configuration's hard-link."
msgstr ""

msgid "Atomically replaces the active configuration file with the prepared one. The atomic replacement is indivisible -- it can either succeed or fail entirely, never partially."
msgstr ""

msgid "Calls the ``apply_config()`` function of every registered role."
msgstr ""

msgid "If any of these steps fail, an error pops up in the web interface next to the corresponding instance. The cluster does not handle such errors automatically, they require manual repair."
msgstr ""

msgid "You will avoid the repair if the ``validate_config()`` function can detect all configuration problems that may lead to ``apply_config()`` errors."
msgstr ""

msgid "Using the built-in HTTP server"
msgstr ""

msgid "The cluster launches an ``httpd`` server instance during initialization (``cartridge.cfg()``). You can bind a port to the instance via an environmental variable:"
msgstr ""

msgid "To make use of the ``httpd`` instance, access it and configure routes inside the ``init()`` function of some role, e.g. a role that exposes API over HTTP:"
msgstr ""

msgid "For more information on using Tarantool's HTTP server, see `its documentation <https://github.com/tarantool/http>`_."
msgstr ""

msgid "Implementing authorization in the web interface"
msgstr ""

msgid "To implement authorization in the web interface of every instance in a Tarantool cluster:"
msgstr ""

msgid "Implement a new, say, ``auth`` module with a ``check_password`` function. It should check the credentials of any user trying to log in to the web interface."
msgstr ""

msgid "The ``check_password`` function accepts a username and password and returns an authentication success or failure."
msgstr ""

msgid "Pass the implemented ``auth`` module name as a parameter to ``cartridge.cfg()``, so the cluster can use it:"
msgstr ""

msgid "This adds a **Log in** button to the upper right corner of the web interface but still lets the unsigned users interact with the interface. This is convenient for testing."
msgstr ""

msgid "Also, to authorize requests to cluster API, you can use the HTTP basic authorization header."
msgstr ""

msgid "To require the authorization of every user in the web interface even before the cluster bootstrap, add the following line:"
msgstr ""

msgid "With the authentication enabled and the ``auth`` module implemented, the user will not be able to even bootstrap the cluster without logging in. After the successful login and bootstrap, the authentication can be enabled and disabled cluster-wide in the web interface and the ``auth_enabled`` parameter is ignored."
msgstr ""

msgid "Application versioning"
msgstr ""

msgid "Tarantool Cartridge understands semantic versioning as described at `semver.org <https://semver.org>`_. When developing an application, create new Git branches and tag them appropriately. These tags are used to calculate version increments for subsequent packing."
msgstr ""

msgid "For example, if your application has version 1.2.1, tag your current branch with ``1.2.1`` (annotated or not)."
msgstr ""

msgid "To retrieve the current version from Git, say:"
msgstr ""

msgid "This output shows that we are 12 commits after the version 1.2.1. If we are to package the application at this point, it will have a full version of ``1.2.1-12`` and its package will be named ``<app_name>-1.2.1-12.rpm``."
msgstr ""

msgid "Non-semantic tags are prohibited. You will not be able to create a package from a branch with the latest tag being non-semantic."
msgstr ""

msgid "Once you :ref:`package <cartridge-deploy>` your application, the version is saved in a ``VERSION`` file in the package root."
msgstr ""

msgid "Using .cartridge.ignore files"
msgstr ""

msgid "You can add a ``.cartridge.ignore`` file to your application repository to exclude particular files and/or directories from package builds."
msgstr ""

msgid "For the most part, the logic is similar to that of ``.gitignore`` files. The major difference is that in ``.cartridge.ignore`` files the order of exceptions relative to the rest of the templates does not matter, while in ``.gitignore`` files the order does matter."
msgstr ""

msgid "**.cartridge.ignore** entry"
msgstr ""

msgid "ignores every..."
msgstr ""

msgid "``target/``"
msgstr ""

msgid "**folder** (due to the trailing ``/``) named ``target``, recursively"
msgstr ""

msgid "``target``"
msgstr ""

msgid "**file or folder** named ``target``, recursively"
msgstr ""

msgid "``/target``"
msgstr ""

msgid "**file or folder** named ``target`` in the top-most directory (due to the leading ``/``)"
msgstr ""

msgid "``/target/``"
msgstr ""

msgid "**folder** named ``target`` in the top-most directory (leading and trailing ``/``)"
msgstr ""

msgid "``*.class``"
msgstr ""

msgid "every **file or folder** ending with ``.class``, recursively"
msgstr ""

msgid "``#comment``"
msgstr ""

msgid "nothing, this is a comment (the first character is a ``#``)"
msgstr ""

msgid "``\\#comment``"
msgstr ""

msgid "every **file or folder** with name ``#comment`` (``\\`` for escaping)"
msgstr ""

msgid "``target/logs/``"
msgstr ""

msgid "every **folder** named ``logs`` which is a subdirectory of a folder named ``target``"
msgstr ""

msgid "``target/*/logs/``"
msgstr ""

msgid "every **folder** named ``logs`` two levels under a folder named ``target`` (``*`` doesn’t include ``/``)"
msgstr ""

msgid "``target/**/logs/``"
msgstr ""

msgid "every **folder** named ``logs`` somewhere under a folder named ``target`` (``**`` includes ``/``)"
msgstr ""

msgid "``*.py[co]``"
msgstr ""

msgid "every **file or folder** ending in ``.pyc`` or ``.pyo``; however, it doesn’t match ``.py!``"
msgstr ""

msgid "``*.py[!co]``"
msgstr ""

msgid "every **file or folder** ending in anything other than ``c`` or ``o``"
msgstr ""

msgid "``*.file[0-9]``"
msgstr ""

msgid "every **file or folder** ending in digit"
msgstr ""

msgid "``*.file[!0-9]``"
msgstr ""

msgid "every **file or folder** ending in anything other than digit"
msgstr ""

msgid "``*``"
msgstr ""

msgid "**every**"
msgstr ""

msgid "``/*``"
msgstr ""

msgid "**everything** in the top-most directory (due to the leading ``/``)"
msgstr ""

msgid "``**/*.tar.gz``"
msgstr ""

msgid "every ``*.tar.gz`` file or folder which is **one or more** levels under the starting folder"
msgstr ""

msgid "``!file``"
msgstr ""

msgid "every **file or folder** will be ignored even if it matches other patterns"
msgstr ""

msgid "Failover architecture"
msgstr ""

msgid "An important concept in cluster topology is appointing **a leader**. Leader is an instance which is responsible for performing key operations. To keep things simple, you can think of a leader as of the only writable master. Every replica set has its own leader, and there's usually not more than one."
msgstr ""

msgid "Which instance will become a leader depends on topology settings and failover configuration."
msgstr ""

msgid "An important topology parameter is the **failover priority** within a replica set. This is an ordered list of instances. By default, the first instance in the list becomes a leader, but with the failover enabled it may be changed automatically if the first one is malfunctioning."
msgstr ""

msgid "Instance configuration upon a leader change"
msgstr ""

msgid "When Cartridge configures roles, it takes into account the **leadership map** (consolidated in the ``failover.lua`` module). The leadership map is composed when the instance enters the ``ConfiguringRoles`` state for the first time. Later the map is updated according to the failover mode."
msgstr ""

msgid "Every change in the leadership map is accompanied by instance re-configuration. When the map changes, Cartridge updates the ``read_only`` setting and calls the ``apply_config`` callback for every role. It also specifies the ``is_master`` flag (which actually means ``is_leader``, but hasn't been renamed yet due to historical reasons)."
msgstr ""

msgid "It's important to say that we discuss a *distributed* system where every instance has its own opinion. Even if all opinions coincide, there still may be races between instances, and you (as an application developer) should take them into account when designing roles and their interaction."
msgstr ""

msgid "Leader appointment rules"
msgstr ""

msgid "The logic behind leader election depends on the **failover mode**: disabled, eventual, or stateful."
msgstr ""

msgid "Disabled mode"
msgstr ""

msgid "This is the simplest case. The leader is always the first instance in the failover priority. No automatic switching is performed. When it's dead, it's dead."
msgstr ""

msgid "Eventual failover"
msgstr ""

msgid "In the ``eventual`` mode, the leader isn't elected consistently. Instead, every instance in the cluster thinks that the leader is the first **healthy** instance in the failover priority list, while instance health is determined according to the membership status (the SWIM protocol)."
msgstr ""

msgid "The member is considered healthy if both are true:"
msgstr ""

msgid "It reports either ``ConfiguringRoles`` or ``RolesConfigured`` state;"
msgstr ""

msgid "Its SWIM status is either ``alive`` or ``suspect``."
msgstr ""

msgid "A ``suspect`` member becomes ``dead`` after the ``failover_timout`` expires."
msgstr ""

msgid "Leader election is done as follows. Suppose there are two replica sets in the cluster:"
msgstr ""

msgid "a single router \"R\","
msgstr ""

msgid "two storages, \"S1\" and \"S2\"."
msgstr ""

msgid "Then we can say: all the three instances (R, S1, S2) agree that S1 is the leader."
msgstr ""

msgid "The SWIM protocol guarantees that *eventually* all instances will find a common ground, but it's not guaranteed for every intermediate moment of time. So we may get a conflict."
msgstr ""

msgid "For example, soon after S1 goes down, R is already informed and thinks that S2 is the leader, but S2 hasn't received the gossip yet and still thinks he's not. This is a conflict."
msgstr ""

msgid "Similarly, when S1 recovers and takes the leadership, S2 may be unaware of that yet. So, both S1 and S2 consider themselves as leaders."
msgstr ""

msgid "Moreover, SWIM protocol isn't perfect and still can produce false-negative gossips (announce the instance is dead when it's not)."
msgstr ""

msgid "Stateful failover"
msgstr ""

msgid "Similarly to the eventual mode, every instance composes its own leadership map, but now the map is fetched from an **external state provider** (that's why this failover mode called \"stateful\"). Nowadays there are two state providers supported -- ``etcd`` and ``stateboard`` (standalone Tarantool instance). State provider serves as a domain-specific key-value storage (simply ``replicaset_uuid -> leader_uuid``) and a locking mechanism."
msgstr ""

msgid "Changes in the leadership map are obtained from the state provider with the `long polling technique <https://en.wikipedia.org/wiki/Push_technology#Long_polling>`_."
msgstr ""

msgid "All decisions are made by **the coordinator** -- the one that holds the lock. The coordinator is implemented as a built-in Cartridge role. There may be many instances with the coordinator role enabled, but only one of them can acquire the lock at the same time. We call this coordinator the \"active\" one."
msgstr ""

msgid "The lock is released automatically when the TCP connection is closed, or it may expire if the coordinator becomes unresponsive (in ``stateboard`` it's set by the stateboard's ``--lock_delay`` option, for ``etcd`` it's a part of clusterwide configuration), so the coordinator renews the lock from time to time in order to be considered alive."
msgstr ""

msgid "The coordinator makes a decision based on the SWIM data, but the decision algorithm is slightly different from that in case of eventual failover:"
msgstr ""

msgid "Right after acquiring the lock from the state provider, the coordinator fetches the leadership map."
msgstr ""

msgid "If there is no leader appointed for the replica set, the coordinator appoints the first leader according to the failover priority, regardless of the SWIM status."
msgstr ""

msgid "If a leader becomes ``dead``, the coordinator makes a decision. A new leader is the first healthy instance from the failover priority list. If an old leader recovers, no leader change is made until the current leader down. Changing failover priority doesn't affect this."
msgstr ""

msgid "Every appointment (self-made or fetched) is immune for a while (controlled by the ``IMMUNITY_TIMEOUT`` option)."
msgstr ""

msgid "The case: external provider outage"
msgstr ""

msgid "In this case instances do nothing: the leader remains a leader, read-only instances remain read-only. If any instance restarts during an external state provider outage, it composes an empty leadership map: it doesn't know who actually is a leader and thinks there is none."
msgstr ""

msgid "The case: coordinator outage"
msgstr ""

msgid "An active coordinator may be absent in a cluster either because of a failure or due to disabling the role everywhere. Just like in the previous case, instances do nothing about it: they keep fetching the leadership map from the state provider. But it will remain the same until a coordinator appears."
msgstr ""

msgid "Manual leader promotion"
msgstr ""

msgid "It differs a lot depending on the failover mode."
msgstr ""

msgid "In the disabled and eventual modes, you can only promote a leader by changing the failover priority (and applying a new clusterwide configuration)."
msgstr ""

msgid "In the stateful mode, the failover priority doesn't make much sense (except for the first appointment). Instead, you should use the promotion API (the Lua :ref:`cartridge.failover_promote <cartridge.failover_promote>` or the GraphQL ``mutation {cluster{failover_promote()}}``) which pushes manual appointments to the state provider."
msgstr ""

msgid "The stateful failover mode implies **consistent promotion**: before becoming writable, each instance performs the ``wait_lsn`` operation to sync up with the previous one."
msgstr ""

msgid "Information about the previous leader (we call it a *vclockkeeper*) is also stored on the external storage. Even when the old leader is demoted, it remains the vclockkeeper until the new leader successfully awaits and persists its vclock on the external storage."
msgstr ""

msgid "If replication is stuck and consistent promotion isn't possible, a user has two options: to revert promotion (to re-promote the old leader) or to force it inconsistently (all kinds of ``failover_promote`` API has ``force_inconsistency`` flag)."
msgstr ""

msgid "Consistent promotion doesn't work for replicasets with `all_rw` flag enabled and for single-instance replicasets. In these two cases an instance doesn't even try to query `vclockkeeper` and to perform `wait_lsn`. But the coordinator still appoints a new leader if the current one dies."
msgstr ""

msgid "Fencing"
msgstr ""

msgid "Neither ``eventual`` nor ``stateful`` failover mode protects a replicaset from the presence of multiple leaders when the network is partitioned. But fencing does. It enforces at-most-one leader policy in a replicaset."
msgstr ""

msgid "Fencing operates as a fiber that occasionally checks connectivity with the state provider and with replicas. Fencing fiber runs on vclockkeepers; it starts right after consistent promotion succeeds. Replicasets which don't need consistency (single-instance and ``all_rw``) don't defense, though."
msgstr ""

msgid "The condition for fencing actuation is the loss of both the state provider quorum and at least one replica. Otherwise, if either state provider is healthy or all replicas are alive, the fencing fiber waits and doesn't intervene."
msgstr ""

msgid "When fencing is actuated, it generates a fake appointment locally and sets the leader to ``nil``. Consequently, the instance becomes read-only. Subsequent recovery is only possible when the quorum reestablishes; replica connection isn't a must for recovery. Recovery is performed according to the rules of consistent switchover unless some other instance has already been promoted to a new leader."
msgstr ""

msgid "Failover configuration"
msgstr ""

msgid "These are clusterwide parameters:"
msgstr ""

msgid "``mode``: \"disabled\" / \"eventual\" / \"stateful\"."
msgstr ""

msgid "``state_provider``: \"tarantool\" / \"etcd\"."
msgstr ""

msgid "``failover_timeout`` -- time (in seconds) to mark ``suspect`` members as ``dead`` and trigger failover (default: 20)."
msgstr ""

msgid "``tarantool_params``: ``{uri = \"...\", password = \"...\"}``."
msgstr ""

msgid "``etcd2_params``: ``{endpoints = {...}, prefix = \"/\", lock_delay = 10, username = \"\", password = \"\"}``."
msgstr ""

msgid "``fencing_enabled``: ``true`` / ``false`` (default: false)."
msgstr ""

msgid "``fencing_timeout`` -- time to actuate fencing after the check fails (default: 10)."
msgstr ""

msgid "``fencing_pause`` -- the period of performing the check (default: 2)."
msgstr ""

msgid "It's required that ``failover_timeout > fencing_timeout >= fencing_pause``."
msgstr ""

msgid "Lua API"
msgstr ""

msgid "See:"
msgstr ""

msgid ":ref:`cartridge.failover_get_params <cartridge.failover_get_params>`,"
msgstr ""

msgid ":ref:`cartridge.failover_set_params <cartridge.failover_set_params>`,"
msgstr ""

msgid ":ref:`cartridge.failover_promote <cartridge.failover_promote>`."
msgstr ""

msgid "GraphQL API"
msgstr ""

msgid "Use your favorite GraphQL client (e.g. `Altair <https://altair.sirmuel.design/>`_) for requests introspection:"
msgstr ""

msgid "``query {cluster{failover_params{}}}``,"
msgstr ""

msgid "``mutation {cluster{failover_params(){}}}``,"
msgstr ""

msgid "``mutation {cluster{failover_promote()}}``."
msgstr ""

msgid "Stateboard configuration"
msgstr ""

msgid "Like other Cartridge instances, the stateboard supports ``cartridge.argprase`` options:"
msgstr ""

msgid "``listen``"
msgstr ""

msgid "``workdir``"
msgstr ""

msgid "``password``"
msgstr ""

msgid "``lock_delay``"
msgstr ""

msgid "Similarly to other ``argparse`` options, they can be passed via command-line arguments or via environment variables, e.g.:"
msgstr ""

msgid "Fine-tuning failover behavior"
msgstr ""

msgid "Besides failover priority and mode, there are some other private options that influence failover operation:"
msgstr ""

msgid "``LONGPOLL_TIMEOUT`` (``failover``) -- the long polling timeout (in seconds) to fetch new appointments (default: 30);"
msgstr ""

msgid "``NETBOX_CALL_TIMEOUT`` (``failover/coordinator``) -- stateboard client's connection timeout (in seconds) applied to all communications (default: 1);"
msgstr ""

msgid "``RECONNECT_PERIOD`` (``coordinator``) -- time (in seconds) to reconnect to the state provider if it's unreachable (default: 5);"
msgstr ""

msgid "``IMMUNITY_TIMEOUT`` (``coordinator``) -- minimal amount of time (in seconds) to wait before overriding an appointment (default: 15)."
msgstr ""

msgid "Configuring instances"
msgstr ""

msgid "Cartridge orchestrates a distributed system of Tarantool instances -- a cluster. One of the core concepts is **clusterwide configuration**. Every instance in a cluster stores a copy of it."
msgstr ""

msgid "Clusterwide configuration contains options that must be identical on every cluster node, such as the topology of the cluster, failover and vshard configuration, authentication parameters and ACLs, and user-defined configuration."
msgstr ""

msgid "Clusterwide configuration doesn't provide instance-specific parameters: ports, workdirs, memory settings, etc."
msgstr ""

msgid "Configuration basics"
msgstr ""

msgid "Instance configuration includes two sets of parameters:"
msgstr ""

msgid ":ref:`cartridge.cfg() parameters <cartridge.argparse.cluster_opts>`;"
msgstr ""

msgid ":ref:`box.cfg() parameters <cartridge.argparse.box_opts>`."
msgstr ""

msgid "You can set any of these parameters in:"
msgstr ""

msgid "Command line arguments."
msgstr ""

msgid "Environment variables."
msgstr ""

msgid "YAML configuration file."
msgstr ""

msgid "``init.lua`` file."
msgstr ""

msgid "The order here indicates the priority: command-line arguments override environment variables, and so forth."
msgstr ""

msgid "No matter how you :ref:`start the instances <cartridge-run>`, you need to set the following ``cartridge.cfg()`` parameters for each instance:"
msgstr ""

msgid "``advertise_uri`` -- either ``<HOST>:<PORT>``, or ``<HOST>:``, or ``<PORT>``. Used by other instances to connect to the current one. **DO NOT** specify ``0.0.0.0`` -- this must be an external IP address, not a socket bind."
msgstr ""

msgid "``http_port`` -- port to open administrative web interface and API on. Defaults to ``8081``. To disable it, specify ``\"http_enabled\": False``."
msgstr ""

msgid "``workdir`` -- a directory where all data will be stored: snapshots, wal logs, and ``cartridge`` configuration file. Defaults to ``.``."
msgstr ""

msgid "If you start instances using ``cartridge`` CLI or ``systemctl``, save the configuration as a YAML file, for example:"
msgstr ""

msgid "With ``cartridge`` CLI, you can pass the path to this file as the ``--cfg`` command-line argument to the ``cartridge start`` command -- or specify the path in ``cartridge`` CLI configuration (in ``./.cartridge.yml`` or ``~/.cartridge.yml``):"
msgstr ""

msgid "With ``systemctl``, save the YAML file to ``/etc/tarantool/conf.d/`` (the default ``systemd`` path) or to a location set in the ``TARANTOOL_CFG`` environment variable."
msgstr ""

msgid "If you start instances with ``tarantool init.lua``, you need to pass other configuration options as command-line parameters and environment variables, for example:"
msgstr ""

msgid "Internal representation of clusterwide configuration"
msgstr ""

msgid "In the file system, clusterwide configuration is represented by a **file tree**. Inside ``workdir`` of any configured instance you can find the following directory:"
msgstr ""

msgid "This is the clusterwide configuration with three default **config sections** -- ``auth``, ``topology``, and ``vshard_groups``."
msgstr ""

msgid "Due to historical reasons clusterwide configuration has two appearances:"
msgstr ""

msgid "old-style single-file ``config.yml`` with all sections combined, and"
msgstr ""

msgid "modern multi-file representation mentioned above."
msgstr ""

msgid "Before cartridge v2.0 it used to look as follows, and this representation is still used in HTTP API and ``luatest`` helpers."
msgstr ""

msgid "Beyond these essential sections, clusterwide configuration may be used for storing some other role-specific data. Clusterwide configuration supports YAML as well as plain text sections. It can also be organized in nested subdirectories."
msgstr ""

msgid "In Lua it's represented by the ``ClusterwideConfig`` object (a table with metamethods). Refer to the ``cartridge.clusterwide-config`` module documentation for more details."
msgstr ""

msgid "Two-phase commit"
msgstr ""

msgid "Cartridge manages clusterwide configuration to be identical everywhere using the two-phase commit algorithm implemented in the ``cartridge.twophase`` module. Changes in clusterwide configuration imply applying it on every instance in the cluster."
msgstr ""

msgid "Almost every change in cluster parameters triggers a two-phase commit: joining/expelling a server, editing replica set roles, managing users, setting failover and vshard configuration."
msgstr ""

msgid "Two-phase commit requires all instances to be alive and healthy, otherwise it returns an error."
msgstr ""

msgid "For more details, please, refer to the ``cartridge.config_patch_clusterwide`` API reference."
msgstr ""

msgid "Managing role-specific data"
msgstr ""

msgid "Beside system sections, clusterwide configuration may be used for storing some other **role-specific data**. It supports YAML as well as plain text sections. And it can also be organized in nested subdirectories."
msgstr ""

msgid "Role-specific sections are used by some third-party roles, i.e. `sharded-queue <https://github.com/tarantool/sharded-queue>`_ and `cartridge-extensions <https://github.com/tarantool/cartridge-extensions>`_."
msgstr ""

msgid "A user can influence clusterwide configuration in various ways. You can alter configuration using Lua, HTTP or GraphQL API. Also there are `luatest <https://github.com/tarantool/luatest>`_ helpers available."
msgstr ""

msgid "HTTP API"
msgstr ""

msgid "It works with old-style single-file representation only. It's useful when there are only few sections needed."
msgstr ""

msgid "Example:"
msgstr ""

msgid "Upload new config:"
msgstr ""

msgid "Download it:"
msgstr ""

msgid "It's suitable for role-specific sections only. System sections (``topology``, ``auth``, ``vshard_groups``, ``users_acl``) can be neither uploaded nor downloaded."
msgstr ""

msgid "If authorization is enabled, use the ``curl`` option ``--user username:password``."
msgstr ""

msgid "GraphQL API, by contrast, is only suitable for managing plain-text sections in the modern multi-file appearance. It is mostly used by WebUI, but sometimes it's also helpful in tests:"
msgstr ""

msgid "Unlike HTTP API, GraphQL affects only the sections mentioned in the query. All the other sections remain unchanged."
msgstr ""

msgid "Similarly to HTTP API, GraphQL ``cluster {config}`` query isn't suitable for managing system sections."
msgstr ""

msgid "It's not the most convenient way to configure third-party role, but it may be useful for role development. Please, refer to the corresponding API reference:"
msgstr ""

msgid "``cartridge.config_patch_clusterwide``"
msgstr ""

msgid "``cartridge.config_get_deepcopy``"
msgstr ""

msgid "``cartridge.config_get_readonly``"
msgstr ""

msgid "Example (from ``sharded-queue``, simplified):"
msgstr ""

msgid "Luatest helpers"
msgstr ""

msgid "Cartridge test helpers provide methods for configuration management:"
msgstr ""

msgid "``cartridge.test-helpers.cluster:upload_config``,"
msgstr ""

msgid "``cartridge.test-helpers.cluster:download_config``."
msgstr ""

msgid "Internally they wrap the HTTP API."
msgstr ""

msgid "Deploying an application"
msgstr ""

msgid "After you've developed your application locally, you can deploy it to a test or production environment."
msgstr ""

msgid "\"Deploy\" includes packing the application into a specific distribution format, installing to the target system, and running the application."
msgstr ""

msgid "You have four options to deploy a Tarantool Cartridge application:"
msgstr ""

msgid "as an :ref:`rpm <cartridge-deploy-rpm>` package (for production);"
msgstr ""

msgid "as a :ref:`deb <cartridge-deploy-deb>` package (for production);"
msgstr ""

msgid "as a :ref:`tar+gz <cartridge-deploy-tgz>` archive (for testing, or as a workaround for production if root access is unavailable)."
msgstr ""

msgid ":ref:`from sources <cartridge-deploy-rock>` (for local testing only)."
msgstr ""

msgid "Deploying as an rpm or deb package"
msgstr ""

msgid "The choice between DEB and RPM depends on the package manager of the target OS. For example, DEB is native for Debian Linux, and RPM -- for CentOS."
msgstr ""

msgid "Pack the application into a distributable:"
msgstr ""

msgid "This will create an RPM package (e.g. ``./my_app-0.1.0-1.rpm``) or a DEB package (e.g. ``./my_app-0.1.0-1.deb``)."
msgstr ""

msgid "Upload the package to target servers, with ``systemctl`` supported."
msgstr ""

msgid "Install:"
msgstr ""

msgid "Configure the instance(s). Create a file called ``/etc/tarantool/conf.d/instances.yml``. For example:"
msgstr ""

msgid "See details :ref:`here <cartridge-config>`."
msgstr ""

msgid "Start Tarantool instances with the corresponding services. You can do it using :ref:`systemctl <cartridge-run-systemctl>`, for example:"
msgstr ""

msgid "In case it is a cluster-aware application, proceed to :ref:`deploying the cluster <cartridge-deployment>`."
msgstr ""

msgid "If you're migrating your application from local test environment to production, you can re-use your test configuration at this step:"
msgstr ""

msgid "In the cluster web interface of the test environment, click **Configuration files > Download** to save the test configuration."
msgstr ""

msgid "In the cluster web interface of the production environment, click **Configuration files > Upload** to upload the saved configuration."
msgstr ""

msgid "Deploying as a tar+gz archive"
msgstr ""

msgid "This will create a tar+gz archive (e.g. ``./my_app-0.1.0-1.tgz``)."
msgstr ""

msgid "Upload the archive to target servers, with ``tarantool`` and (optionally) :ref:`cartridge-cli <cartridge-install-dev>` installed."
msgstr ""

msgid "Extract the archive:"
msgstr ""

msgid "Start Tarantool instance(s). You can do it using:"
msgstr ""

msgid ":ref:`tarantool <cartridge-run-tarantool>`, for example:"
msgstr ""

msgid "or :ref:`cartridge <cartridge-run-cartridge>`, for example:"
msgstr ""

msgid "Deploying from sources"
msgstr ""

msgid "This deployment method is intended for local testing only."
msgstr ""

msgid "Pull all dependencies to the ``.rocks`` directory:"
msgstr ""

msgid "$ tarantoolctl rocks make"
msgstr ""

msgid "Starting/stopping instances"
msgstr ""

msgid "Depending on your :ref:`deployment method <cartridge-deploy>`, you can start/stop the instances using :ref:`tarantool <cartridge-run-tarantool>`, :ref:`cartridge CLI <cartridge-run-cartridge>`, or :ref:`systemctl <cartridge-run-systemctl>`."
msgstr ""

msgid "Start/stop using tarantool"
msgstr ""

msgid "With ``tarantool``, you can start only a single instance:"
msgstr ""

msgid "You can also :ref:`specify more options <cartridge-config-tarantool>` on the command line or in environment variables."
msgstr ""

msgid "To stop the instance, use Ctrl+C."
msgstr ""

msgid "Start/stop using cartridge CLI"
msgstr ""

msgid "With ``cartridge`` CLI, you can start one or multiple instances:"
msgstr ""

msgid "The options are:"
msgstr ""

msgid "``--script FILE``"
msgstr ""

msgid "Application's entry point. Defaults to:"
msgstr ""

msgid "``TARANTOOL_SCRIPT``, or"
msgstr ""

msgid "``./init.lua`` when running from the app's directory, or"
msgstr ""

msgid "``:apps_path/:app_name/init.lua`` in a multi-app environment."
msgstr ""

msgid "``--apps_path PATH``"
msgstr ""

msgid "Path to apps directory when running in a multi-app environment. Defaults to ``/usr/share/tarantool``."
msgstr ""

msgid "``--run_dir DIR``"
msgstr ""

msgid "Directory with pid and sock files. Defaults to ``TARANTOOL_RUN_DIR`` or ``/var/run/tarantool``."
msgstr ""

msgid "``--cfg FILE``"
msgstr ""

msgid "Cartridge instances YAML configuration file. Defaults to ``TARANTOOL_CFG`` or ``./instances.yml``. The ``instances.yml`` file contains ``cartridge.cfg()`` parameters described in the :ref:`configuration section <cartridge-config-basic>` of this guide."
msgstr ""

msgid "``--foreground``"
msgstr ""

msgid "Do not daemonize."
msgstr ""

msgid "It starts all ``tarantool`` instances specified in ``cfg`` file, in foreground, with enforced :ref:`environment variables <cartridge-config>`."
msgstr ""

msgid "When ``APP_NAME`` is not provided, ``cartridge`` parses it from ``./*.rockspec`` filename."
msgstr ""

msgid "When ``INSTANCE_NAME`` is not provided, ``cartridge`` reads ``cfg`` file and starts all defined instances:"
msgstr ""

msgid "To stop the instances, say:"
msgstr ""

msgid "These options from the ``cartridge start`` command are supported:"
msgstr ""

msgid "Start/stop using systemctl"
msgstr ""

msgid "To run a single instance:"
msgstr ""

msgid "This will start a  ``systemd`` service that will listen to the port specified in :ref:`instance configuration <cartridge-run-systemctl-config>` (``http_port`` parameter)."
msgstr ""

msgid "To run multiple instances on one or multiple servers:"
msgstr ""

msgid "where ``APP_NAME@INSTANCE_N`` is the instantiated service name for ``systemd`` with an incremental ``N`` -- a number, unique for every instance, added to the port the instance will listen to (e.g., ``3301``, ``3302``, etc.)"
msgstr ""

msgid "To stop all services on a server, use the ``systemctl stop`` command and specify instance names one by one. For example:"
msgstr ""

msgid "When running instances with ``systemctl``, keep these practices in mind:"
msgstr ""

msgid "You can specify *instance configuration* in a YAML file."
msgstr ""

msgid "This file can contain `these options <https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_api/modules/cartridge.argparse/#tables>`_; see an example `here <https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_cli/#usage-example>`_)."
msgstr ""

msgid "Save this file to ``/etc/tarantool/conf.d/`` (the default ``systemd`` path) or to a location set in the ``TARANTOOL_CFG`` environment variable (if you've edited the application's ``systemd`` unit file). The file name doesn't matter: it can be ``instances.yml`` or anything else you like."
msgstr ""

msgid "Here's what ``systemd`` is doing further:"
msgstr ""

msgid "obtains ``app_name`` (and ``instance_name``, if specified) from the name of the application's ``systemd`` unit file (e.g. ``APP_NAME@default`` or ``APP_NAME@INSTANCE_1``);"
msgstr ""

msgid "sets default console socket (e.g. ``/var/run/tarantool/APP_NAME@INSTANCE_1.control``), PID file (e.g. ``/var/run/tarantool/APP_NAME@INSTANCE_1.pid``) and ``workdir`` (e.g. ``/var/lib/tarantool/<APP_NAME>.<INSTANCE_NAME>``). Environment=TARANTOOL_WORKDIR=${workdir}.%i"
msgstr ""

msgid "Finally, ``cartridge`` looks across all YAML files in ``/etc/tarantool/conf.d`` for a section with the appropriate name (e.g. ``app_name`` that contains common configuration for all instances, and ``app_name.instance_1`` that contain instance-specific configuration). As a result, Cartridge options ``workdir``, ``console_sock``, and ``pid_file`` in the YAML file `cartridge.cfg <https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_api/modules/cartridge/#cfg-opts-box-opts>`_ become useless, because ``systemd`` overrides them."
msgstr ""

msgid "The default tool for querying logs is `journalctl <https://www.freedesktop.org/software/systemd/man/journalctl.html>`_. For example:"
msgstr ""

msgid "If really needed, you can change logging-related ``box.cfg`` options in the YAML configuration file: see `log <https://www.tarantool.io/en/doc/2.3/reference/configuration/#confval-log>`_ and other related options."
msgstr ""

msgid "Error handling guidelines"
msgstr ""

msgid "Almost all errors in Cartridge follow the ``return nil, err`` style, where ``err`` is an error object produced by Tarantool's `errors <https://github.com/tarantool/errors>`_ module. Cartridge doesn't raise errors except for bugs and functions contracts mismatch. Developing new roles should follow these guidelines as well."
msgstr ""

msgid "Error objects in Lua"
msgstr ""

msgid "Error classes help to locate the problem's source. For this purpose, an error object contains its class, stack traceback, and a message."
msgstr ""

msgid "For uniform error handling, ``errors`` provides the ``:pcall`` API:"
msgstr ""

msgid "For ``errors.pcall`` there is no difference between the ``return nil, err`` and ``error()`` approaches."
msgstr ""

msgid "Note that ``errors.pcall`` API differs from the vanilla Lua `pcall <https://www.lua.org/pil/8.4.html>`_. Instead of ``true`` the former returns values returned from the call. If there is an error, it returns ``nil`` instead of ``false``, plus an error message."
msgstr ""

msgid "Remote ``net.box`` calls keep no stack trace from the remote. In that case, ``errors.netbox_eval`` comes to the rescue. It will find a stack trace from local and remote hosts and restore metatables."
msgstr ""

msgid "However, ``vshard`` implemented in Tarantool doesn't utilize the ``errors`` module. Instead it uses `its own errors <https://github.com/tarantool/vshard/blob/master/vshard/error.lua>`_. Keep this in mind when working with ``vshard`` functions."
msgstr ""

msgid "Data included in an error object (class name, message, traceback) may be easily converted to string using the ``tostring()`` function."
msgstr ""

msgid "GraphQL"
msgstr ""

msgid "GraphQL implementation in Cartridge wraps the ``errors`` module, so a typical error response looks as follows:"
msgstr ""

msgid "Read more about errors in the `GraphQL specification <http://spec.graphql.org/draft/#sec-Errors.Error-result-format>`_."
msgstr ""

msgid "If you're going to implement a GraphQL handler, you can add your own extension like this:"
msgstr ""

msgid "It will lead to the following response:"
msgstr ""

msgid "HTTP"
msgstr ""

msgid "In a nutshell, an ``errors`` object is a table. This means that it can be swiftly represented in JSON. This approach is used by Cartridge to handle errors via http:"
msgstr ""
