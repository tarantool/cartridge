
msgid "Tarantool Cartridge developer's guide"
msgstr "Руководство разработчика Tarantool Cartridge"

msgid ""
"For a quick start, skip the details below and jump right away to this "
"detailed `guide <https://github.com/tarantool/cartridge-"
"cli/blob/master/examples/getting-started-app/README.md>`_ to creating a "
"cluster-aware Tarantool application."
msgstr ""
"Если вам необходимо быстро начать работу, можете спокойно пропустить "
"подробное описание ниже и сразу перейти к подробному `руководству "
"<https://github.com/tarantool/cartridge-cli/blob/master/examples/getting-"
"started-app/README.md>`_ по созданию Tarantool-приложения с поддержкой "
"кластера."

msgid ""
"For a deep dive into what you can do with Tarantool Cartridge, go on with"
" this section."
msgstr ""
"Если же вы хотите всесторонне изучить возможности Tarantool Cartridge, "
"продолжайте читать этот раздел."

msgid ""
"To develop and start an application, in short, you need to go through the"
" following steps:"
msgstr ""
"Короче говоря, чтобы разработать и запустить приложение, вам необходимо "
"выполнить следующие шаги:"

msgid ""
":ref:`Install <cartridge-install>` Tarantool Cartridge and other "
"components of the development environment."
msgstr ""
":ref:`Установить <cartridge-install>` Tarantool Cartridge и другие "
"компоненты среды разработки."

msgid ""
"Choose a :ref:`template <cartridge-templates>` for the application and "
"create a project."
msgstr ""
"Выбрать :ref:`шаблон <cartridge-templates>` для приложения и создать "
"проект."

msgid ""
"Develop the application. In case it is a cluster-aware application, "
"implement its logic in a custom (user-defined) :ref:`cluster role "
"<cartridge-roles>` to initialize the database in a cluster environment."
msgstr ""
"Разработать приложение. Если это приложение с поддержкой кластеров, "
"реализуйте его логику в виде отдельной (пользовательской) "
":ref:`кластерной роли <cartridge-roles>`, чтобы инициализировать базу "
"данных в кластерной среде."

msgid ""
":ref:`Deploy <cartridge-deploy>` the application to target server(s). "
"This includes :ref:`configuring <cartridge-config>` and :ref:`starting "
"<cartridge-run>` the instance(s)."
msgstr ""
":ref:`Развернуть <cartridge-deploy>` приложение на сервере или серверах. "
"Это включает в себя :ref:`настройку <cartridge-config>` и :ref:`запуск "
"<cartridge-run>` экземпляров."

msgid ""
"In case it is a cluster-aware application, :ref:`deploy the cluster "
"<cartridge-deployment>`."
msgstr ""
"Если это приложение с поддержкой кластеров, :ref:`развернуть кластер "
"<cartridge-deployment>`."

msgid "The following sections provide details for each of these steps."
msgstr "В следующих разделах подробно описывается каждый из этих шагов."

msgid "Installing Tarantool Cartridge"
msgstr "Установка Tarantool Cartridge"

msgid ""
"Install ``catridge-cli``, a command-line tool for developing, deploying, "
"and managing Tarantool applications:"
msgstr ""
"Установите ``catridge-cli`` -- инструмент командной строки для "
"разработки, развертывания и управления Tarantool-приложениями:"

msgid "$ tarantoolctl rocks install cartridge-cli"
msgstr "$ tarantoolctl rocks install cartridge-cli"

msgid ""
"The Cartridge framework will come as a dependency when you create your "
"project."
msgstr "Среда Cartridge станет зависимостью при создании проекта."

msgid ""
"Everything will be installed to ``.rocks/bin``, so for convenient usage "
"add ``.rocks/bin`` to the executable path:"
msgstr ""
"Все будет установлено в ``.rocks/bin``, поэтому для удобства "
"использования добавьте ``.rocks/bin`` в путь к исполняемому файлу:"

msgid "$ export PATH=$PWD/.rocks/bin/:$PATH"
msgstr "$ export PATH=$PWD/.rocks/bin/:$PATH"

msgid "Install ``git``, a version control system."
msgstr "Установите ``git``, систему управления версиями."

msgid "Install ``npm``, a package manager for ``node.js``."
msgstr "Установите ``npm``, менеджер пакетов для ``node.js``."

msgid "Install the ``unzip`` utility."
msgstr "Установите утилиту ``unzip``."

msgid "Application templates"
msgstr "Шаблоны приложений"

msgid ""
"Tarantool Cartridge provides you with two templates that help instantly "
"set up the application development environment:"
msgstr ""
"В Tarantool Cartridge есть два шаблона, которые помогут вам мгновенно "
"настроить среду разработки приложений:"

msgid ""
"``plain``, for developing an application that runs on a single or "
"multiple independent Tarantool instances (e.g. acting as a proxy to "
"third-party databases) -- that's what you could do before, :ref:`without "
"Tarantool Cartridge <app_server-creating_app>`, but now it's more "
"convenient."
msgstr ""
"``plain`` -- для разработки приложения, которое работает на одном или "
"нескольких независимых экземплярах Tarantool'а (например, в качестве "
"прокси для сторонних баз данных), что можно было делать и раньше "
":ref:`без Tarantool Cartridge <app_server-creating_app>`, но теперь это "
"гораздо удобнее."

msgid ""
"``cartridge``, for developing a cluster-aware application -- this is an "
"exclusive feature of Tarantool Cartridge."
msgstr ""
"``cartridge`` -- для разработки приложений с поддержкой кластеров -- "
"эксклюзивная функция Tarantool Cartridge."

msgid "To create a project based on either template, in any directory say:"
msgstr ""
"Чтобы создать проект на основе одного из шаблонов, в любой директории "
"выполните команду:"

msgid ""
"# plain application\n"
"$ plain create --name <app_name> /path/to/\n"
"\n"
"# - OR -\n"
"\n"
"# cluster application\n"
"$ cartridge create --name <app_name> /path/to/"
msgstr ""
"# простое приложение\n"
"$ plain create --name <имя_приложения> /path/to/\n"
"\n"
"# - ИЛИ -\n"
"\n"
"# кластерное приложение\n"
"$ cartridge create --name <имя_приложения> /path/to/"

msgid ""
"This will automatically set up a Git repository in a new "
"``/path/to/<app_name>/`` directory, tag it with :ref:`version <cartridge-"
"versioning>` ``0.1.0``, and put the necessary files into it (read about "
"default files for each template below)."
msgstr ""
"Это автоматически настроит Git-репозиторий в новой директории "
"``/path/to/<имя_приложения>/``, проставит тег с :ref:`версией <cartridge-"
"versioning>` ``0.1.0`` и поместит туда необходимые файлы (файлы, "
"размещаемые по умолчанию в каждом шаблоне, описаны ниже)."

msgid ""
"In this Git repository, you can develop the application (by simply "
"editing the default files provided by the template), plug the necessary "
"modules, and then easily pack everything to deploy on your server(s)."
msgstr ""
"В этом Git-репозитории можно разработать приложение (просто редактируя "
"файлы из шаблона), подключить необходимые модули, а затем с легкостью "
"упаковать все для развертывания на своих серверах."

msgid "Plain template"
msgstr "Шаблон plain"

msgid ""
"The plain template creates the ``<app_name>/`` directory with the "
"following contents:"
msgstr ""
"Шаблон plain создает директорию ``<имя_приложения>/``, которая содержит "
"следующее:"

msgid ""
"``<app_name>-scm-1.rockspec`` file where you can specify the application "
"dependencies."
msgstr ""
"файл ``<имя_приложения>-scm-1.rockspec``, где можно указать зависимости "
"приложения."

msgid "``deps.sh`` script that resolves dependencies from the ``.rockspec`` file."
msgstr ""
"скрипт ``deps.sh``, который решает проблемы с зависимостями из файла "
"``.rockspec``."

msgid "``init.lua`` file which is the entry point for your application."
msgstr "файл ``init.lua``, который является точкой входа в ваше приложение."

msgid "``.git`` file necessary for a Git repository."
msgstr "файл ``.git``, необходимый для Git-репозитория."

msgid "``.gitignore`` file to ignore the unnecessary files."
msgstr "файл ``.gitignore``, чтобы не учитывать ненужные файлы."

msgid "Cluster template"
msgstr "Шаблон cluster"

msgid ""
"In addition to the files listed in the plain template section, the "
"cluster template contains the following:"
msgstr ""
"Помимо файлов, перечисленным в разделе о шаблоне plain, шаблон cluster "
"содержит следующее:"

msgid ""
"``env.lua`` file that sets common rock paths so that the application can "
"be started from any directory."
msgstr ""
"файл ``env.lua``, который устанавливает общие пути для модулей, чтобы "
"приложение можно было запустить из любой директории."

msgid ""
"``custom-role.lua`` file that is a placeholder for a custom (user-"
"defined) :ref:`cluster role <cartridge-roles>`."
msgstr ""
"файл ``custom-role.lua``, который представляет собой объект-заполнитель "
"для пользовательской :ref:`кластерной роли <cartridge-roles>`."

msgid ""
"The entry point file (``init.lua``) of the cluster template differs from "
"the plain one. Among other things, it loads the ``cartridge`` module and "
"calls its initialization function:"
msgstr ""
"Файл входа в приложение (``init.lua``) в шаблоне cluster отличается от "
"аналогичного файла в шаблоне plain. Помимо прочего, он загружает модуль "
"``cartridge`` и вызывает его функцию инициализации:"

#, fuzzy
msgid ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"-- cartridge options example\n"
"  workdir = '/var/lib/tarantool/app',\n"
"  advertise_uri = 'localhost:3301',\n"
"  cluster_cookie = 'super-cluster-cookie',\n"
"  ...\n"
"}, {\n"
"-- box options example\n"
"  memtx_memory = 1000000000,\n"
"  ... })\n"
" ..."
msgstr ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  cluster_cookie = ...,\n"
"  ...\n"
"})\n"
"..."

msgid ""
"The ``cartridge.cfg()`` call renders the instance operable via the "
"administrative console but does not call ``box.cfg()`` to configure "
"instances."
msgstr ""
"Вызов ``cartridge.cfg()`` позволяет управлять экземпляром через "
"административную консоль, но не вызывает ``box.cfg()`` для настройки "
"экземпляров."

msgid "Calling the ``box.cfg()`` function is forbidden."
msgstr "Запрещается вызывать функцию ``box.cfg()``."

msgid "The cluster itself will do it for you when it is time to:"
msgstr "Сам кластер сделает это за вас, когда придет время:"

msgid "bootstrap the current instance once you:"
msgstr "загрузить текущий экземпляр, когда вы:"

msgid "run ``cartridge.bootstrap()`` via the administrative console, or"
msgstr "выполните ``cartridge.bootstrap()`` в административной консоли, или"

msgid "click **Create** in the web interface;"
msgstr "нажмете **Create** (Создать) в веб-интерфейсе;"

msgid "join the instance to an existing cluster once you:"
msgstr "присоединить экземпляр к существующему кластеру, когда вы:"

msgid ""
"run ``cartridge.join_server({uri = 'other_instance_uri'})`` via the "
"console, or"
msgstr ""
"выполните ``cartridge.join_server({uri = ''uri_другого_экземпляра'})`` в "
"консоли, или"

msgid ""
"click **Join** (an existing replica set) or **Create** (a new replica "
"set) in the web interface."
msgstr ""
"нажмете **Join** (Присоединить -- к уже существующему набору реплик) или "
"**Create** (Создать -- для нового набора реплик) в веб-интерфейсе."

msgid ""
"Notice that you can specify a cookie for the cluster (``cluster_cookie`` "
"parameter) if you need to run several clusters in the same network. The "
"cookie can be any string value."
msgstr ""
"Обратите внимание, что вы можете указать cookie для кластера (параметр "
"``cluster_cookie``), если необходимо запустить несколько кластеров в "
"одной сети. Cookie может представлять собой любое строковое значение."

msgid ""
"Before developing a cluster-aware application, familiarize yourself with "
"the notion of :ref:`cluster roles <cartridge-roles>` and make sure to "
"define a custom role to initialize the database for the cluster "
"application."
msgstr ""
"Перед тем как разрабатывать приложение с поддержкой кластеров, "
"ознакомьтесь с понятием :ref:`кластерных ролей <cartridge-roles>` и "
"обязательно определите специальную роль для инициализации базы данных для"
" кластерного приложения."

msgid "Cluster roles"
msgstr "Кластерные роли"

msgid ""
"A Tarantool Cartridge cluster segregates instance functionality in a "
"role-based way. **Cluster roles** are Lua modules that implement some "
"instance-specific functions and/or logic."
msgstr ""
"Кластер Tarantool Cartridge распределяет функции экземпляров на основе "
"ролей. **Кластерные роли** -- это Lua-модули, которые реализуют некоторые"
" заданные для экземпляра функции и/или логику."

msgid ""
"Since all instances running cluster applications use the same source code"
" and are aware of all the defined roles (and plugged modules), multiple "
"different roles can be dynamically enabled and disabled on any number of "
"instances without restarts even during cluster operation."
msgstr ""
"Поскольку все экземпляры, на которых запущены кластерные приложения, "
"используют один и тот же исходный код и знают обо всех определенных ролях"
" (и подключенных модулях), можно динамически включать и отключать "
"несколько разных ролей на любом количестве экземпляров без перезапусков "
"даже во время работы кластера."

msgid "Built-in roles"
msgstr "Встроенные роли"

msgid ""
"The ``cartridge`` module comes with two *built-in* roles that implement "
"automatic sharding:"
msgstr ""
"В модуль ``cartridge`` входят две *встроенные* роли, которые реализуют "
"автоматический шардинг:"

msgid ""
"``vshard-router`` that handles the ``vshard``'s *compute-intensive* "
"workload: routes requests to storage nodes."
msgstr ""
"``vshard-router`` обрабатывает *ресурсоемкие* вычисления в ``vshard``: "
"направляет запросы к узлам хранения данных."

msgid ""
"``vshard-storage`` that handles the ``vshard``'s *transaction-intensive* "
"workload: stores and manages a subset of a dataset."
msgstr ""
"``vshard-storage`` работает с *большим количеством транзакций* в "
"``vshard``: хранит подмножество набора данных и управляет им."

msgid ""
"For more information on sharding, see the :ref:`vshard module "
"documentation <vshard>`."
msgstr ""
"Для получения дополнительной информации о шардинге см. :ref:`докуемнтацию"
" по модулю vshard <vshard>`."

msgid ""
"With the built-in and custom roles, Tarantool Cartridge allows you to "
"develop applications with separated compute and transaction handling. "
"Later, the relevant workload-specific roles can be enabled on different "
"instances running on physical servers with workload-dedicated hardware."
msgstr ""
"Благодаря встроенным и пользовательским ролям, Tarantool Cartridge "
"позволяет разрабатывать приложения, где вычисления отделены от обработки "
"транзакций. Позже соответствующие роли в зависимости от рабочей нагрузки "
"можно включить на разных экземплярах, которые работают на физических "
"серверах с оборудованием, выделенным для рабочей нагрузки."

msgid ""
"Neither ``vshard-router`` nor ``vshard-storage`` manage spaces, indexes, "
"or formats. To start developing an application, edit the ``custom-"
"role.lua`` placeholder file: add a ``box.schema.space.create()`` call to "
"your first cluster role."
msgstr ""
"Ни ``vshard-router``, ни ``vshard-storage`` не управляют спейсами, "
"индексами и форматами. Чтобы начать разработку приложения, отредактируйте"
" файл-заглушку ``custom-role.lua``: добавьте вызов "
"``box.schema.space.create()`` в свою первую кластерную роль."

msgid "Additionally, you can implement several such roles to:"
msgstr "Кроме того, можно реализовать несколько таких ролей, чтобы:"

msgid "define stored procedures;"
msgstr "определять хранимые процедуры;"

msgid "implement functionality on top of ``vshard``;"
msgstr "реализовать функции поверх ``vshard``;"

msgid "go without ``vshard`` at all;"
msgstr "полностью обойтись без ``vshard``;"

msgid ""
"implement one or multiple supplementary services such as e-mail notifier,"
" replicator, etc."
msgstr ""
"внедрить одну или несколько дополнительных служб, таких как средство "
"уведомления по электронной почте, репликатор и т.д."

msgid "Custom roles"
msgstr "Пользовательские роли"

msgid "To implement a *custom* cluster role, do the following:"
msgstr ""
"Чтобы внедрить *пользовательскую* кластерную роль, выполните следующие "
"действия:"

msgid ""
"Register the new role in the cluster by modifying the ``cartridge.cfg()``"
" call in the ``init.lua`` entry point file:"
msgstr ""
"Зарегистрируйте новую роль в кластере, изменив вызов ``cartridge.cfg()`` "
"в файле входа в приложение ``init.lua``:"

msgid ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  roles = {'custom-role'},\n"
"})\n"
"..."
msgstr ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  roles = {'custom-role'},\n"
"})\n"
"..."

msgid "where ``custom-role`` is the name of the Lua module to be loaded."
msgstr ""
"где ``custom-role`` (пользовательская роль) -- это название загружаемого "
"Lua-модуля."

msgid ""
"Implement the role in a file with the appropriate name (``custom-"
"role.lua``). For example:"
msgstr ""
"Поместите роль в файл с соответствующим именем (``custom-role.lua``). "
"Например:"

msgid ""
"#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"local role_name = 'custom-role'\n"
"\n"
"local function init()\n"
"...\n"
"end\n"
"\n"
"local function stop()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    init = init,\n"
"    stop = stop,\n"
"}"
msgstr ""
"#!/usr/bin/env tarantool\n"
"-- Реализация пользовательской роли\n"
"local role_name = 'custom-role'\n"
"\n"
"local function init()\n"
"...\n"
"end\n"
"\n"
"local function stop()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    init = init,\n"
"    stop = stop,\n"
"}"

msgid ""
"Where the ``role_name`` may differ from the module name passed to the "
"``cartridge.cfg()`` function. If the ``role_name`` variable is not "
"specified, the module name is the default value."
msgstr ""
"Где имя роли ``role_name`` может отличаться от имени модуля, переданного "
"в функции ``cartridge.cfg()``. Если не указать переменную ``role_name``, "
"по умолчанию будет использовано имя модуля."

msgid ""
"Role names must be unique as it is impossible to register multiple roles "
"with the same name."
msgstr ""
"Имена ролей должны быть уникальными, поскольку невозможно "
"зарегистрировать несколько ролей с одним именем."

msgid ""
"The role module does not have required functions but the cluster may "
"execute the following ones during the role's life cycle:"
msgstr ""
"В модуле роли нет необходимых функций, но в течение жизненного цикла роли"
" кластер может выполнять следующие функции:"

msgid "``init()`` is the role's *initialization* function."
msgstr "``init()`` -- это функция *инициализации* роли."

msgid ""
"Inside the function's body you can call any ``box`` functions: create "
"spaces, indexes, grant permissions, etc. Here is what the initialization "
"function may look like:"
msgstr ""
"В теле функции можно вызывать любые функции из ``box``: создавать спейсы,"
" индексы, выдавать права и т.д. Вот как может выглядеть функция "
"инициализации:"

msgid ""
"local function init(opts)\n"
"    -- The cluster passes an 'opts' Lua table containing an 'is_master' "
"flag.\n"
"    if opts.is_master then\n"
"        local customer = box.schema.space.create('customer',\n"
"            { if_not_exists = true }\n"
"        )\n"
"        customer:format({\n"
"            {'customer_id', 'unsigned'},\n"
"            {'bucket_id', 'unsigned'},\n"
"            {'name', 'string'},\n"
"        })\n"
"        customer:create_index('customer_id', {\n"
"            parts = {'customer_id'},\n"
"            if_not_exists = true,\n"
"        })\n"
"    end\n"
"end"
msgstr ""
"local function init(opts)\n"
"    -- Кластер передает Lua-таблицу 'opts', которая содержит флаг "
"'is_master'.\n"
"    if opts.is_master then\n"
"        local customer = box.schema.space.create('customer',\n"
"            { if_not_exists = true }\n"
"        )\n"
"        customer:format({\n"
"            {'customer_id', 'unsigned'},\n"
"            {'bucket_id', 'unsigned'},\n"
"            {'name', 'string'},\n"
"        })\n"
"        customer:create_index('customer_id', {\n"
"            parts = {'customer_id'},\n"
"            if_not_exists = true,\n"
"        })\n"
"    end\n"
"end"

msgid ""
"The function's body is wrapped in a conditional statement that lets you "
"call ``box`` functions on masters only. This protects against replication"
" collisions as data propagates to replicas automatically."
msgstr ""
"Тело функции заключено в условный оператор, который позволяет вызывать "
"функции ``box`` только на мастерах. Это предотвращает конфликты "
"репликации, так как данные автоматически передаются на реплики."

msgid ""
"``stop()`` is the role's *termination* function. Implement it if "
"initialization starts a fiber that has to be stopped or does any job that"
" has to be undone on termination."
msgstr ""
"``stop()`` это функция *завершения работы* роли. Используйте ее, если "
"инициализация запускает файбер, который необходимо остановить, или же "
"выполняет любую задачу, которую следует отменить при завершении работы."

msgid ""
"``validate_config()`` and ``apply_config()`` are *validation* and "
"*application* functions that make custom roles configurable. Implement "
"them if some configuration data has to be stored cluster-wide."
msgstr ""
"``validate_config()`` и ``apply_config()`` -- это функции *валидации* и "
"*применения  конфигурации* соответственно, которые обеспечивают "
"возможность настройки ролей. Используйте их, если некоторые настройки "
"должны храниться на уровне кластера."

msgid ""
"Next, get a grip on the :ref:`role's life cycle <cartridge-role-"
"lifecycle>` to implement the necessary functions."
msgstr ""
"Затем изучите :ref:`жизненный цикл роли <cartridge-role-lifecycle>`, "
"чтобы реализовать необходимые функции."

msgid "Defining role dependencies"
msgstr "Определение зависимостей для ролей"

msgid ""
"You can instruct the cluster to apply some other roles if your custom "
"role is enabled."
msgstr ""
"Можно заставить кластер применить некоторые другие роли, если включена "
"пользовательская роль."

msgid "For example:"
msgstr "Например:"

msgid ""
"-- Role dependencies defined in custom-role.lua\n"
"local role_name = 'custom-role'\n"
"...\n"
"return {\n"
"    role_name = role_name,\n"
"    dependencies = {'cartridge.roles.vshard-router'},\n"
"    ...\n"
"}"
msgstr ""
"-- Зависимости между ролями, заданные в пользовательской роли custom-"
"role.lua\n"
"local role_name = 'custom-role'\n"
"...\n"
"return {\n"
"    role_name = role_name,\n"
"    dependencies = {'cartridge.roles.vshard-router'},\n"
"    ...\n"
"}"

msgid ""
"Here ``vshard-router`` role will be initialized automatically for every "
"instance with ``custom-role`` enabled."
msgstr ""
"Здесь роль ``vshard-router`` будет инициализирована автоматически для "
"каждого экземпляра, в котором включена роль ``custom-role``."

msgid "Using multiple vshard storage groups"
msgstr "Использование нескольких групп vshard storage"

msgid ""
"Replica sets with ``vshard-storage`` roles can belong to different "
"*groups*. For example, ``hot`` or ``cold`` groups meant to independently "
"process hot and cold data."
msgstr ""
"Для наборов реплик с ролью ``vshard-storage`` можно задавать *группы*. "
"Например, группы ``hot`` и ``cold`` предназначены для независимой "
"обработки горячих и холодных данных."

msgid "Groups are specified in the cluster's configuration:"
msgstr "Группы указаны в конфигурации кластера:"

msgid ""
"cartridge.cfg({\n"
"    vshard_groups = {'hot', 'cold'},\n"
"    ...\n"
"})"
msgstr ""
"cartridge.cfg({\n"
"    vshard_groups = {'hot', 'cold'},\n"
"    ...\n"
"})"

msgid ""
"If no groups are specified, the cluster assumes that all replica sets "
"belong to the ``default`` group."
msgstr ""
"Если ни одна группа не указана, кластер предполагает, что все наборы "
"реплик входят в группу ``default`` (по умолчанию)."

msgid ""
"With multiple groups enabled, every replica set with a ``vshard-storage``"
" role enabled must be assigned to a particular group. The assignment can "
"never be changed."
msgstr ""
"Если включены несколько групп, каждый набор реплик с включенной ролью "
"``vshard-storage`` должен быть назначен в определенную группу. Эту "
"настройку нельзя изменить впоследствии."

msgid ""
"Another limitation is that you cannot add groups dynamically (this will "
"become available in future)."
msgstr ""
"Есть еще одно ограничение -- нельзя добавлять группы динамически (такая "
"возможность появится в будущих версиях)."

msgid ""
"Finally, mind the new syntax for router access. Every instance with a "
"``vshard-router`` role enabled initializes multiple routers. All of them "
"are accessible through the role:"
msgstr ""
"Наконец, обратите внимание на новый синтаксис для доступа к роутеру. "
"Каждый экземпляр со включенной ролью ``vshard-router`` инициализирует "
"несколько роутеров. Доступ к ним можно получить через роль:"

msgid ""
"local router_role = cartridge.service_get('vshard-router')\n"
"router_role.get('hot'):call(...)"
msgstr ""
"local router_role = cartridge.service_get('vshard-router')\n"
"router_role.get('hot'):call(...)"

msgid "If you have no roles specified, you can access a static router as before:"
msgstr ""
"Если роли не указаны, доступ к статическому роутеру можно получить, как и"
" прежде:"

msgid ""
"local vhsard = require('vshard')\n"
"vshard.router.call(...)"
msgstr ""
"local vhsard = require('vshard')\n"
"vshard.router.call(...)"

msgid ""
"However, when using the new API, you must call a static router with a "
"colon:"
msgstr ""
"Тем не менее, при использовании нового API следует вызывать статический "
"роутер при помощи двоеточия:"

msgid ""
"local router_role = cartridge.service_get('vshard-router')\n"
"local default_router = router_role.get() -- or router_role.get('default')"
"\n"
"default_router:call(...)"
msgstr ""
"local router_role = cartridge.service_get('vshard-router')\n"
"local default_router = router_role.get() -- или "
"router_role.get('default')\n"
"default_router:call(...)"

msgid "Role's life cycle and the order of function execution"
msgstr "Жизненный цикл роли и порядок выполнения функций"

msgid ""
"The cluster displays all custom role names along with the built-in "
"``vshard`` ones in the web interface. Cluster administrators can enable "
"and disable them for particular instances either via the web interface or"
" cluster public API. For example:"
msgstr ""
"Кластер отображает все имена пользовательских ролей вместе с именами "
"встроенных ролей из ``vshard`` в веб-интерфейсе. Администраторы кластера "
"могут включать и отключать их для определенных экземпляров либо через "
"веб-интерфейс, либо через общедоступный API кластера. Например:"

msgid ""
"cartridge.admin.edit_replicaset('replicaset-uuid', {roles = {'vshard-"
"router', 'custom-role'}})"
msgstr ""
"cartridge.admin.edit_replicaset('uuid-набора-реплик', {roles = {'vshard-"
"router', 'пользователськая-роль'}})"

msgid ""
"If multiple roles are enabled on an instance at the same time, the "
"cluster first initializes the built-in roles (if any) and then the custom"
" ones (if any) in the order the latter were listed in "
"``cartridge.cfg()``."
msgstr ""
"Если несколько ролей одновременно включены на экземпляре, кластер сначала"
" инициализирует встроенные роли (если они есть), а затем пользовательские"
" (если они есть) в том порядке, в котором последние были перечислены в "
"``cartridge.cfg()``."

msgid ""
"If a custom role has dependent roles, the dependencies are registered and"
" validated first, prior to the role itself."
msgstr ""
"Если у пользовательской роли есть зависимые роли, сначала происходит "
"регистрация и валидация зависимостей, а затем уже самой роли."

msgid "The cluster calls the role's functions in the following circumstances:"
msgstr "Кластер вызывает функции роли в следующих случаях:"

msgid ""
"The ``init()`` function, typically, once: either when the role is enabled"
" by the administrator or at the instance restart. Enabling a role once is"
" normally enough."
msgstr ""
"Функция ``init()`` обычно выполняется один раз: либо когда администратор "
"включает роль, либо при перезапуске экземпляра. Как правило, достаточно "
"один раз включить роль."

msgid ""
"The ``stop()`` function -- only when the administrator disables the role,"
" not on instance termination."
msgstr ""
"Функция ``stop()`` -- только когда администратор отключает роль, а не во "
"время завершения работы экземпляра."

msgid ""
"The ``validate_config()`` function, first, before the automatic "
"``box.cfg()`` call (database initialization), then -- upon every "
"configuration update."
msgstr ""
"Функция ``validate_config()``: сначала до автоматического вызова "
"`box.cfg()`` (инициализация базы данных), а затем при каждом обновлении "
"конфигурации."

msgid "The ``apply_config()`` function upon every configuration update."
msgstr "Функция ``apply_config()`` -- при каждом обновлении конфигурации."

msgid ""
"Hence, if the cluster is tasked with performing the following actions, it"
" will execute the functions listed in the following order:"
msgstr ""
"Таким образом, если поставить для кластера задачу выполнить следующие "
"действия, он будет выполнять перечисленные функции в следующем порядке:"

msgid "Join an instance or create a replica set, both with an enabled role:"
msgstr ""
"Присоединение экземпляра или создание набора реплик (в обоих случаях с "
"включенной ролью):"

msgid "``validate_config()``"
msgstr "``validate_config()``"

msgid "``init()``"
msgstr "``init()``"

msgid "``apply_config()``"
msgstr "``apply_config()``"

msgid "Restart an instance with an enabled role:"
msgstr "Перезапуск экземпляра с включенной ролью:"

msgid "Disable role: ``stop()``."
msgstr "Отключение роли: ``stop()``."

msgid "Upon the ``cartridge.confapplier.patch_clusterwide()`` call:"
msgstr "При вызове ``cartridge.confapplier.patch_clusterwide()``:"

msgid "Upon a triggered failover:"
msgstr "При запущенном восстановлении после отказа:"

msgid "Considering the described behavior:"
msgstr "Учитывая вышеописанное поведение:"

msgid "The ``init()`` function may:"
msgstr "Функция ``init()`` может:"

msgid "Call ``box`` functions."
msgstr "Вызывать функции ``box``."

msgid ""
"Start a fiber and, in this case, the ``stop()`` function should take care"
" of the fiber's termination."
msgstr ""
"Запускать файбер, и в таком случае функция ``stop()`` должна позаботиться"
" о завершении работы файбера."

msgid "Configure the built-in :ref:`HTTP server <cartridge-httpd-instance>`."
msgstr "Настраивать встроенный :ref:`HTTP-сервер <cartridge-httpd-instance>`."

msgid "Execute any code related to the role's initialization."
msgstr "Выполнять любой код, связанный с инициализацией роли."

msgid ""
"The ``stop()`` functions must undo any job that has to be undone on "
"role's termination."
msgstr ""
"Функции ``stop()`` должны отменять любую задачу, которую необходимо "
"отменить при завершении работы роли."

msgid "The ``validate_config()`` function must validate any configuration change."
msgstr ""
"Функция ``validate_config()`` должна валидировать любые изменения "
"конфигурации."

msgid ""
"The ``apply_config()`` function may execute any code related to a "
"configuration change, e.g., take care of an ``expirationd`` fiber."
msgstr ""
"Функция ``apply_config()`` может выполнять любой код, связанный с "
"изменением конфигурации, например, следить за файбером ``expirationd``."

msgid ""
"The validation and application functions together allow you to customize "
"the cluster-wide configuration as described in the :ref:`next section "
"<cartridge-role-config>`."
msgstr ""
"Функции валидации и применения конфигурации вместе позволяют настраивать "
"конфигурацию всего кластера, как описано в :ref:`следующем разделе "
"<cartridge-role-config>`."

msgid "Configuring custom roles"
msgstr "Конфигурация пользовательских ролей"

msgid "You can:"
msgstr "Доступны следующие операции:"

msgid ""
"Store configurations for your custom roles as sections in cluster-wide "
"configuration, for example:"
msgstr ""
"Хранить настройки пользовательских ролей в виде разделов в конфигурации "
"на уровне кластера, например:"

msgid ""
"# YAML configuration file\n"
"my_role:\n"
"  notify_url: \"https://localhost:8080\""
msgstr ""
"# YAML configuration file\n"
"my_role:\n"
"  notify_url: \"https://localhost:8080\""

msgid ""
"-- init.lua file\n"
"local notify_url = 'http://localhost'\n"
"function my_role.apply_config(conf, opts)\n"
"  local conf = conf['my_role'] or {}\n"
"  notify_url = conf.notify_url or 'default'\n"
"end"
msgstr ""
"-- init.lua file\n"
"local notify_url = 'http://localhost'\n"
"function my_role.apply_config(conf, opts)\n"
"  local conf = conf['my_role'] or {}\n"
"  notify_url = conf.notify_url or 'default'\n"
"end"

msgid ""
"Download and upload cluster-wide configuration using :ref:`cluster UI "
"<cartridge-ui-configuration>` or API (via GET/PUT queries to "
"``admin/config`` endpoint like ``curl localhost:8081/admin/config`` and "
"``curl -X PUT -d \"{'my_parameter': 'value'}\" "
"localhost:8081/admin/config``)."
msgstr ""
"Загружать и выгружать конфигурацию всего кластера через "
":ref:`веб-интерфейс кластера <cartridge-ui-configuration>` или с помощью "
"API (запросы GET/PUT к конечной точке ``admin/config``: ``curl "
"localhost:8081/admin/config`` и ``curl -X PUT -d \"{'my_parameter': "
"'value'}\" localhost:8081/admin/config``)."

msgid "Utilize it in your role ``apply_config()`` function."
msgstr "Использовать ее в своей функции ``apply_config()``."

msgid ""
"Every instance in the cluster stores a copy of the configuration file in "
"its working directory (configured by ``cartridge.cfg({workdir = ...})``):"
msgstr ""
"Каждый экземпляр в кластере хранит копию конфигурационного файла в своей "
"рабочей директории (которую можно задать с помощью "
"``cartridge.cfg({workdir = ...})``):"

msgid ""
"``/var/lib/tarantool/<instance_name>/config.yml`` for instances deployed "
"from RPM packages and managed by ``systemd``."
msgstr ""
"``/var/lib/tarantool/<instance_name>/config.yml`` для экземпляров, "
"развернутых из RPM-пакетов, под управлением ``systemd``."

msgid ""
"``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` for "
"instances deployed from archives."
msgstr ""
"``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` для "
"экземпляров, развернутых из архивов, под управлением ``tarantoolctl``."

msgid ""
"The cluster's configuration is a Lua table, downloaded and uploaded as "
"YAML. If some application-specific configuration data, e.g., a database "
"schema as defined by DDL (data definition language), has to be stored on "
"every instance in the cluster, you can implement your own API by adding a"
" custom section to the table. The cluster will help you spread it safely "
"across all instances."
msgstr ""
"Конфигурация кластера представляет собой Lua-таблицу. Если некоторые "
"данные конфигурации для конкретного приложения (например, схему базы "
"данных, описанную с помощью языка определения данных DDL) необходимо "
"хранить в каждом экземпляре кластера, можно использовать свой собственный"
" API, добавив в таблицу специальный раздел. Кластер поможет вам безопасно"
" передать его всем экземплярам."

msgid ""
"Such section goes in parallel (in the same file) with the topology-"
"specific and ``vshard``-specific ones the cluster automatically "
"generates. Unlike the generated, the custom section's modification, "
"validation, and application logic has to be defined."
msgstr ""
"Такой раздел создается параллельно (в одном файле) с разделами о "
"топологии и о ``vshard``, которые кластер генерирует автоматически. В "
"отличие от сгенерированных разделов, логику изменения, проверки и "
"применения конфигурации в специальном разделе необходимо определять "
"вручную."

msgid "The common way is to define two functions:"
msgstr "Самый распространенный способ заключается в том, чтобы:"

msgid ""
"``validate_config(conf_new, conf_old)`` to validate changes made in the "
"new configuration (``conf_new``) versus the old configuration "
"(``conf_old``)."
msgstr ""
"``validate_config(conf_new, conf_old)`` для валидации изменений, "
"сделанных в новой конфигурации (``conf_new``) по отношению к старой "
"конфигурации (``conf_old``)."

msgid ""
"``apply_config(conf, opts)`` to execute any code related to a "
"configuration change. As input, this function takes the configuration to "
"apply (``conf``, which is actually the new configuration that you "
"validated earlier with ``validate_config()``) and options (the ``opts`` "
"argument that includes ``is_master``, a Boolean flag described later)."
msgstr ""
"``apply_config(conf, opts)`` для выполнения любого кода, связанного с "
"изменениями конфигурации. Входными данными для этой функции будут "
"применяемая конфигурация (``conf``, которая и есть новая конфигурация, "
"проверенная чуть ранее с помощью ``validate_config()``), а также "
"параметры (аргумент ``opts`` включает в себя описываемый ниже логический "
"флаг ``is_master`` )."

msgid ""
"The ``validate_config()`` function must detect all configuration problems"
" that may lead to ``apply_config()`` errors. For more information, see "
"the :ref:`next section <cartridge-role-config-apply>`."
msgstr ""
"Функция ``validate_config()`` должна обнаружить все проблемы "
"конфигурации, которые могут привести к ошибкам ``apply_config()``. Для "
"получения дополнительной информации см. :ref:`следующий раздел "
"<cartridge-role-config-apply>`."

msgid ""
"When implementing validation and application functions that call ``box`` "
"ones for some reason, the following precautions apply:"
msgstr ""
"При реализации функций валидации и применения конфигурации, которые по "
"какой-либо причине вызывают функции ``box``, следует принять следующие "
"меры предосторожности:"

msgid ""
"Due to the :ref:`role's life cycle <cartridge-role-lifecycle>`, the "
"cluster does not guarantee an automatic ``box.cfg()`` call prior to "
"calling ``validate_config()``."
msgstr ""
":ref:`Жизненный цикл роли <cartridge-role-lifecycle>` не предполагает, "
"что кластер автоматически вызовет ``box.cfg()`` до вызова "
"``validate_config()``."

msgid ""
"If the validation function is to call any ``box`` functions (e.g., to "
"check a format), make sure the calls are wrapped in a protective "
"conditional statement that checks if ``box.cfg()`` has already happened:"
msgstr ""
"Если функция валидации должна вызвать какие-либо функции из ``box`` "
"(например, для проверки формата), убедитесь, что вызовы заключены в "
"защитный условный оператор, который проверяет, произошел ли уже вызов "
"``box.cfg()``:"

#, fuzzy
msgid ""
"-- Inside the validation function:\n"
"\n"
"if type(box.cfg) == 'table' then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""
"-- В рамках функции валидации:\n"
"\n"
"if type(box.cfg) == 'function' then\n"
"\n"
"    -- Здесь можно вызвать функции из box\n"
"\n"
"end"

msgid ""
"Unlike the validation and similar to initialization function, "
"``apply_config()`` can call ``box`` functions freely as the cluster "
"applies custom configuration after the automatic ``box.cfg()`` call."
msgstr ""
"В отличие от функции валидации, как и в случае с функцией инициализации, "
"``apply_config()`` может свободно вызывать функции из ``box``, поскольку "
"кластер применяет пользовательскую конфигурацию после автоматического "
"вызова ``box.cfg()``."

msgid ""
"However, creating spaces, users, etc., can cause replication collisions "
"when performed on both master and replica instances simultaneously. The "
"appropriate way is to call such ``box`` functions on masters only and let"
" the changes propagate to replicas automatically."
msgstr ""
"Однако создание спейсов, пользователей и т.п. может привести к конфликтам"
" репликации при одновременном выполнении на мастере и на реплике. "
"Оптимальный способ заключается в том, чтобы вызывать такие функции из "
"``box`` только на мастерах и автоматически передавать изменения на "
"реплики."

msgid ""
"Upon the ``apply_config(conf, opts)`` execution, the cluster passes an "
"``is_master`` flag in the ``opts`` table which you can use to wrap "
"collision-inducing ``box`` functions in a protective conditional "
"statement:"
msgstr ""
"По выполнении ``apply_config(conf, opts)`` кластер передает флаг "
"``is_master`` в таблице ``opts``, который можно использовать для "
"заключения функций из ``box`` в защитный условный оператор, если они "
"могут вызвать конфликт:"

msgid ""
"-- Inside the configuration application function:\n"
"\n"
"if opts.is_master then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""
"-- В рамках функции применения конфигурации:\n"
"\n"
"if opts.is_master then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"

msgid "Custom configuration example"
msgstr "Пример пользовательской конфигурации"

msgid ""
"Consider the following code as part of the role's module (``custom-"
"role.lua``) implementation:"
msgstr ""
"Рассмотрим следующий код как часть реализации модуля роли (``custom-"
"role.lua``):"

msgid ""
"#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"\n"
"local cartridge = require('cartridge')\n"
"\n"
"local role_name = 'custom-role'\n"
"\n"
"-- Modify the config by implementing some setter (an alternative to HTTP "
"PUT)\n"
"local function set_secret(secret)\n"
"    local custom_role_cfg = cartridge.confapplier.get_deepcopy(role_name)"
" or {}\n"
"    custom_role_cfg.secret = secret\n"
"    cartridge.confapplier.patch_clusterwide({\n"
"        [role_name] = custom_role_cfg,\n"
"    })\n"
"end\n"
"-- Validate\n"
"local function validate_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    if custom_role_cfg.secret ~= nil then\n"
"        assert(type(custom_role_cfg.secret) == 'string', 'custom-"
"role.secret must be a string')\n"
"    end\n"
"    return true\n"
"end\n"
"-- Apply\n"
"local function apply_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    local secret = custom_role_cfg.secret or 'default-secret'\n"
"    -- Make use of it\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    set_secret = set_secret,\n"
"    validate_config = validate_config,\n"
"    apply_config = apply_config,\n"
"}"
msgstr ""
"#!/usr/bin/env tarantool\n"
"-- Реализация пользовательской роли\n"
"\n"
"local cartridge = require('cartridge')\n"
"\n"
"local role_name = 'custom-role'\n"
"\n"
"-- Изменение конфигурации с вводом сеттера (альтернатива HTTP PUT)\n"
"local function set_secret(secret)\n"
"    local custom_role_cfg = cartridge.confapplier.get_deepcopy(role_name)"
" or {}\n"
"    custom_role_cfg.secret = secret\n"
"    cartridge.confapplier.patch_clusterwide({\n"
"        [role_name] = custom_role_cfg,\n"
"    })\n"
"end\n"
"-- Валидация\n"
"local function validate_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    if custom_role_cfg.secret ~= nil then\n"
"        assert(type(custom_role_cfg.secret) == 'string', 'custom-"
"role.secret must be a string')\n"
"    end\n"
"    return true\n"
"end\n"
"-- Применение\n"
"local function apply_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    local secret = custom_role_cfg.secret or 'default-secret'\n"
"    -- Make use of it\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    set_secret = set_secret,\n"
"    validate_config = validate_config,\n"
"    apply_config = apply_config,\n"
"}"

msgid "Once the configuration is customized, do one of the following:"
msgstr "После настройки конфигурации выполните одно из следующих действий:"

msgid ""
"continue developing your application and pay attention to its "
":ref:`versioning <cartridge-versioning>`;"
msgstr ""
"продолжите разработку приложения, обращая особое внимание на "
":ref:`управление версиями <cartridge-versioning>`;"

msgid ""
"(optional) :ref:`enable authorization <cartridge-auth-enable>` in the web"
" interface."
msgstr ""
"(необязательно) :ref:`включите авторизацию <cartridge-auth-enable>` в "
"веб-интерфейсе."

msgid ""
"in case the cluster is already deployed, :ref:`apply the configuration "
"<cartridge-role-config-apply>` cluster-wide."
msgstr ""
"если кластер уже развернут, :ref:`примените конфигурацию <cartridge-role-"
"config-apply>` для всего кластера."

msgid "Applying custom role's configuration"
msgstr "Применение конфигурации пользовательской роли"

msgid ""
"With the implementation showed by the :ref:`example <cartridge-role-"
"config-example>`, you can call the ``set_secret()`` function to apply the"
" new configuration via the administrative console or an HTTP endpoint if "
"the role exports one."
msgstr ""
"В :ref:`примере <cartridge-role-config-example>` реализации можно вызвать"
" функцию ``set_secret()``, чтобы применить новую конфигурацию с помощью "
"административной консоли или конечной точки HTTP, если роль экспортирует "
"таковую."

msgid ""
"The ``set_secret()`` function calls "
"``cartridge.confapplier.patch_clusterwide()`` which performs a two-phase "
"commit:"
msgstr ""
"Функция ``set_secret()`` вызывает "
"``cartridge.confapplier.patch_clusterwide()``, которая производит "
"двухфазную фиксацию транзакций:"

msgid ""
"It patches the active configuration in memory: copies the table and "
"replaces the ``\"custom-role\"`` section in the copy with the one given "
"by the ``set_secret()`` function."
msgstr ""
"Исправляет активную конфигурацию в памяти: копирует таблицу и заменяет "
"раздел ``\"custom-role\"`` в копии на раздел, который задан функцией "
"``set_secret()``."

msgid ""
"The cluster checks if the new configuration can be applied on all "
"instances except disabled and expelled. All instances subject to update "
"must be healthy and ``alive`` according to the `membership module "
"<https://www.tarantool.io/en/doc/1.10/reference/reference_rock/membership/>`_."
msgstr ""
"Кластер проверяет, можно ли применить новую конфигурацию ко всем "
"экземплярам, кроме отключенных и исключенных. Все обновляемые экземпляры "
"должны быть исправными и рабочими в соответствии с требованиями `модуля "
"membership "
"<https://www.tarantool.io/en/doc/1.10/reference/reference_rock/membership/>`_."

msgid ""
"(**Preparation phase**) The cluster propagates the patched configuration."
" Every instance validates it with the ``validate_config()`` function of "
"every registered role. Depending on the validation's result:"
msgstr ""
"(**Фаза подготовки**) Кластер передает исправленную конфигурацию. Каждый "
"экземпляр валидирует ее с помощью функции ``validate_config()`` каждой "
"зарегистрированной роли. В зависимости от результата валидации:"

msgid ""
"If successful (i.e., returns ``true``), the instance saves the new "
"configuration to a temporary file named ``config.prepare.yml`` within the"
" working directory."
msgstr ""
"В случае успеха (то есть возврата значения ``true``) экземпляр сохраняет "
"новую конфигурацию во временный файл с именем ``config.prepare.yml`` в "
"рабочей директории."

msgid ""
"(**Abort phase**) Otherwise, the instance reports an error and all other "
"instances roll back the update: remove the file they may have already "
"prepared."
msgstr ""
"(**Фаза отмены**) В противном случае экземпляр сообщает об ошибке, а все "
"остальные экземпляры откатывают обновление: удаляют файл, который они, "
"возможно, уже подготовили."

msgid ""
"(**Commit phase**) Upon successful preparation of all instances, the "
"cluster commits the changes. Every instance:"
msgstr ""
"(**Фаза фиксации**) После успешной подготовки всех экземпляров кластер "
"фиксирует изменения. Каждый экземпляр:"

msgid "Creates the active configuration's hard-link."
msgstr "Создает жесткую ссылку активной конфигурации."

msgid ""
"Atomically replaces the active one with the prepared. The atomic "
"replacement is indivisible -- it can either succeed or fail entirely, "
"never partially."
msgstr ""
"Атомарно заменяет активную на подготовленную. Атомарная замена неделима, "
"то есть она может быть либо выполнена, либо не выполнена полностью, но не"
" частично."

msgid "Calls the ``apply_config()`` function of every registered role."
msgstr "Вызывает функцию ``apply_config()`` каждой зарегистрированной роли."

msgid ""
"If any of these steps fail, an error pops up in the web interface next to"
" the corresponding instance. The cluster does not handle such errors "
"automatically, they require manual repair."
msgstr ""
"Если любой из этих шагов не будет выполнен, в веб-интерфейсе появится "
"ошибка рядом с соответствующим экземпляром. Кластер не обрабатывает такие"
" ошибки автоматически, их необходимо исправлять вручную."

msgid ""
"You will avoid the repair if the ``validate_config()`` function can "
"detect all configuration problems that may lead to ``apply_config()`` "
"errors."
msgstr ""
"Такого рода исправлений можно избежать, если функция "
"``validate_config()`` сможет обнаружить все проблемы конфигурации, "
"которые могут привести к ошибкам в ``apply_config()``."

msgid "Using the built-in HTTP server"
msgstr "Использование встроенного HTTP-сервера"

msgid ""
"The cluster launches an ``httpd`` server instance during initialization "
"(``cartridge.cfg()``). You can bind a port to the instance via an "
"environmental variable:"
msgstr ""
"Кластер запускает экземпляр ``httpd``-сервера во время инициализации "
"(``cartridge.cfg()``). Можно привязать порт к экземпляру через переменную"
" окружения:"

msgid ""
"-- Get the port from an environmental variable or the default one:\n"
"local http_port = os.getenv('HTTP_PORT') or '8080'\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"   ...\n"
"   -- Pass the port to the cluster:\n"
"   http_port = http_port,\n"
"   ...\n"
"})"
msgstr ""
"-- Получение порта из переменной окружения или используемого по "
"умолчанию:\n"
"local http_port = os.getenv('HTTP_PORT') or '8080'\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"   ...\n"
"   -- Передача порта в кластер:\n"
"   http_port = http_port,\n"
"   ...\n"
"})"

msgid ""
"To make use of the ``httpd`` instance, access it and configure routes "
"inside the ``init()`` function of some role, e.g. a role that exposes API"
" over HTTP:"
msgstr ""
"Чтобы использовать ``httpd``-экземпляр, получите к нему доступ и "
"настройте маршруты в рамках функции ``init()`` для какой-либо роли "
"(например, для  роли, которая предоставляет API через HTTP):"

msgid ""
"local function init(opts)\n"
"\n"
"...\n"
"\n"
"   -- Get the httpd instance:\n"
"   local httpd = cartridge.service_get('httpd')\n"
"   if httpd ~= nil then\n"
"       -- Configure a route to, for example, metrics:\n"
"       httpd:route({\n"
"               method = 'GET',\n"
"               path = '/metrics',\n"
"               public = true,\n"
"           },\n"
"           function(req)\n"
"               return req:render({json = stat.stat()})\n"
"           end\n"
"       )\n"
"   end\n"
"end"
msgstr ""
"local function init(opts)\n"
"\n"
"...\n"
"\n"
"   -- Получение httpd-экземпляра:\n"
"   local httpd = cartridge.service_get('httpd')\n"
"   if httpd ~= nil then\n"
"       -- Настройка маршрута, к примеру, к метрике:\n"
"       httpd:route({\n"
"               method = 'GET',\n"
"               path = '/metrics',\n"
"               public = true,\n"
"           },\n"
"           function(req)\n"
"               return req:render({json = stat.stat()})\n"
"           end\n"
"       )\n"
"   end\n"
"end"

msgid ""
"For more information on the usage of Tarantool's HTTP server, see `its "
"documentation <https://github.com/tarantool/http>`_."
msgstr ""
"Для получения дополнительной информации об использовании HTTP-сервера "
"Tarantool обратитесь к `соответствующей документации "
"<https://github.com/tarantool/http>`_."

msgid "Implementing authorization in the web interface"
msgstr "Реализация авторизации в веб-интерфейсе"

msgid ""
"To implement authorization in the web interface of every instance in "
"Tarantool cluster:"
msgstr ""
"Чтобы реализовать авторизацию в веб-интерфейсе каждого экземпляра в "
"кластере Tarantool'а:"

msgid ""
"Implement a new, say, ``auth`` module with a ``check_password`` function."
" It should check the credentials of any user trying to log in to the web "
"interface."
msgstr ""
"Используйте модуль, к примеру, ``auth`` с функцией ``check_password``. "
"Данная функция проверяет учетные данные любого пользователя, который "
"пытается войти в веб-интерфейс."

msgid ""
"The ``check_password`` function accepts a username and password and "
"returns an authentication success or failure."
msgstr ""
"Функция ``check_password`` принимает имя пользователя и пароль и "
"возвращает результат аутентификации: пройдена или нет."

msgid ""
"-- auth.lua\n"
"\n"
"-- Add a function to check the credentials\n"
"local function check_password(username, password)\n"
"\n"
"    -- Check the credentials any way you like\n"
"\n"
"    -- Return an authentication success or failure\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    return true\n"
"end\n"
"..."
msgstr ""
"-- auth.lua\n"
"\n"
"-- Добавление функции для проверки учетных данных\n"
"local function check_password(username, password)\n"
"\n"
"    -- Проверка учетных данных любым способом\n"
"\n"
"    -- Возврат пройденной или непройденной аутентификации\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    return true\n"
"end\n"
"..."

msgid ""
"Pass the implemented ``auth`` module name as a parameter to "
"``cartridge.cfg()``, so the cluster can use it:"
msgstr ""
"Передайте имя используемого модуля ``auth`` в качестве параметра для "
"``cartridge.cfg()``, чтобы кластер мог использовать его:"

msgid ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    -- The cluster will automatically call 'require()' on the 'auth' "
"module.\n"
"    ...\n"
"})"
msgstr ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    -- Кластер автоматически вызовет 'require()' для модуля 'auth'.\n"
"    ...\n"
"})"

msgid ""
"This adds a **Log in** button to the upper right corner of the web "
"interface but still lets the unsigned users interact with the interface. "
"This is convenient for testing."
msgstr ""
"Это добавит кнопку **Log in** (Войти) в верхний правый угол в "
"веб-интерфейсе, но все же позволит неавторизованным пользователям "
"взаимодействовать с интерфейсом, что удобно для тестирования."

msgid ""
"Also, to authorize requests to cluster API, you can use the HTTP basic "
"authorization header."
msgstr ""
"Кроме того, для авторизации запросов к API кластера можно использовать "
"базовый заголовок HTTP для авторизации."

msgid ""
"To require the authorization of every user in the web interface even "
"before the cluster bootstrap, add the following line:"
msgstr ""
"Чтобы требовать авторизацию каждого пользователя в веб-интерфейсе даже до"
" начальной загрузки кластера, добавьте следующую строку:"

msgid ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    auth_enabled = true,\n"
"    ...\n"
"})"
msgstr ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    auth_enabled = true,\n"
"    ...\n"
"})"

msgid ""
"With the authentication enabled and the ``auth`` module implemented, the "
"user will not be able to even bootstrap the cluster without logging in. "
"After the successful login and bootstrap, the authentication can be "
"enabled and disabled cluster-wide in the web interface and the "
"``auth_enabled`` parameter is ignored."
msgstr ""
"С включенной аутентификацией при использовании модуля ``auth`` "
"пользователь не сможет даже загрузить кластер без входа в систему. После "
"успешного входа в систему и начальной загрузки можно включить и отключить"
" аутентификацию для всего кластера в веб-интерфейсе, а параметр "
"``auth_enabled`` игнорируется."

msgid "Application versioning"
msgstr "Управление версиями приложения"

msgid ""
"Tarantool Cartridge understands semantic versioning as described at "
"`semver.org <https://semver.org>`_. When developing an application, "
"create new Git branches and tag them appropriately. These tags are used "
"to calculate version increments for subsequent packaging."
msgstr ""
"В Tarantool Cartridge семантическое управление версиями осуществляется "
"так, как описано на сайте `semver.org <https://semver.org>`_. При "
"разработке приложения создайте новые ветки Git и пометьте их "
"соответствующими тегами. Эти теги используются для расчета увеличения "
"значения версий для последующей упаковки."

msgid ""
"For example, if your application has version 1.2.1, tag your current "
"branch with ``1.2.1`` (annotated or not)."
msgstr ""
"Например, если версия вашего приложения -- 1.2.1, пометьте текущую ветку "
"тегом ``1.2.1`` (с аннотациями или без них)."

msgid "To retrieve the current version from Git, say:"
msgstr "Чтобы получить значение текущей версии из Git, выполните команду:"

msgid ""
"$ git describe --long --tags\n"
"1.2.1-12-g74864f2"
msgstr ""
"$ git describe --long --tags\n"
"1.2.1-12-g74864f2"

msgid ""
"This output shows that we are 12 commits after the version 1.2.1. If we "
"are to package the application at this point, it will have a full version"
" of ``1.2.1-12`` and its package will be named "
"``<app_name>-1.2.1-12.rpm``."
msgstr ""
"Вывод показывает, что после версии 1.2.1 было 12 коммитов. Если мы "
"соберемся упаковать приложение на данном этапе, его полная версия будет "
"``1.2.1-12``, а пакет будет называться ``<имя_приложения>-1.2.1-12.rpm``."

msgid ""
"Non-semantic tags are prohibited. You will not be able to create a "
"package from a branch with the latest tag being non-semantic."
msgstr ""
"Запрещается использовать не семантические теги. Вы не сможете создать "
"пакет из ветки, если последний тег не будет семантическим."

msgid ""
"Once you :ref:`package <cartridge-deploy>` your application, the version "
"is saved in a ``VERSION`` file in the package root."
msgstr ""
"После :ref:`упаковки <cartridge-deploy>` приложения его версия "
"сохраняется в файл ``VERSION`` в корневой каталог пакета."

#, fuzzy
msgid "Using .cartridge.ignore files"
msgstr "Использование файлов .cartridge-cli.ignore"

#, fuzzy
msgid ""
"You can add a ``.cartridge.ignore`` file to your application repository "
"to exclude particular files and/or directories from package builds."
msgstr ""
"В репозиторий приложения можно добавить файл ``.cartridge-cli.ignore``, "
"чтобы не включать определенные файлы и/или директории в сборки пакета."

#, fuzzy
msgid ""
"For the most part, the logic is similar to that of ``.gitignore`` files. "
"The major difference is that in ``.cartridge.ignore`` files the order of "
"exceptions relative to the rest of the templates does not matter, while "
"in ``.gitignore`` files the order does matter."
msgstr ""
"По большей части логика похожа на логику файлов ``.gitignore``. Основное "
"отличие состоит в том, что в файлах ``.cartridge-cli.ignore`` порядок "
"исключения относительно остальных шаблонов не имеет значения, а в файлах "
"``.gitignore`` -- имеет."

#, fuzzy
msgid "**.cartridge.ignore** entry"
msgstr "запись в ``.cartridge-cli.ignore``"

msgid "ignores every..."
msgstr "игнорирует все..."

msgid "``target/``"
msgstr "``target/``"

msgid "**folder** (due to the trailing ``/``) named ``target``, recursively"
msgstr ""
"**папки** (поскольку в конце стоит ``/``) под названием ``target`` "
"рекурсивно"

msgid "``target``"
msgstr "``target``"

msgid "**file or folder** named ``target``, recursively"
msgstr "**файлы или папки** под названием ``target`` рекурсивно"

msgid "``/target``"
msgstr "``/target``"

msgid ""
"**file or folder** named ``target`` in the top-most directory (due to the"
" leading ``/``)"
msgstr ""
"**файлы или папки** под названием ``target`` в самой верхней директории "
"(поскольку в начале стоит ``/``)"

msgid "``/target/``"
msgstr "``/target/``"

msgid ""
"**folder** named ``target`` in the top-most directory (leading and "
"trailing ``/``)"
msgstr ""
"**папки** под названием ``target`` в самой верхней директории (в начале и"
" в конце стоит ``/``)"

msgid "``*.class``"
msgstr "``*.class``"

msgid "every **file or folder** ending with ``.class``, recursively"
msgstr "**файлы или папки**, оканчивающиеся на ``.class``, рекурсивно"

msgid "``#comment``"
msgstr "``#comment``"

msgid "nothing, this is a comment (the first character is a ``#``)"
msgstr "ничего, это комментарий (первый символ -- ``#``)"

msgid "``\\#comment``"
msgstr "``\\#comment``"

msgid "every **file or folder** with name ``#comment`` (``\\`` for escaping)"
msgstr "**файлы или папки** под названием ``#comment`` (``\\\\`` для выделения)"

msgid "``target/logs/``"
msgstr "``target/logs/``"

msgid ""
"every **folder** named ``logs`` which is a subdirectory of a folder named"
" ``target``"
msgstr ""
"**папки** под названием ``logs``, которые представляют собой "
"поддиректорию папки под названием ``target``"

msgid "``target/*/logs/``"
msgstr "``target/*/logs/``"

msgid ""
"every **folder** named ``logs`` two levels under a folder named "
"``target`` (``*`` doesn’t include ``/``)"
msgstr ""
"**папки** под названием ``logs`` на два уровня ниже папки под названием "
"``target`` (``*`` не включает ``/``)"

msgid "``target/**/logs/``"
msgstr "``target/**/logs/``"

msgid ""
"every **folder** named ``logs`` somewhere under a folder named ``target``"
" (``**`` includes ``/``)"
msgstr ""
"**папки** под названием ``logs`` где угодно в пределах папки ``target`` "
"(``**`` включает ``/``)"

msgid "``*.py[co]``"
msgstr "``*.py[co]``"

msgid ""
"every **file or folder** ending in ``.pyc`` or ``.pyo``; however, it "
"doesn’t match ``.py!``"
msgstr ""
"**файлы или папки**, оканчивающиеся на ``.pyc`` или ``.pyo``, но не на "
"``.py!``"

msgid "``*.py[!co]``"
msgstr "``*.py[!co]``"

msgid "every **file or folder** ending in anything other than ``c`` or ``o``"
msgstr "**файлы или папки**, оканчивающиеся на что угодно, кроме ``c`` или ``o``"

msgid "``*.file[0-9]``"
msgstr "``*.file[0-9]``"

msgid "every **file or folder** ending in digit"
msgstr "**файлы или папки**, оканчивающиеся на цифру"

msgid "``*.file[!0-9]``"
msgstr "``*.file[!0-9]``"

msgid "every **file or folder** ending in anything other than digit"
msgstr "**файлы или папки**, оканчивающиеся на что угодно, кроме цифры"

msgid "``*``"
msgstr "``*``"

msgid "**every**"
msgstr "**всё**"

msgid "``/*``"
msgstr "``/*``"

msgid "**everything** in the top-most directory (due to the leading ``/``)"
msgstr "**всё** в самой верхней директории (поскольку в начале стоит ``/``)"

msgid "``**/*.tar.gz``"
msgstr "``**/*.tar.gz``"

msgid ""
"every ``*.tar.gz`` file or folder which is **one or more** levels under "
"the starting folder"
msgstr ""
"файлы ``*.tar.gz`` или папки, которые находятся на **один или несколько**"
" уровней ниже исходной папки"

msgid "``!file``"
msgstr "``!file``"

msgid "every **file or folder** will be ignored even if it matches other patterns"
msgstr ""
"**файлы и папки** будут проигнорированы, даже если они подходят под "
"другие типы"

msgid "Deploying an application"
msgstr "Развертывание приложения"

msgid "You have four options to deploy a Tarantool Cartridge application:"
msgstr "Развернуть приложение Tarantool Cartridge можно четырьмя способами:"

msgid "as an :ref:`rpm <cartridge-deploy-rpm>` package (for production);"
msgstr ""
"в виде :ref:`rpm <cartridge-deploy-rpm>`-пакета (для эксплуатационной "
"среды);"

msgid "as a :ref:`deb <cartridge-deploy-deb>` package (for production);"
msgstr ""
"в виде :ref:`deb <cartridge-deploy-deb>`-пакета (для эксплуатационной "
"среды);"

msgid ""
"as a :ref:`tar+gz <cartridge-deploy-tgz>` archive (for testing, or as a "
"workaround for production if root access is unavailable)."
msgstr ""
"в виде архива :ref:`tar+gz <cartridge-deploy-tgz>` (для тестирования или "
"для эксплуатационной среды, если отсутствует доступ уровня root)."

msgid ":ref:`from sources <cartridge-deploy-rock>` (for local testing only)."
msgstr ""
":ref:`из исходных файлов <cartridge-deploy-rock>` (только для локального "
"тестирования)."

msgid "Deploying as an rpm or deb package"
msgstr "Развертывание приложения в виде пакета rpm или deb"

msgid "Pack the application into a distributable:"
msgstr "Упакуйте файлы приложения в распространяемый пакет:"

msgid ""
"$ cartridge pack rpm APP_NAME\n"
"# -- OR --\n"
"$ cartridge pack deb APP_NAME"
msgstr ""
"$ cartridge pack rpm ИМЯ_ПРИЛОЖЕНИЯ\n"
"# -- ИЛИ --\n"
"$ cartridge pack deb ИМЯ_ПРИЛОЖЕНИЯ"

msgid ""
"This will create an RPM package (e.g. ``./my_app-0.1.0-1.rpm``) or a DEB "
"package (e.g. ``./my_app-0.1.0-1.deb``)."
msgstr ""
"Будет создан RPM-пакет (например, ``./my_app-0.1.0-1.rpm``) или же "
"DEB-пакет (например, ``./my_app-0.1.0-1.deb``)."

msgid "Upload the package to target servers, with ``systemctl`` supported."
msgstr "Загрузите пакет на необходимые серверы с поддержкой ``systemctl``."

msgid "Install:"
msgstr "Установите:"

msgid ""
"$ yum install APP_NAME-VERSION.rpm\n"
"# -- OR --\n"
"$ dpkg -i APP_NAME-VERSION.deb"
msgstr ""
"$ yum install ИМЯ_ПРИЛОЖЕНИЯ-ВЕРСИЯ.rpm\n"
"# -- ИЛИ --\n"
"$ dpkg -i ИМЯ_ПРИЛОЖЕНИЯ-ВЕРСИЯ.deb"

msgid ":ref:`Configure the instance(s) <cartridge-config>`."
msgstr ":ref:`Выполните конфигурацию экземпляров <cartridge-config>`."

msgid ""
"Start Tarantool instances with the corresponding services. You can do it "
"using :ref:`systemctl <cartridge-run-systemctl>`, for example:"
msgstr ""
"Запустите экземпляры Tarantool'а с соответствующими службами. Например, "
"это можно сделать, используя :ref:`systemctl <cartridge-run-systemctl>`:"

msgid ""
"# starts a single instance\n"
"$ systemctl start my_app\n"
"\n"
"# starts multiple instances\n"
"$ systemctl start my_app@router\n"
"$ systemctl start my_app@storage_A\n"
"$ systemctl start my_app@storage_B"
msgstr ""
"# запуск одного экземпляра\n"
"$ systemctl start my_app\n"
"\n"
"# запуск нескольких экземпляров\n"
"$ systemctl start my_app@router\n"
"$ systemctl start my_app@storage_A\n"
"$ systemctl start my_app@storage_B"

msgid ""
"In case it is a cluster-aware application, proceed to :ref:`deploying the"
" cluster <cartridge-deployment>`."
msgstr ""
"Если это приложение с поддержкой кластеров, далее переходите к "
":ref:`развертыванию кластера <cartridge-deployment>`."

msgid "Deploying as a tar+gz archive"
msgstr "Развертывание архива tar+gz"

msgid "$ cartridge pack tgz APP_NAME"
msgstr "$ cartridge pack tgz ИМЯ_ПРИЛОЖЕНИЯ"

msgid "This will create a tar+gz archive (e.g. ``./my_app-0.1.0-1.tgz``)."
msgstr "Будет создан архив tar+gz (например, ``./my_app-0.1.0-1.tgz``)."

msgid ""
"Upload the archive to target servers, with ``tarantool`` and (optionally)"
" :ref:`cartridge-cli <cartridge-install>` installed."
msgstr ""
"Загрузите архив на необходимый сервер с установленным ``tarantool`` и "
"(необязательно) :ref:`cartridge-cli <cartridge-install>`."

msgid "Extract the archive:"
msgstr "Распакуйте архив:"

msgid "$ tar -xzvf APP_NAME-VERSION.tgz"
msgstr "$ tar -xzvf ИМЯ_ПРИЛОЖЕНИЯ-ВЕРСИЯ.tgz"

msgid "Start Tarantool instance(s). You can do it using:"
msgstr "Запустите экземпляры Tarantool’а. Это можно сделать, используя:"

msgid ":ref:`tarantool <cartridge-run-tarantool>`, for example:"
msgstr ":ref:`tarantoolctl <cartridge-run-tarantool>`, например:"

msgid "$ tarantool init.lua # starts a single instance"
msgstr "$ tarantool init.lua # запускает одиночный экземпляр"

msgid "or :ref:`cartridge <cartridge-run-cartridge>`, for example:"
msgstr "или :ref:`cartridge <cartridge-run-cartridge>`, например:"

msgid ""
"# in application directory\n"
"$ cartridge start # starts all instances\n"
"$ cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"$ cartridge start my_app # starts all instances of my_app\n"
"$ cartridge start my_app.router # starts a single instance"
msgstr ""
"# в директории приложения\n"
"$ cartridge start # запускает все экземпляры\n"
"$ cartridge start .router_1 # запускает один экземпляр\n"
"\n"
"# в среде с несколькими приложениями\n"
"$ cartridge start my_app # запускает все экземпляры my_app\n"
"$ cartridge start my_app.router # запускает один экземпляр"

msgid "Deploying from sources"
msgstr "Развертывание из исходных файлов"

msgid "This deployment method is intended for local testing only."
msgstr "Такой метод развертывания предназначен только для локального тестирования."

msgid "Pull all dependencies to the ``.rocks`` directory:"
msgstr "Вытяните все зависимости в директорию ``.rocks``:"

msgid "$ tarantoolctl rocks make"
msgstr "$ tarantoolctl rocks make"

msgid ""
"# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # starts a single instance"
msgstr ""
"# в директории приложения\n"
"cartridge start # запускает все экземпляры\n"
"cartridge start .router_1 # запускает один экземпляр\n"
"\n"
"# в среде с несколькими приложениями\n"
"cartridge start my_app # запускает все экземпляры my_app\n"
"cartridge start my_app.router # запускает один экземпляр"

msgid "Configuring instances"
msgstr "Конфигурация экземпляров"

msgid "Instance configuration includes two sets of parameters:"
msgstr "Конфигурация экземпляра состоит из двух наборов параметров:"

msgid ""
"`cartridge.cfg() parameters "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#cluster-opts>`_;"
msgstr ""
"параметры `cartridge.cfg() "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#cluster-opts>`_;"

msgid ""
"`box.cfg() parameters "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#box-opts>`_."
msgstr ""
"параметры `box.cfg() "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse"
"/#box-opts>`_."

msgid "You can set any of these parameters in:"
msgstr "Задать эти параметры можно:"

msgid "Command line arguments."
msgstr "В аргументах в командной строке."

msgid "Environment variables."
msgstr "В переменных окружения."

msgid "YAML configuration file."
msgstr "В конфигурационном файле формата YAML."

msgid "``init.lua`` file."
msgstr "В файле ``init.lua``."

msgid ""
"The order here indicates the priority: command-line arguments override "
"environment variables, and so forth."
msgstr ""
"Вышеуказанный порядок определяет приоритет: аргументы в командной строке "
"замещают переменные окружения и т.д."

msgid ""
"No matter how you :ref:`start the instances <cartridge-run>`, you need to"
" set the following ``cartridge.cfg()`` parameters for each instance:"
msgstr ""
"Независимо от того, как вы :ref:`запускаете экземпляры <cartridge-run>`, "
"необходимо задать следующие параметры ``cartridge.cfg()`` для каждого "
"экземпляра:"

msgid ""
"``advertise_uri`` -- either ``<HOST>:<PORT>``, or ``<HOST>:``, or "
"``<PORT>``. Used by other instances to connect to the current one. **DO "
"NOT** specify ``0.0.0.0`` -- this must be an external IP address, not a "
"socket bind."
msgstr ""
"``advertise_uri`` -- либо ``<ХОСТ>:<ПОРТ>``, либо ``<ХОСТ>:``, либо "
"``<ПОРТ>``. Используется другими экземплярами для подключения. **НЕ** "
"указывайте ``0.0.0.0`` -- это должен быть внешний IP-адрес, а не привязка"
" сокета."

msgid ""
"``http_port`` -- port to open administrative web interface and API on. "
"Defaults to ``8081``. To disable it, specify ``\"http_enabled\": False``."
msgstr ""
"``http_port`` -- порт, который используется, чтобы открывать "
"административный веб-интерфейс и API. По умолчанию: ``8081``. Чтобы "
"отключить, укажите ``\"http_enabled\": False``."

msgid ""
"``workdir`` -- a directory where all data will be stored: snapshots, wal "
"logs, and ``cartridge`` configuration file. Defaults to ``.``."
msgstr ""
"``workdir`` -- директория, где хранятся все данные: файлы снимка, журналы"
" упреждающей записи и конфигурационный файл ``cartridge``. По умолчанию: "
"``.``."

msgid ""
"If you start instances using ``cartridge`` CLI or ``systemctl``, save the"
" configuration as a YAML file, for example:"
msgstr ""
"Если вы запустите экземпляры, используя интерфейс командной строки "
"``cartridge`` или ``systemctl``, сохраните конфигурацию в формате YAML, "
"например:"

msgid ""
"my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": "
"8080}\n"
"my_app.storage_A: {\"advertise_uri\": \"localhost:3302\", "
"\"http_enabled\": False}\n"
"my_app.storage_B: {\"advertise_uri\": \"localhost:3303\", "
"\"http_enabled\": False}"
msgstr ""
"my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": "
"8080}\n"
"my_app.storage_A: {\"advertise_uri\": \"localhost:3302\", "
"\"http_enabled\": False}\n"
"my_app.storage_B: {\"advertise_uri\": \"localhost:3303\", "
"\"http_enabled\": False}"

msgid ""
"With ``cartridge`` CLI, you can pass the path to this file as the "
"``--cfg`` command-line argument to the ``cartridge start`` command -- or "
"specify the path in ``cartridge`` CLI configuration (in "
"``./.cartridge.yml`` or ``~/.cartridge.yml``):"
msgstr ""
"С помощью интерфейса командной строки ``cartridge`` вы можете передать "
"путь к этому файлу в качестве аргумента командной строки ``--cfg`` для "
"команды ``cartridge start`` -- или же указать путь в конфигурации "
"``cartridge`` (в ``./.cartridge.yml`` или ``~/.cartridge.yml``):"

msgid ""
"cfg: cartridge.yml\n"
"run_dir: tmp/run\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""
"cfg: cartridge.yml\n"
"run_dir: tmp/run\n"
"apps_path: /usr/local/share/tarantool"

msgid ""
"With ``systemctl``, save the YAML file to ``/etc/tarantool/conf.d/`` (the"
" default ``systemd`` path) or to a location set in the ``TARANTOOL_CFG`` "
"environment variable."
msgstr ""
"С помощью ``systemctl`` сохраните файл в формате YAML в "
"``/etc/tarantool/conf.d/`` (по умолчанию путь ``systemd``) или в место, "
"указанное в переменной окружения ``TARANTOOL_CFG``."

msgid ""
"If you start instances with ``tarantool init.lua``, you need to pass "
"other configuration options as command-line parameters and environment "
"variables, for example:"
msgstr ""
"Если вы запускаете экземпляры с помощью ``tarantool init.lua``, "
"необходимо также передать другие параметры конфигурации в качестве "
"параметров командной строки и переменных окружения, например:"

msgid ""
"$ tarantool init.lua --alias router --memtx-memory 100 --workdir "
"\"~/db/3301\" --advertise_uri \"localhost:3301\" --http_port \"8080\""
msgstr ""
"$ tarantool init.lua --alias router --memtx-memory 100 --workdir "
"\"~/db/3301\" --advertise_uri \"localhost:3301\" --http_port \"8080\""

msgid "Starting/stopping instances"
msgstr "Запуск/остановка экземпляров"

msgid ""
"Depending on your :ref:`deployment method <cartridge-deploy>`, you can "
"start/stop the instances using :ref:`tarantool <cartridge-run-"
"tarantool>`, :ref:`cartridge CLI <cartridge-run-cartridge>`, or "
":ref:`systemctl <cartridge-run-systemctl>`."
msgstr ""
"В зависимости от :ref:`способа развертывания <cartridge-deploy>` вы "
"можете запускать/останавливать экземпляры, используя :ref:`tarantool "
"<cartridge-run-tarantool>`, :ref:`интерфейс командной строки cartridge "
"<cartridge-run-cartridge>` или :ref:`systemctl <cartridge-run-"
"systemctl>`."

msgid "Start/stop using ``tarantool``"
msgstr "Запуск/остановка с помощью ``tarantool``"

msgid "With ``tarantool``, you can start only a single instance:"
msgstr "С помощью ``tarantool`` можно запустить только один экземпляр:"

msgid "$ tarantool init.lua # the simplest command"
msgstr "$ tarantool init.lua # простейшая команда"

msgid ""
"You can also :ref:`specify more options <cartridge-config-tarantool>` on "
"the command line or in environment variables."
msgstr ""
"Можно также :ref:`задать дополнительные параметры <cartridge-config-"
"tarantool>` в командной строке или в переменных окружения."

msgid "To stop the instance, use Ctrl+C."
msgstr "Чтобы остановить экземпляр, используйте Ctrl+C."

msgid "Start/stop using ``cartridge`` CLI"
msgstr "Запуск/остановка с помощью CLI в ``cartridge``"

msgid "With ``cartridge`` CLI, you can start one or multiple instances:"
msgstr ""
"С помощью интерфейса командной строки ``cartridge``, можно запустить один"
" или несколько экземпляров:"

msgid "$ cartridge start [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr "$ cartridge start [ИМЯ_ПРИЛОЖЕНИЯ[.ИМЯ_ЭКЗЕМПЛЯРА]] [параметры]"

msgid "The options are:"
msgstr "Возможные параметры:"

msgid "``--script FILE``"
msgstr "``--script FILE``"

msgid "Application's entry point. Defaults to:"
msgstr "Точка входа в приложение. По умолчанию:"

msgid "``TARANTOOL_SCRIPT``, or"
msgstr "``TARANTOOL_SCRIPT``, либо"

msgid "``./init.lua`` when running from the app's directory, or"
msgstr "``./init.lua``, если запуск идет из директории приложения, или же"

msgid "``:apps_path/:app_name/init.lua`` in a multi-app environment."
msgstr ""
"``:путь_к_приложениям/:имя_приложения/init.lua`` в среде с несколькими "
"приложениями."

msgid "``--apps_path PATH``"
msgstr "``--apps_path PATH``"

msgid ""
"Path to apps directory when running in a multi-app environment. Defaults "
"to ``/usr/share/tarantool``."
msgstr ""
"Путь к директории с приложениями при запуске из среды с несколькими "
"приложениями. По умолчанию: ``/usr/share/tarantool``."

msgid "``--run_dir DIR``"
msgstr "``--run_dir DIR``"

msgid ""
"Directory with pid and sock files. Defaults to ``TARANTOOL_RUN_DIR`` or "
"``/var/run/tarantool``."
msgstr ""
"Директория с файлами pid и sock. По умолчанию: ``TARANTOOL_RUN_DIR`` или "
"``/var/run/tarantool``."

msgid "``--cfg FILE``"
msgstr "``--cfg FILE``"

msgid ""
"Cartridge instances YAML configuration file. Defaults to "
"``TARANTOOL_CFG`` or ``./instances.yml``."
msgstr ""
"Конфигурациионный файл в формате YAML для экземпляров Cartridge. По "
"умолчанию: ``TARANTOOL_CFG`` или ``./instances.yml``."

msgid "``--foreground``"
msgstr "``--foreground``"

msgid "Do not daemonize."
msgstr "Не в фоне."

msgid "cartridge start my_app --cfg demo.yml --run_dir ./tmp/run --foreground"
msgstr "cartridge start my_app --cfg demo.yml --run_dir ./tmp/run --foreground"

msgid ""
"It starts all ``tarantool`` instances specified in ``cfg`` file, in "
"foreground, with enforced :ref:`environment variables <cartridge-"
"config>`."
msgstr ""
"Это запустит все экземпляры Tarantool'а, указанные в файле ``cfg``, не в "
"фоновом режиме с принудительным использованием :ref:`переменных окружения"
" <cartridge-config>`."

msgid ""
"When ``APP_NAME`` is not provided, ``cartridge`` parses it from "
"``./*.rockspec`` filename."
msgstr ""
"Если ``ИМЯ_ПРИЛОЖЕНИЯ`` не указано, ``cartridge`` выделит его из имени "
"файла ``./*.rockspec``."

msgid ""
"When ``INSTANCE_NAME`` is not provided, ``cartridge`` reads ``cfg`` file "
"and starts all defined instances:"
msgstr ""
"Если ``ИМЯ_ЭКЗЕМПЛЯРА`` не указывается, ``cartridge`` прочитает файл "
"``cfg`` и запустит все указанные экземпляры:"

msgid ""
"# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # start single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # start a single instance"
msgstr ""
"# в директории приложения\n"
"cartridge start # запускает все экземпляры\n"
"cartridge start .router_1 # запускает отдельный экземпляр\n"
"\n"
"# в среде с несколькими приложениями\n"
"cartridge start my_app # запускает все экземпляры my_app\n"
"cartridge start my_app.router # запускает отдельный экземпляр"

msgid "To stop the instances, say:"
msgstr "Чтобы остановить экземпляры, выполните команду:"

msgid "$ cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr "$ cartridge stop [ИМЯ_ПРИЛОЖЕНИЯ[.ИМЯ_ЭКЗЕМПЛЯРА]] [параметры]"

msgid "These options from the ``cartridge start`` command are supported:"
msgstr "Поддерживаются следующие параметры из команды `cartridge start``:"

msgid "Start/stop using ``systemctl``"
msgstr "Запуск/остановка с помощью ``systemctl``"

msgid "To run a single instance:"
msgstr "Чтобы запустить отдельный экземпляр:"

msgid "$ systemctl start APP_NAME"
msgstr "$ systemctl start ИМЯ_ПРИЛОЖЕНИЯ"

msgid ""
"This will start a  ``systemd`` service that will listen to the port "
"specified in :ref:`instance configuration <cartridge-config>` "
"(``http_port`` parameter)."
msgstr ""
"Это запустит службу ``systemd``, которая будет прослушивать порт, "
"указанный в :ref:`конфигурации экземпляра <cartridge-config>` (параметр "
"``http_port``)."

msgid "To run multiple instances on one or multiple servers:"
msgstr "Чтобы запустить несколько экземпляров на одном или нескольких серверах:"

msgid ""
"$ systemctl start APP_NAME@INSTANCE_1\n"
"$ systemctl start APP_NAME@INSTANCE_2\n"
"...\n"
"$ systemctl start APP_NAME@INSTANCE_N"
msgstr ""
"$ systemctl start ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_1\n"
"$ systemctl start ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_2\n"
"...\n"
"$ systemctl start ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_N"

msgid ""
"where ``APP_NAME@INSTANCE_N`` is the instantiated service name for "
"``systemd`` with an incremental ``N`` -- a number, unique for every "
"instance, added to the port the instance will listen to (e.g., ``3301``, "
"``3302``, etc.)"
msgstr ""
"где ``ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_N`` -- это имя экземпляра сервиса "
"``systemd`` с инкрементным числом N (уникальным для каждого экземпляра), "
"которое следует добавить к порту ``3300`` для настройки прослушивания "
"(например, ``3301``, ``3302`` и т.д.)."

msgid ""
"To stop all services on a server, use the ``systemctl stop`` command and "
"specify instance names one by one. For example:"
msgstr ""
"Чтобы остановить все сервисы на сервере, используйте команду ``systemctl "
"stop`` и укажите имена экземпляров по одному. Например:"

msgid ""
"$ systemctl stop APP_NAME@INSTANCE_1 APP_NAME@INSTANCE_2 ... "
"APP_NAME@INSTANCE_<N>"
msgstr ""
"$ systemctl stop ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_1 ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_2 "
"... ИМЯ_ПРИЛОЖЕНИЯ@ЭКЗЕМПЛЯР_<N>"
