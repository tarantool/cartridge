
msgid "Developer's guide"
msgstr "Руководство разработчика"

msgid ""
"For a quick start, skip the details below and jump right away to the "
"`Cartridge getting started guide "
"<https://www.tarantool.io/en/doc/latest/getting_started/getting_started_cartridge/>`_."
msgstr ""
"Если вы хотите сразу приступить к работе, пропустите подробное описание ниже"
" и переходите к `Руководству по началу работы с Cartridge "
"<https://www.tarantool.io/en/doc/latest/getting_started/getting_started_cartridge/>`_."

msgid ""
"For a deep dive into what you can develop with Tarantool Cartridge, go on "
"with the Cartridge developer's guide."
msgstr ""
"Чтобы тщательно изучить, какие возможности Tarantool Cartridge предоставляет"
" для разработки приложений, продолжайте знакомиться с руководством для "
"разработчика по Cartridge."

msgid "Introduction"
msgstr "Введение"

msgid ""
"To develop and start an application, in short, you need to go through the "
"following steps:"
msgstr ""
"Короче говоря, чтобы разработать и запустить приложение, вам необходимо "
"выполнить следующие шаги:"

msgid ""
":ref:`Install <cartridge-install-dev>` Tarantool Cartridge and other "
"components of the development environment."
msgstr ""
":ref:`Установить <cartridge-install-dev>` Tarantool Cartridge и другие "
"компоненты среды разработки."

msgid ":ref:`Create a project <cartridge-project>`."
msgstr ":ref:`Создать проект <cartridge-project>`."

msgid ""
"Develop the application. In case it is a cluster-aware application, "
"implement its logic in a custom (user-defined) :ref:`cluster role "
"<cartridge-roles>` to initialize the database in a cluster environment."
msgstr ""
"Разработать приложение. Если это приложение с поддержкой кластеров, "
"реализуйте его логику в виде отдельной (пользовательской) :ref:`кластерной "
"роли <cartridge-roles>`, чтобы инициализировать базу данных в кластерной "
"среде."

msgid ""
":ref:`Deploy <cartridge-deploy>` the application to target server(s). This "
"includes :ref:`configuring <cartridge-config>` and :ref:`starting "
"<cartridge-run>` the instance(s)."
msgstr ""
":ref:`Развернуть <cartridge-deploy>` приложение на сервере или серверах. Это"
" включает в себя :ref:`настройку <cartridge-config>` и :ref:`запуск "
"<cartridge-run>` экземпляров."

msgid ""
"In case it is a cluster-aware application, :ref:`deploy the cluster "
"<cartridge-deployment>`."
msgstr ""
"Если это приложение с поддержкой кластеров, :ref:`развернуть кластер "
"<cartridge-deployment>`."

msgid "The following sections provide details for each of these steps."
msgstr "В следующих разделах подробно описывается каждый из этих шагов."

msgid "Installing Tarantool Cartridge"
msgstr "Установка Tarantool Cartridge"

msgid ""
"`Install <https://github.com/tarantool/cartridge-cli#installation>`__ "
"``cartridge-cli``, a command-line tool for developing, deploying, and "
"managing Tarantool applications."
msgstr ""
"`Установите <https://github.com/tarantool/cartridge-cli#installation>`__ "
"``cartridge-cli`` — инструмент командной строки для разработки, "
"развертывания и управления Tarantool-приложениями."

msgid ""
"`Install <https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>`__ "
"``git``, a version control system."
msgstr ""
"`Установите <https://git-scm.com/book/en/v2/Getting-Started-Installing-"
"Git>`__ ``git`` — систему управления версиями."

msgid ""
"`Install <https://www.npmjs.com/get-npm>`__ ``npm``, a package manager for "
"``node.js``."
msgstr ""
"`Установите <https://www.npmjs.com/get-npm>`__ ``npm`` — менеджер пакетов "
"для ``node.js``."

msgid ""
"`Install <https://linuxize.com/post/how-to-unzip-files-in-linux/>`__ the "
"``unzip`` utility."
msgstr ""
"`Установите <https://linuxize.com/post/how-to-unzip-files-in-linux/>`__ "
"утилиту ``unzip``."

msgid "Creating a project"
msgstr "Создание проекта"

msgid ""
"To set up your development environment, create a project using the Tarantool"
" Cartridge project template. In any directory, run:"
msgstr ""
"Чтобы настроить среду разработки, создайте проект по шаблону проекта "
"Tarantool Cartridge. В любой директории выполните:"

msgid "$ cartridge create --name <app_name> /path/to/"
msgstr "$ cartridge create --name <app_name> /path/to/"

msgid ""
"This will automatically set up a Git repository in a new "
"``/path/to/<app_name>/`` directory, tag it with :ref:`version <cartridge-"
"versioning>` ``0.1.0``, and put the necessary files into it."
msgstr ""
"При этом будет автоматически создан Git-репозиторий в новом каталоге "
"``/путь/к/<app_name>/`` с необходимыми файлами и проставленным :ref:`тегом "
"версии <cartridge-versioning>` ``0.1.0``."

msgid ""
"In this Git repository, you can develop the application (by simply editing "
"the default files provided by the template), plug the necessary modules, and"
" then easily pack everything to deploy on your server(s)."
msgstr ""
"В этом Git-репозитории можно разработать приложение (просто редактируя файлы"
" из шаблона), подключить необходимые модули, а затем с легкостью упаковать "
"всё для развертывания на своих серверах."

msgid ""
"The project template creates the ``<app_name>/`` directory with the "
"following contents:"
msgstr ""
"Шаблон проекта создает каталог ``<app_name>/``, который включает в себя:"

msgid ""
"``<app_name>-scm-1.rockspec`` file where you can specify the application "
"dependencies."
msgstr ""
"файл ``<имя_приложения>-scm-1.rockspec``, где можно указать зависимости "
"приложения."

msgid ""
"``deps.sh`` script that resolves dependencies from the ``.rockspec`` file."
msgstr ""
"скрипт ``deps.sh``, который решает проблемы с зависимостями из файла "
"``.rockspec``."

msgid "``init.lua`` file which is the entry point for your application."
msgstr "файл ``init.lua``, который является точкой входа в ваше приложение."

msgid "``.git`` file necessary for a Git repository."
msgstr "файл ``.git``, необходимый для Git-репозитория."

msgid "``.gitignore`` file to ignore the unnecessary files."
msgstr "файл ``.gitignore``, чтобы не учитывать ненужные файлы."

msgid ""
"``env.lua`` file that sets common rock paths so that the application can be "
"started from any directory."
msgstr ""
"файл ``env.lua``, который устанавливает общие пути для модулей, чтобы "
"приложение можно было запустить из любого каталога."

msgid ""
"``custom-role.lua`` file that is a placeholder for a custom (user-defined) "
":ref:`cluster role <cartridge-roles>`."
msgstr ""
"файл ``custom-role.lua``, который представляет собой объект-заполнитель для "
"пользовательской :ref:`кластерной роли <cartridge-roles>`."

msgid ""
"The entry point file (``init.lua``), among other things, loads the "
"``cartridge`` module and calls its initialization function:"
msgstr ""
"Файл входа в приложение (``init.lua``), в частности, загружает модуль "
"``cartridge`` и вызывает соответствующую функцию инициализации:"

msgid ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"-- cartridge options example\n"
" workdir = '/var/lib/tarantool/app',\n"
" advertise_uri = 'localhost:3301',\n"
" cluster_cookie = 'super-cluster-cookie',\n"
" ...\n"
"}, {\n"
"-- box options example\n"
" memtx_memory = 1000000000,\n"
" ... })\n"
"..."
msgstr ""
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"-- пример настройки cartridge\n"
" workdir = '/var/lib/tarantool/app',\n"
" advertise_uri = 'localhost:3301',\n"
" cluster_cookie = 'super-cluster-cookie',\n"
" ...\n"
"}, {\n"
"-- пример настройки модуля box\n"
" memtx_memory = 1000000000,\n"
" ... })\n"
"..."

msgid ""
"The ``cartridge.cfg()`` call renders the instance operable via the "
"administrative console but does not call ``box.cfg()`` to configure "
"instances."
msgstr ""
"Вызов ``cartridge.cfg()`` позволяет управлять экземпляром через "
"административную консоль, но не вызывает ``box.cfg()`` для настройки "
"экземпляров."

msgid "Calling the ``box.cfg()`` function is forbidden."
msgstr "Запрещается вызывать функцию ``box.cfg()``."

msgid "The cluster itself will do it for you when it is time to:"
msgstr "Сам кластер сделает это за вас, когда придет время:"

msgid "bootstrap the current instance once you:"
msgstr "загрузить текущий экземпляр, когда вы:"

msgid "run ``cartridge.bootstrap()`` via the administrative console, or"
msgstr "выполните ``cartridge.bootstrap()`` в административной консоли, или"

msgid "click **Create** in the web interface;"
msgstr "нажмете **Create** в веб-интерфейсе;"

msgid "join the instance to an existing cluster once you:"
msgstr "присоединить экземпляр к существующему кластеру, когда вы:"

msgid ""
"run ``cartridge.join_server({uri = 'other_instance_uri'})`` via the console,"
" or"
msgstr ""
"выполните ``cartridge.join_server({uri = ''uri_другого_экземпляра'})`` в "
"консоли, или"

msgid ""
"click **Join** (an existing replica set) or **Create** (a new replica set) "
"in the web interface."
msgstr ""
"нажмете **Join** (Присоединить -- к уже существующему набору реплик) или "
"**Create** (Создать -- для нового набора реплик) в веб-интерфейсе."

msgid ""
"Notice that you can specify a cookie for the cluster (``cluster_cookie`` "
"parameter) if you need to run several clusters in the same network. The "
"cookie can be any string value."
msgstr ""
"Обратите внимание, что вы можете указать cookie для кластера (параметр "
"``cluster_cookie``), если необходимо запустить несколько кластеров в одной "
"сети. Cookie может представлять собой любое строковое значение."

msgid ""
"Now you can develop an application that will run on a single or multiple "
"independent Tarantool instances (e.g. acting as a proxy to third-party "
"databases) -- or will run in a cluster."
msgstr ""
"Теперь можно разрабатывать приложение, которое будет работать на одном или "
"нескольких независимых экземплярах Tarantool (например, в качестве прокси-"
"сервера для сторонних баз данных) — или в кластере."

msgid ""
"If you plan to develop a cluster-aware application, first familiarize "
"yourself with the notion of :ref:`cluster roles <cartridge-roles>`."
msgstr ""
"Если вы планируете разрабатывать приложение с поддержкой кластеров, сначала "
"познакомьтесь с понятием :ref:`кластерных ролей <cartridge-roles>`."

msgid "Cluster roles"
msgstr "Кластерные роли"

msgid ""
"**Cluster roles** are Lua modules that implement some specific functions "
"and/or logic. In other words, a Tarantool Cartridge cluster segregates "
"instance functionality in a role-based way."
msgstr ""
"**Кластерные роли** — это Lua-модули, которые реализуют некоторые конкретные"
" функции и/или логику. Другими словами, кластер Tarantool Cartridge "
"распределяет функции экземпляров на основе ролей."

msgid ""
"Since all instances running cluster applications use the same source code "
"and are aware of all the defined roles (and plugged modules), you can "
"dynamically enable and disable multiple different roles without restarts, "
"even during cluster operation."
msgstr ""
"Поскольку все экземпляры, выполняющие кластерные приложения, используют один"
" и тот же исходный код и знают обо всех определенных ролях (и подключенных "
"модулях), можно динамически включать и выключать несколько разных ролей без "
"перезапусков даже во время работы кластера."

msgid ""
"Note that every instance in a replica set performs the same roles and you "
"cannot enable/disable roles individually on some instances. In other words, "
"configuration of enabled roles is set up *per replica set*. See a step-by-"
"step configuration example in :ref:`this guide <cartridge-deployment>`."
msgstr ""
"Обратите внимание, что каждый экземпляр в наборе реплик выполняет одни и те "
"же роли, и нельзя включить/выключить роли отдельно для какого-то экземпляра."
" Другими словами, роли включаются *для набора реплик*. Пошаговый пример "
"настройки см. в :ref:`этом руководстве <cartridge-deployment>`."

msgid "Built-in roles"
msgstr "Встроенные роли"

msgid ""
"The ``cartridge`` module comes with two *built-in* roles that implement "
"automatic sharding:"
msgstr ""
"В модуль ``cartridge`` входят две *встроенные* роли, которые реализуют "
"автоматический шардинг:"

msgid ""
"``vshard-router`` that handles the ``vshard``'s *compute-intensive* "
"workload: routes requests to storage nodes."
msgstr ""
"``vshard-router`` обрабатывает *ресурсоемкие* вычисления в ``vshard``: "
"направляет запросы к узлам хранения данных."

msgid ""
"``vshard-storage`` that handles the ``vshard``'s *transaction-intensive* "
"workload: stores and manages a subset of a dataset."
msgstr ""
"``vshard-storage`` работает с *большим количеством транзакций* в ``vshard``:"
" хранит подмножество набора данных и управляет им."

msgid ""
"For more information on sharding, see the `vshard module documentation "
"<https://www.tarantool.io/en/doc/latest/reference/reference_rock/vshard/>`_."
msgstr ""
"Для получения дополнительной информации о шардировании см. `документацию по "
"модулю vshard "
"<https://www.tarantool.io/en/doc/latest/reference/reference_rock/vshard/>`_."

msgid ""
"With the built-in and :ref:`custom roles <cartridge-custom-roles>`, you can "
"develop applications with separated compute and transaction handling -- and "
"enable relevant workload-specific roles on different instances running on "
"physical servers with workload-dedicated hardware."
msgstr ""
"Благодаря встроенным и :ref:`пользовательским ролям <cartridge-custom-"
"roles>` можно разрабатывать приложения, где обработка вычислений выполняется"
" отдельно от обработки транзакций, а также включать кластерные роли в "
"зависимости от рабочей нагрузки на экземпляры, которые работают на "
"физических серверах с аппаратным обеспечением, предназначенным для рабочей "
"нагрузки определенного типа."

msgid "Custom roles"
msgstr "Пользовательские роли"

msgid "You can implement custom roles for any purposes, for example:"
msgstr "Вы можете создавать пользовательские роли для любых целей, например:"

msgid "define stored procedures;"
msgstr "определять хранимые процедуры;"

msgid "implement extra features on top of ``vshard``;"
msgstr "реализовать дополнительные функции на основе ``vshard``;"

msgid "go without ``vshard`` at all;"
msgstr "полностью обойтись без ``vshard``;"

msgid ""
"implement one or multiple supplementary services such as e-mail notifier, "
"replicator, etc."
msgstr ""
"внедрить одну или несколько дополнительных служб, таких как средство "
"уведомления по электронной почте, репликатор и т.д."

msgid "To implement a custom cluster role, do the following:"
msgstr ""
"Чтобы реализовать пользовательскую кластерную роль, выполните следующие "
"действия:"

msgid ""
"Take the ``app/roles/custom.lua`` file in your project as a sample. Rename "
"this file as you wish, e.g. ``app/roles/custom-role.lua``, and implement the"
" role's logic. For example:"
msgstr ""
"Возьмите в качестве примера файл ``app/roles/custom.lua`` из проекта. "
"Переименуйте этот файл как угодно, например ``app/roles/custom-role.lua``, и"
" опишите логику роли. Например:"

msgid ""
"-- Implement a custom role in app/roles/custom-role.lua\n"
"local role_name = 'custom-role'\n"
"\n"
"local function init()\n"
"...\n"
"end\n"
"\n"
"local function stop()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    init = init,\n"
"    stop = stop,\n"
"}"
msgstr ""
"-- Реализуйте пользовательскую роль в app/roles/custom-role.lua\n"
"local role_name = 'custom-role'\n"
"\n"
"local function init()\n"
"...\n"
"end\n"
"\n"
"local function stop()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    init = init,\n"
"    stop = stop,\n"
"}"

msgid ""
"Here the ``role_name`` value may differ from the module name passed to the "
"``cartridge.cfg()`` function. If the ``role_name`` variable is not "
"specified, the module name is the default value."
msgstr ""
"Здесь значение ``role_name`` может отличаться от имени модуля, переданного в"
" функцию ``cartridge.cfg()``. Если не указать переменную ``role_name``, то "
"значением по умолчанию будет имя модуля."

msgid ""
"Role names must be unique as it is impossible to register multiple roles "
"with the same name."
msgstr ""
"Имена ролей должны быть уникальными, поскольку нельзя зарегистрировать "
"несколько ролей с одним именем."

msgid ""
"Register the new role in the cluster by modifying the ``cartridge.cfg()`` "
"call in the ``init.lua`` entry point file:"
msgstr ""
"Зарегистрируйте новую роль в кластере, изменив вызов ``cartridge.cfg()`` в "
"файле входа в приложение ``init.lua``:"

msgid ""
"-- Register a custom role in init.lua\n"
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"    workdir = ...,\n"
"    advertise_uri = ...,\n"
"    roles = {'custom-role'},\n"
"})\n"
"..."
msgstr ""
"-- Зарегистрируйте пользовательскую роль в init.lua,\n"
"...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"    workdir = ...,\n"
"    advertise_uri = ...,\n"
"    roles = {'custom-role'},\n"
"})\n"
"..."

msgid "where ``custom-role`` is the name of the Lua module to be loaded."
msgstr "где ``custom-role`` — это название загружаемого Lua-модуля."

msgid ""
"The role module does not have required functions, but the cluster may "
"execute the following ones during the :ref:`role's life cycle <cartridge-"
"role-lifecycle>`:"
msgstr ""
"В модуле роли нет необходимых функций, но в течение :ref:`жизненного цикла "
"роли <cartridge-role-lifecycle>` кластер может выполнять следующие функции:"

msgid "``init()`` is the role's *initialization* function."
msgstr "``init()`` -- это функция *инициализации* роли."

msgid ""
"Inside the function's body you can call any `box "
"<https://www.tarantool.io/en/doc/latest/reference/reference_lua/box/>`_ "
"functions: create spaces, indexes, grant permissions, etc. Here is what the "
"initialization function may look like:"
msgstr ""
"В пределах тела функции можно вызывать любые функции из `box "
"<https://www.tarantool.io/en/doc/latest/reference/reference_lua/box/>`_: "
"создавать спейсы, индексы, выдавать права и т.д. Вот как может выглядеть "
"функция инициализации:"

msgid ""
" local function init(opts)\n"
"     -- The cluster passes an 'opts' Lua table containing an 'is_master' flag.\n"
"     if opts.is_master then\n"
"         local customer = box.schema.space.create('customer',\n"
"             { if_not_exists = true }\n"
"         )\n"
"         customer:format({\n"
"             {'customer_id', 'unsigned'},\n"
"             {'bucket_id', 'unsigned'},\n"
"             {'name', 'string'},\n"
"         })\n"
"         customer:create_index('customer_id', {\n"
"             parts = {'customer_id'},\n"
"             if_not_exists = true,\n"
"         })\n"
"     end\n"
" end"
msgstr ""
" local function init(opts)\n"
"     -- Кластер передает Lua-таблицу 'opts', содержащую флаг 'is_master'.\n"
"     if opts.is_master then\n"
"         local customer = box.schema.space.create('customer',\n"
"             { if_not_exists = true }\n"
"         )\n"
"         customer:format({\n"
"             {'customer_id', 'unsigned'},\n"
"             {'bucket_id', 'unsigned'},\n"
"             {'name', 'string'},\n"
"         })\n"
"         customer:create_index('customer_id', {\n"
"             parts = {'customer_id'},\n"
"             if_not_exists = true,\n"
"         })\n"
"     end\n"
" end"

msgid ""
"Neither ``vshard-router`` nor ``vshard-storage`` manage spaces, indexes, or "
"formats. You should do it within a *custom* role: add a "
"``box.schema.space.create()`` call to your first cluster role, as shown in "
"the example above."
msgstr ""
"Спейсами, индексами и форматами не управляют ни ``vshard-router``, ни "
"``vshard-storage`` — это придется делать в рамках *пользовательской* роли, "
"то есть добавить вызов ``box.schema.space.create()`` к первой кластерной "
"роли, как показано в примере выше."

msgid ""
"The function's body is wrapped in a conditional statement that lets you call"
" ``box`` functions on masters only. This protects against replication "
"collisions as data propagates to replicas automatically."
msgstr ""
"Тело функции заключено в условный оператор, который позволяет вызывать "
"функции ``box`` только на мастерах. Это предотвращает конфликты репликации, "
"так как данные автоматически передаются на реплики."

msgid ""
"``stop()`` is the role's *termination* function. Implement it if "
"initialization starts a fiber that has to be stopped or does any job that "
"needs to be undone on termination."
msgstr ""
"``stop()`` — это функция *завершения работы* роли. Ее стоит использовать, "
"если инициализация запускает файбер, который нужно остановить, или же "
"выполняет любую задачу, которую нужно отменить при завершении работы."

msgid ""
"``validate_config()`` and ``apply_config()`` are functions that *validate* "
"and *apply* the role's configuration. Implement them if some configuration "
"data needs to be stored cluster-wide."
msgstr ""
"``validate_config()`` и ``apply_config()`` — это функции, которые "
"*валидируют* и *применяют* настройки роли соответственно. Их стоит "
"использовать, если какие-то настройки нужно хранить на уровне кластера."

msgid ""
"Next, get a grip on the :ref:`role's life cycle <cartridge-role-lifecycle>` "
"to implement the functions you need."
msgstr ""
"Далее, изучите :ref:`жизненный цикл ролей <cartridge-role-lifecycle>`, чтобы"
" реализовать необходимые функции."

msgid "Defining role dependencies"
msgstr "Определение зависимостей для ролей"

msgid ""
"You can instruct the cluster to apply some other roles if your custom role "
"is enabled."
msgstr ""
"Можно заставить кластер применить некоторые другие роли, если включена "
"пользовательская роль."

msgid "For example:"
msgstr "Например:"

msgid ""
"-- Role dependencies defined in app/roles/custom-role.lua\n"
"local role_name = 'custom-role'\n"
"...\n"
"return {\n"
"    role_name = role_name,\n"
"    dependencies = {'cartridge.roles.vshard-router'},\n"
"    ...\n"
"}"
msgstr ""
"-- Зависимости для ролей, определенные в app/roles/custom-role.lua\n"
"local role_name = 'custom-role'\n"
"...\n"
"return {\n"
"    role_name = role_name,\n"
"    dependencies = {'cartridge.roles.vshard-router'},\n"
"    ...\n"
"}"

msgid ""
"Here ``vshard-router`` role will be initialized automatically for every "
"instance with ``custom-role`` enabled."
msgstr ""
"Здесь роль ``vshard-router`` будет инициализирована автоматически для "
"каждого экземпляра, в котором включена роль ``custom-role``."

msgid "Using multiple vshard storage groups"
msgstr "Использование нескольких групп vshard storage"

msgid ""
"Replica sets with ``vshard-storage`` roles can belong to different *groups*."
" For example, ``hot`` or ``cold`` groups meant to independently process hot "
"and cold data."
msgstr ""
"Для наборов реплик с ролью ``vshard-storage`` можно задавать *группы*. "
"Например, группы ``hot`` и ``cold`` предназначены для независимой обработки "
"горячих и холодных данных."

msgid "Groups are specified in the cluster's configuration:"
msgstr "Группы указаны в конфигурации кластера:"

msgid ""
"-- Specify groups in init.lua\n"
"cartridge.cfg({\n"
"    vshard_groups = {'hot', 'cold'},\n"
"    ...\n"
"})"
msgstr ""
"-- Укажите группы в init.lua\n"
"cartridge.cfg({\n"
"    vshard_groups = {'hot', 'cold'},\n"
"    ...\n"
"})"

msgid ""
"If no groups are specified, the cluster assumes that all replica sets belong"
" to the ``default`` group."
msgstr ""
"Если ни одна группа не указана, кластер предполагает, что все наборы реплик "
"входят в группу ``default`` (по умолчанию)."

msgid ""
"With multiple groups enabled, every replica set with a ``vshard-storage`` "
"role enabled must be assigned to a particular group. The assignment can "
"never be changed."
msgstr ""
"Если включены несколько групп, каждый набор реплик с включенной ролью "
"``vshard-storage`` должен быть назначен в определенную группу. Эту настройку"
" нельзя изменить впоследствии."

msgid ""
"Another limitation is that you cannot add groups dynamically (this will "
"become available in future)."
msgstr ""
"Есть еще одно ограничение -- нельзя добавлять группы динамически (такая "
"возможность появится в будущих версиях)."

msgid ""
"Finally, mind the syntax for router access. Every instance with a ``vshard-"
"router`` role enabled initializes multiple routers. All of them are "
"accessible through the role:"
msgstr ""
"Наконец, обратите внимание на синтаксис для доступа к роутеру. Каждый "
"экземпляр со включенной ролью ``vshard-router`` инициализирует несколько "
"роутеров. Доступ к ним можно получить через роль:"

msgid ""
"local router_role = cartridge.service_get('vshard-router')\n"
"router_role.get('hot'):call(...)"
msgstr ""
"local router_role = cartridge.service_get('vshard-router')\n"
"router_role.get('hot'):call(...)"

msgid ""
"If you have no roles specified, you can access a static router as before "
"(when Tarantool Cartridge was unaware of groups):"
msgstr ""
"Если роли не указаны, доступ к статическому роутеру можно получить, как и "
"прежде (когда Tarantool Cartridge не знал о группах):"

msgid ""
"local vhsard = require('vshard')\n"
"vshard.router.call(...)"
msgstr ""
"local vhsard = require('vshard')\n"
"vshard.router.call(...)"

msgid ""
"However, when using the current group-aware API, you must call a static "
"router with a colon:"
msgstr ""
"Тем не менее, при использовании действующего API, работающего с группами, "
"статический роутер следует вызывать при помощи двоеточия:"

msgid ""
"local router_role = cartridge.service_get('vshard-router')\n"
"local default_router = router_role.get() -- or router_role.get('default')\n"
"default_router:call(...)"
msgstr ""
"local router_role = cartridge.service_get('vshard-router')\n"
"local default_router = router_role.get() -- или router_role.get('default')\n"
"default_router:call(...)"

msgid "Role's life cycle (and the order of function execution)"
msgstr "Жизненный цикл роли и порядок выполнения функций"

msgid ""
"The cluster displays the names of all custom roles along with the built-in "
"``vshard-*`` roles in the :ref:`web interface <cartridge-deployment>`. "
"Cluster administrators can enable and disable them for particular instances "
"-- either via the web interface or via the cluster `public API "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.admin/#edit-"
"topology-args>`_. For example:"
msgstr ""
"Кластер отображает все имена пользовательских ролей вместе с именами "
"встроенных ролей из ``vshard`` в :ref:`веб-интерфейсе <cartridge-"
"deployment>`. Администраторы кластера могут включать и отключать их для "
"определенных экземпляров либо в веб-интерфейсе, либо с помощью "
"`общедоступного API "
"<https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.admin/#edit-"
"topology-args>`_. Например:"

msgid ""
"cartridge.admin.edit_replicaset('replicaset-uuid', {roles = {'vshard-"
"router', 'custom-role'}})"
msgstr ""
"cartridge.admin.edit_replicaset('replicaset-uuid', {roles = {'vshard-"
"router', 'custom-role'}})"

msgid ""
"If you enable multiple roles on an instance at the same time, the cluster "
"first initializes the built-in roles (if any) and then the custom ones (if "
"any) in the order the latter were listed in ``cartridge.cfg()``."
msgstr ""
"Если несколько ролей одновременно включены на экземпляре, кластер сначала "
"инициализирует встроенные роли (если они есть), а затем пользовательские "
"(если они есть) в том порядке, в котором пользовательские роли были "
"перечислены в ``cartridge.cfg()``."

msgid ""
"If a custom role has dependent roles, the dependencies are registered and "
"validated first, *prior* to the role itself."
msgstr ""
"Если для пользовательской роли есть зависимые роли, сначала происходит "
"регистрация и валидация зависимостей, а *затем* уже самой роли."

msgid "The cluster calls the role's functions in the following circumstances:"
msgstr "Кластер вызывает функции роли в следующих случаях:"

msgid ""
"The ``init()`` function, typically, once: either when the role is enabled by"
" the administrator or at the instance restart. Enabling a role once is "
"normally enough."
msgstr ""
"Функция ``init()`` обычно выполняется один раз: либо когда администратор "
"включает роль, либо при перезапуске экземпляра. Как правило, достаточно один"
" раз включить роль."

msgid ""
"The ``stop()`` function -- only when the administrator disables the role, "
"not on instance termination."
msgstr ""
"Функция ``stop()`` -- только когда администратор отключает роль, а не во "
"время завершения работы экземпляра."

msgid ""
"The ``validate_config()`` function, first, before the automatic "
"``box.cfg()`` call (database initialization), then -- upon every "
"configuration update."
msgstr ""
"Функция ``validate_config()``: сначала до автоматического вызова "
"``box.cfg()`` (инициализация базы данных), а затем при каждом обновлении "
"конфигурации."

msgid "The ``apply_config()`` function upon every configuration update."
msgstr "Функция ``apply_config()`` -- при каждом обновлении конфигурации."

msgid ""
"As a tryout, let's task the cluster with some actions and see the order of "
"executing the role's functions:"
msgstr ""
"В качестве эксперимента дадим кластеру некоторые задачи и посмотрим порядок "
"выполнения функций роли:"

msgid "Join an instance or create a replica set, both with an enabled role:"
msgstr ""
"Присоединение экземпляра или создание набора реплик (в обоих случаях с "
"включенной ролью):"

msgid "``validate_config()``"
msgstr "``validate_config()``"

msgid "``init()``"
msgstr "``init()``"

msgid "``apply_config()``"
msgstr "``apply_config()``"

msgid "Restart an instance with an enabled role:"
msgstr "Перезапуск экземпляра с включенной ролью:"

msgid "Disable role: ``stop()``."
msgstr "Отключение роли: ``stop()``."

msgid "Upon the ``cartridge.confapplier.patch_clusterwide()`` call:"
msgstr "При вызове ``cartridge.confapplier.patch_clusterwide()``:"

msgid "Upon a triggered failover:"
msgstr "При запущенном восстановлении после отказа:"

msgid "Considering the described behavior:"
msgstr "Учитывая вышеописанное поведение:"

msgid "The ``init()`` function may:"
msgstr "Функция ``init()`` может:"

msgid "Call ``box`` functions."
msgstr "Вызывать функции ``box``."

msgid ""
"Start a fiber and, in this case, the ``stop()`` function should take care of"
" the fiber's termination."
msgstr ""
"Запускать файбер, и в таком случае функция ``stop()`` должна позаботиться о "
"завершении работы файбера."

msgid "Configure the built-in :ref:`HTTP server <cartridge-httpd-instance>`."
msgstr "Настраивать встроенный :ref:`HTTP-сервер <cartridge-httpd-instance>`."

msgid "Execute any code related to the role's initialization."
msgstr "Выполнять любой код, связанный с инициализацией роли."

msgid ""
"The ``stop()`` functions must undo any job that needs to be undone on role's"
" termination."
msgstr ""
"Функции ``stop()`` должны отменять любую задачу, которую нужно отменить при "
"завершении работы роли."

msgid ""
"The ``validate_config()`` function must validate any configuration change."
msgstr ""
"Функция ``validate_config()`` должна валидировать любые изменения "
"конфигурации."

msgid ""
"The ``apply_config()`` function may execute any code related to a "
"configuration change, e.g., take care of an ``expirationd`` fiber."
msgstr ""
"Функция ``apply_config()`` может выполнять любой код, связанный с изменением"
" конфигурации, например, следить за файбером ``expirationd``."

msgid ""
"The validation and application functions together allow you to change the "
"cluster-wide configuration as described in the :ref:`next section "
"<cartridge-role-config>`."
msgstr ""
"Функции валидации и применения конфигурации позволяют настроить конфигурацию"
" всего кластера, как описано в :ref:`следующем разделе <cartridge-role-"
"config>`."

msgid "Configuring custom roles"
msgstr "Конфигурация пользовательских ролей"

msgid "You can:"
msgstr "Вы можете:"

msgid ""
"Store configurations for your custom roles as sections in cluster-wide "
"configuration, for example:"
msgstr ""
"Хранить настройки пользовательских ролей в виде разделов в конфигурации на "
"уровне кластера, например:"

msgid ""
"# in YAML configuration file\n"
"my_role:\n"
"  notify_url: \"https://localhost:8080\""
msgstr ""
"# в конфигурационном YAML-файле\n"
"my_role:\n"
"  notify_url: \"https://localhost:8080\""

msgid ""
"-- in init.lua file\n"
"local notify_url = 'http://localhost'\n"
"function my_role.apply_config(conf, opts)\n"
"    local conf = conf['my_role'] or {}\n"
"    notify_url = conf.notify_url or 'default'\n"
"end"
msgstr ""
"-- в файле init.lua\n"
"local notify_url = 'http://localhost'\n"
"function my_role.apply_config(conf, opts)\n"
"    local conf = conf['my_role'] or {}\n"
"    notify_url = conf.notify_url or 'default'\n"
"end"

msgid ""
"Download and upload cluster-wide configuration using the :ref:`web interface"
" <cartridge-ui-configuration>` or API (via GET/PUT queries to "
"``admin/config`` endpoint like ``curl localhost:8081/admin/config`` and "
"``curl -X PUT -d \"{'my_parameter': 'value'}\" "
"localhost:8081/admin/config``)."
msgstr ""
"Загружать и выгружать конфигурацию всего кластера через :ref:`веб-интерфейс "
"<cartridge-ui-configuration>` или с помощью API (запросы GET/PUT к конечной "
"точке ``admin/config``: ``curl localhost:8081/admin/config`` и ``curl -X PUT"
" -d \"{'my_parameter': 'value'}\" localhost:8081/admin/config``)."

msgid "Utilize it in your role's ``apply_config()`` function."
msgstr "Использовать ее в функции ``apply_config()`` в своей роли."

msgid ""
"Every instance in the cluster stores a copy of the configuration file in its"
" working directory (configured by ``cartridge.cfg({workdir = ...})``):"
msgstr ""
"Каждый экземпляр в кластере хранит копию конфигурационного файла в своем "
"рабочем каталоге (который можно задать с помощью ``cartridge.cfg({workdir = "
"...})``):"

msgid ""
"``/var/lib/tarantool/<instance_name>/config.yml`` for instances deployed "
"from RPM packages and managed by ``systemd``."
msgstr ""
"``/var/lib/tarantool/<instance_name>/config.yml`` для экземпляров, "
"развернутых из RPM-пакетов, под управлением ``systemd``."

msgid ""
"``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` for "
"instances deployed from tar+gz archives."
msgstr ""
"``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` для "
"экземпляров, развернутых из архивов tar+gz."

msgid ""
"The cluster's configuration is a Lua table, downloaded and uploaded as YAML."
" If some application-specific configuration data, e.g. a database schema as "
"defined by DDL (data definition language), needs to be stored on every "
"instance in the cluster, you can implement your own API by adding a custom "
"section to the table. The cluster will help you spread it safely across all "
"instances."
msgstr ""
"Конфигурация кластера представляет собой Lua-таблицу, которую можно "
"загрузить и выгрузить в формате YAML. Если в каждом экземпляре кластера "
"необходимо хранить какие-то данные конфигурации для конкретного приложения "
"(например, схему базы данных, описанную с помощью языка определения данных "
"DDL), можно использовать свой собственный API, добавив в таблицу специальный"
" раздел. Кластер поможет вам безопасно передать настройки всем экземплярам."

msgid ""
"Such section goes in the same file with topology-specific and "
"``vshard``-specific sections that the cluster generates automatically. "
"Unlike the generated, the custom section's modification, validation, and "
"application logic has to be defined."
msgstr ""
"Этот раздел нужно создавать в том же файле, что и разделы по топологии и по "
"``vshard``, которые кластер генерирует автоматически. Но в отличие от "
"сгенерированных разделов, в специальном разделе необходимо определять "
"вручную логику изменения, проверки и применения конфигурации."

msgid "The common way is to define two functions:"
msgstr "Самый распространенный способ заключается в том, чтобы:"

msgid ""
"``validate_config(conf_new, conf_old)`` to validate changes made in the new "
"configuration (``conf_new``) versus the old configuration (``conf_old``)."
msgstr ""
"``validate_config(conf_new, conf_old)`` для валидации изменений, сделанных в"
" новой конфигурации (``conf_new``) по отношению к старой конфигурации "
"(``conf_old``)."

msgid ""
"``apply_config(conf, opts)`` to execute any code related to a configuration "
"change. As input, this function takes the configuration to apply (``conf``, "
"which is actually the new configuration that you validated earlier with "
"``validate_config()``) and options (the ``opts`` argument that includes "
"``is_master``, a Boolean flag described later)."
msgstr ""
"``apply_config(conf, opts)`` для выполнения любого кода, связанного с "
"изменениями конфигурации. Входными данными для этой функции будут "
"применяемая конфигурация (``conf``, которая и есть новая конфигурация, "
"проверенная чуть ранее с помощью ``validate_config()``), а также параметры "
"(аргумент ``opts`` включает в себя описываемый ниже логический флаг "
"``is_master`` )."

msgid ""
"The ``validate_config()`` function must detect all configuration problems "
"that may lead to ``apply_config()`` errors. For more information, see the "
":ref:`next section <cartridge-role-config-apply>`."
msgstr ""
"Функция ``validate_config()`` должна обнаружить все проблемы конфигурации, "
"которые могут привести к ошибкам ``apply_config()``. Для получения "
"дополнительной информации см. :ref:`следующий раздел <cartridge-role-config-"
"apply>`."

msgid ""
"When implementing validation and application functions that call ``box`` "
"ones for some reason, mind the following precautions:"
msgstr ""
"При реализации функций валидации и применения конфигурации, которые по "
"какой-либо причине вызывают функции ``box``, следует принять меры "
"предосторожности:"

msgid ""
"Due to the :ref:`role's life cycle <cartridge-role-lifecycle>`, the cluster "
"does not guarantee an automatic ``box.cfg()`` call prior to calling "
"``validate_config()``."
msgstr ""
":ref:`Жизненный цикл роли <cartridge-role-lifecycle>` не предполагает, что "
"кластер автоматически вызовет ``box.cfg()`` до вызова ``validate_config()``."

msgid ""
"If the validation function calls any ``box`` functions (e.g., to check a "
"format), make sure the calls are wrapped in a protective conditional "
"statement that checks if ``box.cfg()`` has already happened:"
msgstr ""
"Если функция валидации конфигурации вызывает функции из ``box`` (например, "
"для проверки формата), убедитесь, что вызовы включены в защитный условный "
"оператор, который проверяет, был ли уже вызов ``box.cfg()``:"

msgid ""
"-- Inside the validate_config() function:\n"
"if type(box.cfg) == 'table' then\n"
"    -- Here you can call box functions\n"
"end"
msgstr ""
"-- Внутри функции validate_config():\n"
"if type(box.cfg) == 'table' then\n"
"    -- Здесь вы можете вызывать функции из box\n"
"end"

msgid ""
"Unlike the validation function, ``apply_config()`` can call ``box`` "
"functions freely as the cluster applies custom configuration after the "
"automatic ``box.cfg()`` call."
msgstr ""
"В отличие от функции валидации, ``apply_config()`` может свободно вызывать "
"функции из ``box``, потому что кластер применяет пользовательскую "
"конфигурацию после автоматического вызова ``box.cfg()``."

msgid ""
"However, creating spaces, users, etc., can cause replication collisions when"
" performed on both master and replica instances simultaneously. The "
"appropriate way is to call such ``box`` functions *on masters only* and let "
"the changes propagate to replicas automatically."
msgstr ""
"Тем не менее, создание спейсов, пользователей и т. д. может вызвать "
"конфликты репликации при одновременном выполнении на мастере и на реплике. "
"Лучше всего вызывать такие функции из ``box`` *только на мастерах*, а на "
"реплики изменения отправятся автоматически."

msgid ""
"Upon the ``apply_config(conf, opts)`` execution, the cluster passes an "
"``is_master`` flag in the ``opts`` table which you can use to wrap "
"collision-inducing ``box`` functions in a protective conditional statement:"
msgstr ""
"По выполнении ``apply_config(conf, opts)`` кластер передает флаг "
"``is_master`` в таблице ``opts``, который можно использовать для заключения "
"функций из ``box`` в защитный условный оператор, если они могут вызвать "
"конфликт:"

msgid ""
"-- Inside the apply_config() function:\n"
"if opts.is_master then\n"
"    -- Here you can call box functions\n"
"end"
msgstr ""
"-- Внутри функции  apply_config():\n"
"if opts.is_master then\n"
"    -- Здесь вы можете вызывать функции из box\n"
"end"

msgid "Custom configuration example"
msgstr "Пример пользовательской конфигурации"

msgid ""
"Consider the following code as part of the role's module (``custom-"
"role.lua``) implementation:"
msgstr ""
"Рассмотрим следующий код как часть реализации модуля роли (``custom-"
"role.lua``):"

msgid ""
"-- Custom role implementation\n"
"\n"
"local cartridge = require('cartridge')\n"
"\n"
"local role_name = 'custom-role'\n"
"\n"
"-- Modify the config by implementing some setter (an alternative to HTTP PUT)\n"
"local function set_secret(secret)\n"
"    local custom_role_cfg = cartridge.confapplier.get_deepcopy(role_name) or {}\n"
"    custom_role_cfg.secret = secret\n"
"    cartridge.confapplier.patch_clusterwide({\n"
"        [role_name] = custom_role_cfg,\n"
"    })\n"
"end\n"
"-- Validate\n"
"local function validate_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    if custom_role_cfg.secret ~= nil then\n"
"        assert(type(custom_role_cfg.secret) == 'string', 'custom-role.secret must be a string')\n"
"    end\n"
"    return true\n"
"end\n"
"-- Apply\n"
"local function apply_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    local secret = custom_role_cfg.secret or 'default-secret'\n"
"    -- Make use of it\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    set_secret = set_secret,\n"
"    validate_config = validate_config,\n"
"    apply_config = apply_config,\n"
"}"
msgstr ""
"-- Реализация пользовательской роли\n"
"\n"
"local cartridge = require('cartridge')\n"
"\n"
"local role_name = 'custom-role'\n"
"\n"
"-- Измените конфигурацию, реализовав свой метод, устанавливающий значение поля (как альтернативу для HTTP PUT)\n"
"local function set_secret(secret)\n"
"    local custom_role_cfg = cartridge.confapplier.get_deepcopy(role_name) or {}\n"
"    custom_role_cfg.secret = secret\n"
"    cartridge.confapplier.patch_clusterwide({\n"
"        [role_name] = custom_role_cfg,\n"
"    })\n"
"end\n"
"-- Валидируйте конфигурацию\n"
"local function validate_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    if custom_role_cfg.secret ~= nil then\n"
"        assert(type(custom_role_cfg.secret) == 'string', 'custom-role.secret must be a string')\n"
"    end\n"
"    return true\n"
"end\n"
"-- Примените её\n"
"local function apply_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    local secret = custom_role_cfg.secret or 'default-secret'\n"
"    -- И используйте\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    set_secret = set_secret,\n"
"    validate_config = validate_config,\n"
"    apply_config = apply_config,\n"
"}"

msgid "Once the configuration is customized, do one of the following:"
msgstr "После настройки конфигурации выполните одно из следующих действий:"

msgid ""
"continue developing your application and pay attention to its "
":ref:`versioning <cartridge-versioning>`;"
msgstr ""
"продолжите разработку приложения, обращая особое внимание на "
":ref:`управление версиями <cartridge-versioning>`;"

msgid ""
"(optional) :ref:`enable authorization <cartridge-auth-enable>` in the web "
"interface."
msgstr ""
"(необязательно) :ref:`включите авторизацию <cartridge-auth-enable>` в веб-"
"интерфейсе."

msgid ""
"in case the cluster is already deployed, :ref:`apply the configuration "
"<cartridge-role-config-apply>` cluster-wide."
msgstr ""
"если кластер уже развернут, :ref:`примените конфигурацию <cartridge-role-"
"config-apply>` для всего кластера."

msgid "Applying custom role's configuration"
msgstr "Применение конфигурации пользовательской роли"

msgid ""
"With the implementation showed by the :ref:`example <cartridge-role-config-"
"example>`, you can call the ``set_secret()`` function to apply the new "
"configuration via the administrative console -- or an HTTP endpoint if the "
"role exports one."
msgstr ""
"В :ref:`примере <cartridge-role-config-example>` реализации можно вызвать "
"функцию ``set_secret()``, чтобы применить новую конфигурацию с помощью "
"административной консоли или конечной точки HTTP, если роль ее экспортирует."

msgid ""
"The ``set_secret()`` function calls "
"``cartridge.confapplier.patch_clusterwide()`` which performs a two-phase "
"commit:"
msgstr ""
"Функция ``set_secret()`` вызывает "
"``cartridge.confapplier.patch_clusterwide()``, которая производит двухфазную"
" фиксацию транзакций:"

msgid ""
"It patches the active configuration in memory: copies the table and replaces"
" the ``\"custom-role\"`` section in the copy with the one given by the "
"``set_secret()`` function."
msgstr ""
"Исправляет активную конфигурацию в памяти: копирует таблицу и заменяет "
"раздел ``\"custom-role\"`` в копии на раздел, который задан функцией "
"``set_secret()``."

msgid ""
"The cluster checks if the new configuration can be applied on all instances "
"except disabled and expelled. All instances subject to update must be "
"healthy and ``alive`` according to the `membership module "
"<https://www.tarantool.io/en/doc/latest/reference/reference_rock/membership/>`_."
msgstr ""
"Кластер проверяет, можно ли применить новую конфигурацию ко всем "
"экземплярам, кроме отключенных и исключенных. Все обновляемые экземпляры "
"должны быть исправными и в статусе ``alive`` в соответствии с требованиями "
"`модуля membership "
"<https://www.tarantool.io/en/doc/latest/reference/reference_rock/membership/>`_."

msgid ""
"(**Preparation phase**) The cluster propagates the patched configuration. "
"Every instance validates it with the ``validate_config()`` function of every"
" registered role. Depending on the validation's result:"
msgstr ""
"(**Фаза подготовки**) Кластер передает исправленную конфигурацию. Каждый "
"экземпляр валидирует ее с помощью функции ``validate_config()`` из каждой "
"зарегистрированной роли. В зависимости от результата валидации:"

msgid ""
"If successful (i.e., returns ``true``), the instance saves the new "
"configuration to a temporary file named ``config.prepare.yml`` within the "
"working directory."
msgstr ""
"В случае успеха (то есть возврата значения ``true``) экземпляр сохраняет "
"новую конфигурацию во временный файл с именем ``config.prepare.yml`` в "
"рабочем каталоге."

msgid ""
"(**Abort phase**) Otherwise, the instance reports an error and all the other"
" instances roll back the update: remove the file they may have already "
"prepared."
msgstr ""
"(**Фаза отмены**) В противном случае экземпляр сообщает об ошибке, а все "
"остальные экземпляры откатывают обновление: удаляют файл, если уже "
"подготовили его."

msgid ""
"(**Commit phase**) Upon successful preparation of all instances, the cluster"
" commits the changes. Every instance:"
msgstr ""
"(**Фаза коммита**) После успешной подготовки всех экземпляров кластер "
"фиксирует изменения. Каждый экземпляр:"

msgid "Creates the active configuration's hard-link."
msgstr "Создает жесткую ссылку на активную конфигурацию."

msgid ""
"Atomically replaces the active configuration file with the prepared one. The"
" atomic replacement is indivisible -- it can either succeed or fail "
"entirely, never partially."
msgstr ""
"Атомарно заменяет активный файл конфигурации на подготовленный файл. "
"Атомарная замена неделима: она выполняется или не выполняется полностью — но"
" не частично."

msgid "Calls the ``apply_config()`` function of every registered role."
msgstr "Вызывает функцию ``apply_config()`` каждой зарегистрированной роли."

msgid ""
"If any of these steps fail, an error pops up in the web interface next to "
"the corresponding instance. The cluster does not handle such errors "
"automatically, they require manual repair."
msgstr ""
"Если любой из этих шагов не будет выполнен, в веб-интерфейсе появится ошибка"
" рядом с соответствующим экземпляром. Кластер не обрабатывает такие ошибки "
"автоматически, их необходимо исправлять вручную."

msgid ""
"You will avoid the repair if the ``validate_config()`` function can detect "
"all configuration problems that may lead to ``apply_config()`` errors."
msgstr ""
"Такого рода исправлений можно избежать, если функция ``validate_config()`` "
"сможет обнаружить все проблемы конфигурации, которые могут привести к "
"ошибкам в ``apply_config()``."

msgid "Using the built-in HTTP server"
msgstr "Использование встроенного HTTP-сервера"

msgid ""
"The cluster launches an ``httpd`` server instance during initialization "
"(``cartridge.cfg()``). You can bind a port to the instance via an "
"environmental variable:"
msgstr ""
"Кластер запускает экземпляр ``httpd``-сервера во время инициализации "
"(``cartridge.cfg()``). Можно привязать порт к экземпляру через переменную "
"окружения:"

msgid ""
"-- Get the port from an environmental variable or the default one:\n"
"local http_port = os.getenv('HTTP_PORT') or '8080'\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    ...\n"
"    -- Pass the port to the cluster:\n"
"    http_port = http_port,\n"
"    ...\n"
"})"
msgstr ""
"-- Получите порт из переменной окружения или используйте значение по умолчанию:\n"
"local http_port = os.getenv('HTTP_PORT') or '8080'\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    ...\n"
"    -- Передайте порт кластеру:\n"
"    http_port = http_port,\n"
"    ...\n"
"})"

msgid ""
"To make use of the ``httpd`` instance, access it and configure routes inside"
" the ``init()`` function of some role, e.g. a role that exposes API over "
"HTTP:"
msgstr ""
"Чтобы использовать ``httpd``-экземпляр, получите к нему доступ и настройте "
"маршруты в рамках функции ``init()`` для какой-либо роли (например, для  "
"роли, которая предоставляет API через HTTP):"

msgid ""
"local function init(opts)\n"
"\n"
"...\n"
"\n"
"    -- Get the httpd instance:\n"
"    local httpd = cartridge.service_get('httpd')\n"
"    if httpd ~= nil then\n"
"        -- Configure a route to, for example, metrics:\n"
"        httpd:route({\n"
"            method = 'GET',\n"
"            path = '/metrics',\n"
"            public = true,\n"
"        },\n"
"        function(req)\n"
"            return req:render({json = stat.stat()})\n"
"        end\n"
"        )\n"
"    end\n"
"end"
msgstr ""
"local function init(opts)\n"
"\n"
"...\n"
"\n"
"    -- Получите экземпляр httpd:\n"
"    local httpd = cartridge.service_get('httpd')\n"
"    if httpd ~= nil then\n"
"        -- Настройте маршрут, например к метрикам:\n"
"        httpd:route({\n"
"            method = 'GET',\n"
"            path = '/metrics',\n"
"            public = true,\n"
"        },\n"
"        function(req)\n"
"            return req:render({json = stat.stat()})\n"
"        end\n"
"        )\n"
"    end\n"
"end"

msgid ""
"For more information on using Tarantool's HTTP server, see `its "
"documentation <https://github.com/tarantool/http>`_."
msgstr ""
"Чтобы получить дополнительную информацию об использовании HTTP-сервера "
"Tarantool, обратитесь к `документации <https://github.com/tarantool/http>`_."

msgid "Implementing authorization in the web interface"
msgstr "Реализация авторизации в веб-интерфейсе"

msgid ""
"To implement authorization in the web interface of every instance in a "
"Tarantool cluster:"
msgstr ""
"Чтобы реализовать авторизацию в веб-интерфейсе для каждого экземпляра в "
"кластере Tarantool:"

msgid ""
"Implement a new, say, ``auth`` module with a ``check_password`` function. It"
" should check the credentials of any user trying to log in to the web "
"interface."
msgstr ""
"Используйте модуль, к примеру, ``auth`` с функцией ``check_password``. "
"Данная функция проверяет учетные данные любого пользователя, который "
"пытается войти в веб-интерфейс."

msgid ""
"The ``check_password`` function accepts a username and password and returns "
"an authentication success or failure."
msgstr ""
"Функция ``check_password`` принимает имя пользователя и пароль и возвращает "
"результат аутентификации: пройдена или нет."

msgid ""
"-- auth.lua\n"
"\n"
"-- Add a function to check the credentials\n"
"local function check_password(username, password)\n"
"\n"
"    -- Check the credentials any way you like\n"
"\n"
"    -- Return an authentication success or failure\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    return true\n"
"end\n"
"..."
msgstr ""
"-- auth.lua\n"
"\n"
"-- Добавьте функцию для проверки учетных данных\n"
"local function check_password(username, password)\n"
"\n"
"    -- Проверьте учетные данные любым удобным вам способом\n"
"\n"
"    -- Верните значение, означающее успех или неудачу аутентификации\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    return true\n"
"end\n"
"..."

msgid ""
"Pass the implemented ``auth`` module name as a parameter to "
"``cartridge.cfg()``, so the cluster can use it:"
msgstr ""
"Передайте имя используемого модуля ``auth`` в качестве параметра для "
"``cartridge.cfg()``, чтобы кластер мог использовать его:"

msgid ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    -- The cluster will automatically call 'require()' on the 'auth' module.\n"
"    ...\n"
"})"
msgstr ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    -- Кластер автоматически вызовет 'require()' для модуля 'auth'.\n"
"    ...\n"
"})"

msgid ""
"This adds a **Log in** button to the upper right corner of the web interface"
" but still lets the unsigned users interact with the interface. This is "
"convenient for testing."
msgstr ""
"Это добавит кнопку **Log in** (Войти) в верхний правый угол в веб-"
"интерфейсе, но все же позволит неавторизованным пользователям "
"взаимодействовать с интерфейсом, что удобно для тестирования."

msgid ""
"Also, to authorize requests to cluster API, you can use the HTTP basic "
"authorization header."
msgstr ""
"Кроме того, для авторизации запросов к API кластера можно использовать "
"базовый заголовок HTTP для авторизации."

msgid ""
"To require the authorization of every user in the web interface even before "
"the cluster bootstrap, add the following line:"
msgstr ""
"Чтобы требовать авторизацию каждого пользователя в веб-интерфейсе даже до "
"начальной загрузки кластера, добавьте следующую строку:"

msgid ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    auth_enabled = true,\n"
"    ...\n"
"})"
msgstr ""
"-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    auth_enabled = true,\n"
"    ...\n"
"})"

msgid ""
"With the authentication enabled and the ``auth`` module implemented, the "
"user will not be able to even bootstrap the cluster without logging in. "
"After the successful login and bootstrap, the authentication can be enabled "
"and disabled cluster-wide in the web interface and the ``auth_enabled`` "
"parameter is ignored."
msgstr ""
"С включенной аутентификацией при использовании модуля ``auth`` пользователь "
"не сможет даже загрузить кластер без входа в систему. После успешного входа "
"в систему и начальной загрузки можно включить и отключить аутентификацию для"
" всего кластера в веб-интерфейсе, а параметр ``auth_enabled`` игнорируется."

msgid "Application versioning"
msgstr "Управление версиями приложения"

msgid ""
"Tarantool Cartridge understands semantic versioning as described at "
"`semver.org <https://semver.org>`_. When developing an application, create "
"new Git branches and tag them appropriately. These tags are used to "
"calculate version increments for subsequent packing."
msgstr ""
"В Tarantool Cartridge используется семантический подход к управлению "
"версиями, как описано на сайте `semver.org <https://semver.org>`_. При "
"разработке приложения создайте новые ветки Git и проставьте соответствующие "
"теги. Эти теги будут использоваться для расчета увеличения версий при "
"последующей упаковке."

msgid ""
"For example, if your application has version 1.2.1, tag your current branch "
"with ``1.2.1`` (annotated or not)."
msgstr ""
"Например, если версия вашего приложения -- 1.2.1, пометьте текущую ветку "
"тегом ``1.2.1`` (с аннотациями или без них)."

msgid "To retrieve the current version from Git, run:"
msgstr ""
"Чтобы получить идентификатор текущей версии из Git, выполните команду:"

msgid ""
"$ git describe --long --tags\n"
"1.2.1-12-g74864f2"
msgstr ""
"$ git describe --long --tags\n"
"1.2.1-12-g74864f2"

msgid ""
"This output shows that we are 12 commits after the version 1.2.1. If we are "
"to package the application at this point, it will have a full version of "
"``1.2.1-12`` and its package will be named ``<app_name>-1.2.1-12.rpm``."
msgstr ""
"Вывод показывает, что после версии 1.2.1 было 12 коммитов. Если мы соберемся"
" упаковать приложение на данном этапе, его полная версия будет ``1.2.1-12``,"
" а пакет будет называться ``<имя_приложения>-1.2.1-12.rpm``."

msgid ""
"Non-semantic tags are prohibited. You will not be able to create a package "
"from a branch with the latest tag being non-semantic."
msgstr ""
"Запрещается использовать не семантические теги. Вы не сможете создать пакет "
"из ветки, если последний тег не будет семантическим."

msgid ""
"Once you :ref:`package <cartridge-deploy>` your application, the version is "
"saved in a ``VERSION`` file in the package root."
msgstr ""
"После :ref:`упаковки <cartridge-deploy>` приложения его версия сохраняется в"
" файл ``VERSION`` в корневой каталог пакета."

msgid "Using .cartridge.ignore files"
msgstr "Использование файлов .cartridge.ignore"

msgid ""
"You can add a ``.cartridge.ignore`` file to your application repository to "
"exclude particular files and/or directories from package builds."
msgstr ""
"В репозиторий приложения можно добавить файл ``.cartridge.ignore``, чтобы "
"исключить определенные файлы и/или каталоги из сборки пакета."

msgid ""
"For the most part, the logic is similar to that of ``.gitignore`` files. The"
" major difference is that in ``.cartridge.ignore`` files the order of "
"exceptions relative to the rest of the templates does not matter, while in "
"``.gitignore`` files the order does matter."
msgstr ""
"По большей части логика похожа на логику файлов ``.gitignore``. Основное "
"отличие состоит в том, что в файлах ``.cartridge.ignore`` порядок исключения"
" относительно остальных шаблонов не имеет значения, а в файлах "
"``.gitignore`` — имеет."

msgid "**.cartridge.ignore** entry"
msgstr "запись **.cartridge.ignore**"

msgid "ignores every..."
msgstr "игнорирует все..."

msgid "``target/``"
msgstr "``target/``"

msgid "**folder** (due to the trailing ``/``) named ``target``, recursively"
msgstr ""
"**папки** (поскольку в конце стоит ``/``) под названием ``target`` "
"рекурсивно"

msgid "``target``"
msgstr "``target``"

msgid "**file or folder** named ``target``, recursively"
msgstr "**файлы или папки** под названием ``target`` рекурсивно"

msgid "``/target``"
msgstr "``/target``"

msgid ""
"**file or folder** named ``target`` in the top-most directory (due to the "
"leading ``/``)"
msgstr ""
"**файлы или папки** под названием ``target`` в самом верхнем каталоге "
"(поскольку в начале стоит ``/``)"

msgid "``/target/``"
msgstr "``/target/``"

msgid ""
"**folder** named ``target`` in the top-most directory (leading and trailing "
"``/``)"
msgstr ""
"**папки** под названием ``target`` в самом верхнем каталоге (в начале и в "
"конце стоит ``/``)"

msgid "``*.class``"
msgstr "``*.class``"

msgid "every **file or folder** ending with ``.class``, recursively"
msgstr "**файлы или папки**, оканчивающиеся на ``.class``, рекурсивно"

msgid "``#comment``"
msgstr "``#comment``"

msgid "nothing, this is a comment (the first character is a ``#``)"
msgstr "ничего, это комментарий (первый символ -- ``#``)"

msgid "``\\#comment``"
msgstr "``\\#comment``"

msgid "every **file or folder** with name ``#comment`` (``\\`` for escaping)"
msgstr "**файлы или папки** под названием ``#comment`` (``\\\\`` для выделения)"

msgid "``target/logs/``"
msgstr "``target/logs/``"

msgid ""
"every **folder** named ``logs`` which is a subdirectory of a folder named "
"``target``"
msgstr ""
"**папки** под названием ``logs``, которые представляют собой подкаталог "
"папки под названием ``target``"

msgid "``target/*/logs/``"
msgstr "``target/*/logs/``"

msgid ""
"every **folder** named ``logs`` two levels under a folder named ``target`` "
"(``*`` doesn’t include ``/``)"
msgstr ""
"**папки** под названием ``logs`` на два уровня ниже папки под названием "
"``target`` (``*`` не включает ``/``)"

msgid "``target/**/logs/``"
msgstr "``target/**/logs/``"

msgid ""
"every **folder** named ``logs`` somewhere under a folder named ``target`` "
"(``**`` includes ``/``)"
msgstr ""
"**папки** под названием ``logs`` где угодно в пределах папки ``target`` "
"(``**`` включает ``/``)"

msgid "``*.py[co]``"
msgstr "``*.py[co]``"

msgid ""
"every **file or folder** ending in ``.pyc`` or ``.pyo``; however, it doesn’t"
" match ``.py!``"
msgstr ""
"**файлы или папки**, оканчивающиеся на ``.pyc`` или ``.pyo``, но не на "
"``.py!``"

msgid "``*.py[!co]``"
msgstr "``*.py[!co]``"

msgid "every **file or folder** ending in anything other than ``c`` or ``o``"
msgstr ""
"**файлы или папки**, оканчивающиеся на что угодно, кроме ``c`` или ``o``"

msgid "``*.file[0-9]``"
msgstr "``*.file[0-9]``"

msgid "every **file or folder** ending in digit"
msgstr "**файлы или папки**, оканчивающиеся на цифру"

msgid "``*.file[!0-9]``"
msgstr "``*.file[!0-9]``"

msgid "every **file or folder** ending in anything other than digit"
msgstr "**файлы или папки**, оканчивающиеся на что угодно, кроме цифры"

msgid "``*``"
msgstr "``*``"

msgid "**every**"
msgstr "**всё**"

msgid "``/*``"
msgstr "``/*``"

msgid "**everything** in the top-most directory (due to the leading ``/``)"
msgstr "**всё** в самом верхнем каталоге (поскольку в начале стоит ``/``)"

msgid "``**/*.tar.gz``"
msgstr "``**/*.tar.gz``"

msgid ""
"every ``*.tar.gz`` file or folder which is **one or more** levels under the "
"starting folder"
msgstr ""
"файлы ``*.tar.gz`` или папки, которые находятся на **один или несколько** "
"уровней ниже исходной папки"

msgid "``!file``"
msgstr "``!file``"

msgid ""
"every **file or folder** will be ignored even if it matches other patterns"
msgstr ""
"**файлы и папки** будут проигнорированы, даже если они подходят под другие "
"типы"

msgid "Failover architecture"
msgstr "Отказоустойчивая архитектура"

msgid ""
"An important concept in cluster topology is appointing **a leader**. Leader "
"is an instance which is responsible for performing key operations. To keep "
"things simple, you can think of a leader as of the only writable master. "
"Every replica set has its own leader, and there's usually not more than one."
msgstr ""
"Важную роль в кластерной топологии играет назначение **лидера**. Лидер — это"
" экземпляр, который отвечает за выполнение ключевых операций. Чтобы не "
"усложнять, можно сказать, что лидер — это единственный мастер, доступный для"
" записи. Для каждого набора реплик есть свой лидер — и обычно не больше "
"одного."

msgid ""
"Which instance will become a leader depends on topology settings and "
"failover configuration."
msgstr ""
"Назначение экземпляра лидером происходит в зависимости от настроек топологии"
" и конфигурации восстановления после отказа."

msgid ""
"An important topology parameter is the **failover priority** within a "
"replica set. This is an ordered list of instances. By default, the first "
"instance in the list becomes a leader, but with the failover enabled it may "
"be changed automatically if the first one is malfunctioning."
msgstr ""
"Важный параметр топологии — **приоритет восстановления после отказа** в "
"пределах набора реплик, который представляет собой упорядоченный список "
"экземпляров. По умолчанию первый экземпляр в списке становится лидером, но "
"если включено восстановление после отказа, лидер может меняться "
"автоматически, когда первый экземпляр не работает."

msgid "Instance configuration upon a leader change"
msgstr "Конфигурация экземпляра при смене лидера"

msgid ""
"When Cartridge configures roles, it takes into account the **leadership "
"map** (consolidated in the ``failover.lua`` module). The leadership map is "
"composed when the instance enters the ``ConfiguringRoles`` state for the "
"first time. Later the map is updated according to the failover mode."
msgstr ""
"Когда Cartridge настраивает роли, он учитывает **ассоциативный массив "
"лидеров** (консолидированный в модуле ``failover.lua``). Ассоциативный "
"массив лидеров составляется, когда экземпляр впервые входит в состояние "
"``ConfiguringRoles``. В дальнейшем массив обновляется в соответствии с "
"режимом восстановления после отказа."

msgid ""
"Every change in the leadership map is accompanied by instance re-"
"configuration. When the map changes, Cartridge updates the ``read_only`` "
"setting and calls the ``apply_config`` callback for every role. It also "
"specifies the ``is_master`` flag (which actually means ``is_leader``, but "
"hasn't been renamed yet due to historical reasons)."
msgstr ""
"Каждое изменение в ассоциативном массиве лидеров сопровождается "
"переконфигурацией экземпляра. Когда массив меняется, Cartridge обновляет "
"параметр ``read_only`` и вызывает ``apply_config`` для каждой роли. Он также"
" устанавливает флаг ``is_master`` (который на самом деле означает "
"``is_leader``, но еще не переименован в силу исторических причин)."

msgid ""
"It's important to say that we discuss a *distributed* system where every "
"instance has its own opinion. Even if all opinions coincide, there still may"
" be races between instances, and you (as an application developer) should "
"take them into account when designing roles and their interaction."
msgstr ""
"Важно отметить, что речь идет о *распределенной* системе, где у каждого "
"экземпляра есть свое собственное мнение. Даже если все мнения совпадают, "
"экземпляры все равно могут быть в состоянии гонки, и вам (как разработчику "
"приложения) следует учитывать их при проектировании ролей и их "
"взаимодействия."

msgid "Leader appointment rules"
msgstr "Правила назначения лидера"

msgid ""
"The logic behind leader election depends on the **failover mode**: disabled,"
" eventual, or stateful."
msgstr ""
"Логика выбора лидера зависит от **режима восстановления после отказа**: "
"disabled, eventual или stateful."

msgid "Disabled mode"
msgstr "Режим disabled"

msgid ""
"This is the simplest case. The leader is always the first instance in the "
"failover priority. No automatic switching is performed. When it's dead, it's"
" dead."
msgstr ""
"Это самый простой случай. Лидером всегда будет первый экземпляр в приоритете"
" восстановления после отказа. Автоматического переключения не будет. Если он"
" отключен, он отключен."

msgid "Eventual failover"
msgstr "Режим eventual"

msgid ""
"In the ``eventual`` mode, the leader isn't elected consistently. Instead, "
"every instance in the cluster thinks that the leader is the first "
"**healthy** instance in the failover priority list, while instance health is"
" determined according to the membership status (the SWIM protocol)."
msgstr ""
"В режиме ``eventual`` лидер не выбирается последовательно. Вместо этого "
"каждый экземпляр в кластере считает, что лидером является первый **рабочий**"
" экземпляр в списке приоритетов восстановления после отказа, а "
"работоспособность экземпляра определяется в соответствии со статусом "
"членства (протокол SWIM)."

msgid "The member is considered healthy if both are true:"
msgstr "Член кластера считается рабочим, если выполняются оба условия:"

msgid "It reports either ``ConfiguringRoles`` or ``RolesConfigured`` state;"
msgstr ""
"Он сообщает, что находится в статусе ``ConfiguringRoles`` или "
"``RolesConfigured``;"

msgid "Its SWIM status is either ``alive`` or ``suspect``."
msgstr "Его статус по протоколу SWIM: ``alive`` или ``suspect``."

msgid ""
"A ``suspect`` member becomes ``dead`` after the ``failover_timout`` expires."
msgstr ""
"Член кластера в статусе ``suspect`` становится недоступным (в статусе "
"``dead``) по истечении ``failover_timout``."

msgid ""
"Leader election is done as follows. Suppose there are two replica sets in "
"the cluster:"
msgstr ""
"Выбор лидера осуществляется следующим образом. Предположим, что в кластере "
"есть два набора реплик:"

msgid "a single router \"R\","
msgstr "один роутер \"R\","

msgid "two storages, \"S1\" and \"S2\"."
msgstr "два хранилища: \"S1\" и \"S2\"."

msgid ""
"Then we can say: all the three instances (R, S1, S2) agree that S1 is the "
"leader."
msgstr ""
"Тогда можно сказать, что все три экземпляра (R, S1, S2) согласны с тем, что "
"S1 является лидером."

msgid ""
"The SWIM protocol guarantees that *eventually* all instances will find a "
"common ground, but it's not guaranteed for every intermediate moment of "
"time. So we may get a conflict."
msgstr ""
"Протокол SWIM гарантирует, что *постепенно* все экземпляры договорятся, но "
"это не гарантировано в промежуточные моменты времени. Поэтому может "
"возникнуть конфликт."

msgid ""
"For example, soon after S1 goes down, R is already informed and thinks that "
"S2 is the leader, but S2 hasn't received the gossip yet and still thinks "
"he's not. This is a conflict."
msgstr ""
"Например, вскоре после того, как упал экземпляр S1, экземпляр R уже получил "
"информацию и думает, что S2 — лидер, но S2 еще не получил это сообщение и "
"еще не считает себя лидером. Вот и конфликт."

msgid ""
"Similarly, when S1 recovers and takes the leadership, S2 may be unaware of "
"that yet. So, both S1 and S2 consider themselves as leaders."
msgstr ""
"Аналогично, когда S1 вернется в работу и вновь станет лидером, S2 может не "
"сразу знать об этом. Таким образом, и S1, и S2 будут считать себя лидерами."

msgid ""
"Moreover, SWIM protocol isn't perfect and still can produce false-negative "
"gossips (announce the instance is dead when it's not)."
msgstr ""
"Более того, протокол SWIM не совершенен и все еще может передавать ложные "
"сообщения (объявлять, что экземпляр недоступен, когда это не так)."

msgid "Stateful failover"
msgstr "Режим stateful"

msgid ""
"Similarly to the eventual mode, every instance composes its own leadership "
"map, but now the map is fetched from an **external state provider** (that's "
"why this failover mode called \"stateful\"). Nowadays there are two state "
"providers supported -- ``etcd`` and ``stateboard`` (standalone Tarantool "
"instance). State provider serves as a domain-specific key-value storage "
"(simply ``replicaset_uuid -> leader_uuid``) and a locking mechanism."
msgstr ""
"Как и в режиме eventual, каждый экземпляр составляет свой собственный "
"ассоциативный массив лидеров, но теперь массив берется из **внешнего "
"поставщика состояния** (поэтому этот режим восстановления после отказа "
"называется \"с проверкой состояния\"). Сейчас поддерживаются два поставщика "
"состояния: ``etcd`` и ``stateboard`` (изолированный экземпляр Tarantool). "
"Поставщик состояния выступает в качестве хранилища пар ключ-значение (просто"
" ``replicaset_uuid -> leader_uuid``) и механизма блокировки."

msgid ""
"Changes in the leadership map are obtained from the state provider with the "
"`long polling technique "
"<https://en.wikipedia.org/wiki/Push_technology#Long_polling>`_."
msgstr ""
"Изменения массива лидеров передаются от поставщика состояния с помощью "
"`метода длинных опросов "
"<https://en.wikipedia.org/wiki/Push_technology#Long_polling>`_."

msgid ""
"All decisions are made by **the coordinator** -- the one that holds the "
"lock. The coordinator is implemented as a built-in Cartridge role. There may"
" be many instances with the coordinator role enabled, but only one of them "
"can acquire the lock at the same time. We call this coordinator the "
"\"active\" one."
msgstr ""
"Все решения принимает **координатор** — тот, кто захватил блокировку. "
"Координатор реализован как встроенная роль Cartridge. У множества "
"экземпляров может быть включена роль координатора, но только один из них "
"может захватить блокировку. Этот координатор называется \"активным\"."

msgid ""
"The lock is released automatically when the TCP connection is closed, or it "
"may expire if the coordinator becomes unresponsive (in ``stateboard`` it's "
"set by the stateboard's ``--lock_delay`` option, for ``etcd`` it's a part of"
" clusterwide configuration), so the coordinator renews the lock from time to"
" time in order to be considered alive."
msgstr ""
"Блокировка снимается автоматически при закрытии TCP-соединения, или же она "
"может отключиться, если координатор перестанет отвечать (в ``stateboard`` "
"это задается опцией ``--lock_delay``, в ``etcd`` это часть конфигурации на "
"уровне кластера), поэтому координатор время от времени обновляет блокировку,"
" чтобы считаться рабочим."

msgid ""
"The coordinator makes a decision based on the SWIM data, but the decision "
"algorithm is slightly different from that in case of eventual failover:"
msgstr ""
"Координатор принимает решение на основе SWIM-данных, но алгоритм принятия "
"решения немного отличается от алгоритма в режиме eventual:"

msgid ""
"Right after acquiring the lock from the state provider, the coordinator "
"fetches the leadership map."
msgstr ""
"Сразу после получения блокировки от поставщика состояния, координатор "
"считывает массив лидеров."

msgid ""
"If there is no leader appointed for the replica set, the coordinator "
"appoints the first leader according to the failover priority, regardless of "
"the SWIM status."
msgstr ""
"Если у набора реплик нет лидера, координатор назначает первого лидера в "
"соответствии с приоритетом восстановления после отказа, независимо от "
"статуса SWIM."

msgid ""
"If a leader becomes ``dead``, the coordinator makes a decision. A new leader"
" is the first healthy instance from the failover priority list. If an old "
"leader recovers, no leader change is made until the current leader down. "
"Changing failover priority doesn't affect this."
msgstr ""
"Если лидер находится в статусе ``dead``, координатор будет принимать "
"решение. Новым лидером станет первый рабочий экземпляр из списка приоритетов"
" восстановления после отказа. Даже если старый лидер вернется в работу, "
"лидер не сменится до тех пор, пока текущий лидер не выйдет из строя. "
"Изменение приоритета восстановления после отказа не повлияет на это."

msgid ""
"Every appointment (self-made or fetched) is immune for a while (controlled "
"by the ``IMMUNITY_TIMEOUT`` option)."
msgstr ""
"Каждое назначение экземпляра лидером (неважно, назначил он себя сам или "
"получил статус лидера) сохраняется на некоторое время (задается в параметре "
"``IMMUNITY_TIMEOUT``)."

msgid "The case: external provider outage"
msgstr "Сценарий: отключение внешнего поставщика"

msgid ""
"In this case instances do nothing: the leader remains a leader, read-only "
"instances remain read-only. If any instance restarts during an external "
"state provider outage, it composes an empty leadership map: it doesn't know "
"who actually is a leader and thinks there is none."
msgstr ""
"В этом случае экземпляры ничего не делают: лидер остается лидером, "
"экземпляры только для чтения работают только на чтение. Если один экземпляр "
"перезапустится во время отключения внешнего поставщика состояния, он "
"составит пустой массив лидеров: он не знает, кто на самом деле является "
"лидером, и считает, что его нет."

msgid "The case: coordinator outage"
msgstr "Сценарий: отключение координатора"

msgid ""
"An active coordinator may be absent in a cluster either because of a failure"
" or due to disabling the role everywhere. Just like in the previous case, "
"instances do nothing about it: they keep fetching the leadership map from "
"the state provider. But it will remain the same until a coordinator appears."
msgstr ""
"В кластере может не быть активного координатора либо из-за сбоя, либо из-за "
"повсеместного отключения роли. Как и в предыдущем случае, экземпляры ничего "
"не будут делать: они продолжают получать массив лидеров от поставщика "
"состояния. Но массив не изменится, пока не появится координатор."

msgid "Manual leader promotion"
msgstr "Продвижение лидера вручную"

msgid "It differs a lot depending on the failover mode."
msgstr ""
"Продвижение лидера вручную сильно отличается в разных режимах восстановления"
" после отказа."

msgid ""
"In the disabled and eventual modes, you can only promote a leader by "
"changing the failover priority (and applying a new clusterwide "
"configuration)."
msgstr ""
"В режимах disabled и eventual продвинуть лидера можно только путем изменения"
" приоритета восстановления после отказа (и применения новой конфигурации на "
"уровне кластера)."

msgid ""
"In the stateful mode, the failover priority doesn't make much sense (except "
"for the first appointment). Instead, you should use the promotion API (the "
"Lua :ref:`cartridge.failover_promote <cartridge.failover_promote>` or the "
"GraphQL ``mutation {cluster{failover_promote()}}``) which pushes manual "
"appointments to the state provider."
msgstr ""
"В режиме stateful приоритет восстановления после отказа не имеет особого "
"смысла (кроме первого назначения). Вместо этого следует использовать API для"
" продвижения (:ref:`cartridge.failover_promote <cartridge.failover_promote>`"
" в Lua или ``mutation {cluster{failover_promote()}}`` в GraphQL), который "
"передает данные о продвижении поставщику состояния."

msgid ""
"The stateful failover mode implies **consistent promotion**: before becoming"
" writable, each instance performs the ``wait_lsn`` operation to sync up with"
" the previous one."
msgstr ""
"Режим stateful подразумевает **последовательное продвижение**: прежде чем "
"разрешить запись, каждый экземпляр выполняет операцию ``wait_lsn`` для "
"синхронизации с предыдущим."

msgid ""
"Information about the previous leader (we call it a *vclockkeeper*) is also "
"stored on the external storage. Even when the old leader is demoted, it "
"remains the vclockkeeper until the new leader successfully awaits and "
"persists its vclock on the external storage."
msgstr ""
"Информация о предыдущем лидере (мы называем его *vclockkeeper*) также "
"хранится на внешнем хранилище. Даже после смещения старого лидера он "
"остается vclockkeeper до тех пор, пока новый лидер успешно ждет и сохраняет "
"vclock на внешнем хранилище."

msgid ""
"If replication is stuck and consistent promotion isn't possible, a user has "
"two options: to revert promotion (to re-promote the old leader) or to force "
"it inconsistently (all kinds of ``failover_promote`` API has "
"``force_inconsistency`` flag)."
msgstr ""
"Если репликация застряла и последовательное продвижение невозможно, у "
"пользователя есть два варианта: отменить продвижение (снова продвинуть "
"старого лидера) или вызвать недопустимое состояние (во всех видах API "
"``failover_promote`` есть флаг для вызова недопустимого состояния "
"``force_inconsistency``)."

msgid ""
"Consistent promotion doesn't work for replicasets with `all_rw` flag enabled"
" and for single-instance replicasets. In these two cases an instance doesn't"
" even try to query `vclockkeeper` and to perform `wait_lsn`. But the "
"coordinator still appoints a new leader if the current one dies."
msgstr ""
"Последовательное продвижение не работает для наборов реплик с установленным "
"флагом `all_rw` и для наборов реплик из одного экземпляра. В этих случаях "
"экземпляр даже не пытается запросить `vclockkeeper` и выполнить `wait_lsn`. "
"Но координатор все равно назначает нового лидера, если текущий будет "
"недоступен."

msgid "Fencing"
msgstr "Фенсинг"

msgid ""
"Neither ``eventual`` nor ``stateful`` failover mode protects a replicaset "
"from the presence of multiple leaders when the network is partitioned. But "
"fencing does. It enforces at-most-one leader policy in a replicaset."
msgstr ""
"Ни режим ``eventual``, ни режим ``stateful`` не защищают набор реплик от "
"появления нескольких лидеров, когда сеть разделена. А фенсинг (изоляция "
"узла, fencing) защищает, обеспечивая соблюдение требования о наличии не "
"более одного лидера в наборе реплик."

msgid ""
"Fencing operates as a fiber that occasionally checks connectivity with the "
"state provider and with replicas. Fencing fiber runs on vclockkeepers; it "
"starts right after consistent promotion succeeds. Replicasets which don't "
"need consistency (single-instance and ``all_rw``) don't defense, though."
msgstr ""
"Изоляция представляет собой файбер, который время от времени проверяет связь"
" с поставщиком состояния и с репликами. Файбер изоляции работает на "
"экземплярах vclockkeeper; он запускается сразу, когда подтверждается "
"последовательное продвижение. Изоляция не применяется к наборам реплик, "
"которым не нужна консистентность (с одним экземпляром и ``all_rw``)."

msgid ""
"The condition for fencing actuation is the loss of both the state provider "
"quorum and at least one replica. Otherwise, if either state provider is "
"healthy or all replicas are alive, the fencing fiber waits and doesn't "
"intervene."
msgstr ""
"Чтобы фенсинг сработал, должны выполняться такие условия: потеря кворума "
"поставщика состояния и потеря хотя бы одной реплики. В противном случае, "
"если либо поставщик состояния доступен, либо все реплики работают, файбер "
"фенсинга ждет и не вмешивается в их работу."

msgid ""
"When fencing is actuated, it generates a fake appointment locally and sets "
"the leader to ``nil``. Consequently, the instance becomes read-only. "
"Subsequent recovery is only possible when the quorum reestablishes; replica "
"connection isn't a must for recovery. Recovery is performed according to the"
" rules of consistent switchover unless some other instance has already been "
"promoted to a new leader."
msgstr ""
"Когда фенсинг срабатывает, он локально фиктивно назначает лидера на ``nil``."
" Следовательно, экземпляр будет доступен только для чтения. Возврат статуса "
"лидера возможен только при восстановлении кворума; подключение реплики не "
"будет обязательным условием, чтобы вернуть статус лидера. Экземпляр может "
"снова стать лидером в соответствии с правилами последовательного "
"переключения, если только какой-либо другой экземпляр еще не был назначен "
"новым лидером."

msgid "Failover configuration"
msgstr "Конфигурация восстановления после отказа"

msgid "These are clusterwide parameters:"
msgstr "Параметры конфигурации на уровне кластера:"

msgid "``mode``: \"disabled\" / \"eventual\" / \"stateful\"."
msgstr "``mode``: \"disabled\" / \"eventual\" / \"stateful\"."

msgid "``state_provider``: \"tarantool\" / \"etcd\"."
msgstr "``state_provider``: \"tarantool\" / \"etcd\"."

msgid ""
"``failover_timeout`` -- time (in seconds) to mark ``suspect`` members as "
"``dead`` and trigger failover (default: 20)."
msgstr ""
"``failover_timeout`` -- время (в секундах) до перевода члена кластера в "
"статусе ``suspect`` в статус ``dead`` и запуска восстановления после отказа "
"(по умолчанию: 20)."

msgid "``tarantool_params``: ``{uri = \"...\", password = \"...\"}``."
msgstr "``tarantool_params``: ``{uri = \"...\", password = \"...\"}``."

msgid ""
"``etcd2_params``: ``{endpoints = {...}, prefix = \"/\", lock_delay = 10, "
"username = \"\", password = \"\"}``."
msgstr ""
"``etcd2_params``: ``{endpoints = {...}, prefix = \"/\", lock_delay = 10, "
"username = \"\", password = \"\"}``."

msgid "``fencing_enabled``: ``true`` / ``false`` (default: false)."
msgstr "``fencing_enabled``: ``true`` / ``false`` (по умолчанию: false)."

msgid ""
"``fencing_timeout`` -- time to actuate fencing after the check fails "
"(default: 10)."
msgstr ""
"``fencing_timeout`` -- время до срабатывания фенсинга после неудачной "
"проверки (по умолчанию: 10)."

msgid "``fencing_pause`` -- the period of performing the check (default: 2)."
msgstr "``fencing_pause`` -- время на выполнение проверки (по умолчанию: 2)."

msgid ""
"It's required that ``failover_timeout > fencing_timeout >= fencing_pause``."
msgstr ""
"Должно быть так: ``failover_timeout > fencing_timeout >= fencing_pause``."

msgid "Lua API"
msgstr "Lua API"

msgid "See:"
msgstr "См.:"

msgid ":ref:`cartridge.failover_get_params <cartridge.failover_get_params>`,"
msgstr ":ref:`cartridge.failover_get_params <cartridge.failover_get_params>`,"

msgid ":ref:`cartridge.failover_set_params <cartridge.failover_set_params>`,"
msgstr ":ref:`cartridge.failover_set_params <cartridge.failover_set_params>`,"

msgid ":ref:`cartridge.failover_promote <cartridge.failover_promote>`."
msgstr ":ref:`cartridge.failover_promote <cartridge.failover_promote>`."

msgid "GraphQL API"
msgstr "GraphQL API"

msgid ""
"Use your favorite GraphQL client (e.g. `Altair "
"<https://altair.sirmuel.design/>`_) for requests introspection:"
msgstr ""
"Используйте ваш любимый клиент GraphQL (например, `Altair "
"<https://altair.sirmuel.design/>`_) для интроспекции запросов:"

msgid "``query {cluster{failover_params{}}}``,"
msgstr "``query {cluster{failover_params{}}}``,"

msgid "``mutation {cluster{failover_params(){}}}``,"
msgstr "``mutation {cluster{failover_params(){}}}``,"

msgid "``mutation {cluster{failover_promote()}}``."
msgstr "``mutation {cluster{failover_promote()}}``."

msgid "Stateboard configuration"
msgstr "Конфигурация stateboard"

msgid ""
"Like other Cartridge instances, the stateboard supports "
"``cartridge.argprase`` options:"
msgstr ""
"Как и другие экземпляры Cartridge, stateboard поддерживает параметры "
"``cartridge.argprase``:"

msgid "``listen``"
msgstr "``listen``"

msgid "``workdir``"
msgstr "``workdir``"

msgid "``password``"
msgstr "``password``"

msgid "``lock_delay``"
msgstr "``lock_delay``"

msgid ""
"Similarly to other ``argparse`` options, they can be passed via command-line"
" arguments or via environment variables, e.g.:"
msgstr ""
"Как и другие параметры ``argparse``, их можно передавать как аргументы "
"командной строки или переменные окружения, например:"

msgid ""
".rocks/bin/stateboard --workdir ./dev/stateboard --listen 4401 --password "
"qwerty"
msgstr ""
".rocks/bin/stateboard --workdir ./dev/stateboard --listen 4401 --password "
"qwerty"

msgid "Fine-tuning failover behavior"
msgstr "Настройка поведения при восстановлении после отказа"

msgid ""
"Besides failover priority and mode, there are some other private options "
"that influence failover operation:"
msgstr ""
"Помимо приоритета и режима восстановления после отказа, есть еще несколько "
"закрытых параметров, которые влияют на восстановление после отказа:"

msgid ""
"``LONGPOLL_TIMEOUT`` (``failover``) -- the long polling timeout (in seconds)"
" to fetch new appointments (default: 30);"
msgstr ""
"``LONGPOLL_TIMEOUT`` (``failover``) -- время ожидания длинного запроса (в "
"секундах) для получения данных о назначении лидера (по умолчанию: 30);"

msgid ""
"``NETBOX_CALL_TIMEOUT`` (``failover/coordinator``) -- stateboard client's "
"connection timeout (in seconds) applied to all communications (default: 1);"
msgstr ""
"``NETBOX_CALL_TIMEOUT`` (``failover/coordinator``) -- время ожидания "
"соединения клиента stateboard (в секундах), применяется ко всем соединениям "
"(по умолчанию: 1);"

msgid ""
"``RECONNECT_PERIOD`` (``coordinator``) -- time (in seconds) to reconnect to "
"the state provider if it's unreachable (default: 5);"
msgstr ""
"``RECONNECT_PERIOD`` (``coordinator``) -- время (в секундах) для повторного "
"соединения с поставщиком состояния, если он недоступен (по умолчанию: 5);"

msgid ""
"``IMMUNITY_TIMEOUT`` (``coordinator``) -- minimal amount of time (in "
"seconds) to wait before overriding an appointment (default: 15)."
msgstr ""
"``IMMUNITY_TIMEOUT`` (``coordinator``) -- минимальное время (в секундах) до "
"переназначения лидера (по умолчанию: 15)."

msgid "Configuring instances"
msgstr "Конфигурация экземпляров"

msgid ""
"Cartridge orchestrates a distributed system of Tarantool instances -- a "
"cluster. One of the core concepts is **clusterwide configuration**. Every "
"instance in a cluster stores a copy of it."
msgstr ""
"Cartridge организует кластер — распределенную систему экземпляров Tarantool."
" Одно из основных понятий — **конфигурация на уровне кластера**. Каждый "
"экземпляр в кластере хранит свою копию конфигурации."

msgid ""
"Clusterwide configuration contains options that must be identical on every "
"cluster node, such as the topology of the cluster, failover and vshard "
"configuration, authentication parameters and ACLs, and user-defined "
"configuration."
msgstr ""
"В конфигурации на уровне кластера заданы параметры, которые должны быть "
"одинаковыми на каждом узле кластера: топология кластера, конфигурация "
"восстановления после отказа и настройки vshard, параметры аутентификации и "
"ACL, а также настройки, которые задает пользователь."

msgid ""
"Clusterwide configuration doesn't provide instance-specific parameters: "
"ports, workdirs, memory settings, etc."
msgstr ""
"В конфигурации на уровне кластера не задаются параметры для конкретного "
"экземпляра: порты, рабочие каталоги, настройки памяти и т. д."

msgid "Configuration basics"
msgstr "Основы конфигурации"

msgid "Instance configuration includes two sets of parameters:"
msgstr "Конфигурация экземпляра состоит из двух наборов параметров:"

msgid ":ref:`cartridge.cfg() parameters <cartridge.argparse.cluster_opts>`;"
msgstr ":ref:`параметры cartridge.cfg() <cartridge.argparse.cluster_opts>`;"

msgid ":ref:`box.cfg() parameters <cartridge.argparse.box_opts>`."
msgstr ":ref:`параметры box.cfg() <cartridge.argparse.box_opts>`."

msgid "You can set any of these parameters in:"
msgstr "Задать эти параметры можно:"

msgid "Command line arguments."
msgstr "В аргументах в командной строке."

msgid "Environment variables."
msgstr "В переменных окружения."

msgid "YAML configuration file."
msgstr "В конфигурационном файле формата YAML."

msgid "``init.lua`` file."
msgstr "В файле ``init.lua``."

msgid ""
"The order here indicates the priority: command-line arguments override "
"environment variables, and so forth."
msgstr ""
"Вышеуказанный порядок определяет приоритет: аргументы в командной строке "
"замещают переменные окружения и т.д."

msgid ""
"No matter how you :ref:`start the instances <cartridge-run>`, you need to "
"set the following ``cartridge.cfg()`` parameters for each instance:"
msgstr ""
"Независимо от того, как вы :ref:`запускаете экземпляры <cartridge-run>`, "
"необходимо задать следующие параметры ``cartridge.cfg()`` для каждого "
"экземпляра:"

msgid ""
"``advertise_uri`` -- either ``<HOST>:<PORT>``, or ``<HOST>:``, or "
"``<PORT>``. Used by other instances to connect to the current one. **DO "
"NOT** specify ``0.0.0.0`` -- this must be an external IP address, not a "
"socket bind."
msgstr ""
"``advertise_uri`` -- либо ``<ХОСТ>:<ПОРТ>``, либо ``<ХОСТ>:``, либо "
"``<ПОРТ>``. Используется другими экземплярами для подключения. **НЕ** "
"указывайте ``0.0.0.0`` -- это должен быть внешний IP-адрес, а не привязка "
"сокета."

msgid ""
"``http_port`` -- port to open administrative web interface and API on. "
"Defaults to ``8081``. To disable it, specify ``\"http_enabled\": False``."
msgstr ""
"``http_port`` -- порт, который используется, чтобы открывать "
"административный веб-интерфейс и API. По умолчанию: ``8081``. Чтобы "
"отключить, укажите ``\"http_enabled\": False``."

msgid ""
"``workdir`` -- a directory where all data will be stored: snapshots, wal "
"logs, and ``cartridge`` configuration file. Defaults to ``.``."
msgstr ""
"``workdir`` — каталог, где хранятся все данные: файлы снимка, журналы "
"упреждающей записи и конфигурационный файл ``cartridge``. По умолчанию: "
"``.``."

msgid ""
"If you start instances using ``cartridge`` CLI or ``systemctl``, save the "
"configuration as a YAML file, for example:"
msgstr ""
"Если вы запустите экземпляры, используя интерфейс командной строки "
"``cartridge`` или ``systemctl``, сохраните конфигурацию в формате YAML, "
"например:"

msgid ""
"my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": 8080}\n"
"my_app.storage_A: {\"advertise_uri\": \"localhost:3302\", \"http_enabled\": False}\n"
"my_app.storage_B: {\"advertise_uri\": \"localhost:3303\", \"http_enabled\": False}"
msgstr ""
"my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": 8080}\n"
"my_app.storage_A: {\"advertise_uri\": \"localhost:3302\", \"http_enabled\": False}\n"
"my_app.storage_B: {\"advertise_uri\": \"localhost:3303\", \"http_enabled\": False}"

msgid ""
"With ``cartridge`` CLI, you can pass the path to this file as the ``--cfg`` "
"command-line argument to the ``cartridge start`` command -- or specify the "
"path in ``cartridge`` CLI configuration (in ``./.cartridge.yml`` or "
"``~/.cartridge.yml``):"
msgstr ""
"С помощью интерфейса командной строки ``cartridge`` вы можете передать путь "
"к этому файлу в качестве аргумента командной строки ``--cfg`` для команды "
"``cartridge start`` -- или же указать путь в конфигурации ``cartridge`` (в "
"``./.cartridge.yml`` или ``~/.cartridge.yml``):"

msgid ""
"cfg: cartridge.yml\n"
"run_dir: tmp/run\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""
"cfg: cartridge.yml\n"
"run_dir: tmp/run\n"
"apps_path: /usr/local/share/tarantool"

msgid ""
"With ``systemctl``, save the YAML file to ``/etc/tarantool/conf.d/`` (the "
"default ``systemd`` path) or to a location set in the ``TARANTOOL_CFG`` "
"environment variable."
msgstr ""
"С помощью ``systemctl`` сохраните файл в формате YAML в "
"``/etc/tarantool/conf.d/`` (по умолчанию путь ``systemd``) или в место, "
"указанное в переменной окружения ``TARANTOOL_CFG``."

msgid ""
"If you start instances with ``tarantool init.lua``, you need to pass other "
"configuration options as command-line parameters and environment variables, "
"for example:"
msgstr ""
"Если вы запускаете экземпляры с помощью ``tarantool init.lua``, необходимо "
"также передать другие параметры конфигурации в качестве параметров командной"
" строки и переменных окружения, например:"

msgid ""
"$ tarantool init.lua --alias router --memtx-memory 100 --workdir "
"\"~/db/3301\" --advertise_uri \"localhost:3301\" --http_port \"8080\""
msgstr ""
"$ tarantool init.lua --alias router --memtx-memory 100 --workdir "
"\"~/db/3301\" --advertise_uri \"localhost:3301\" --http_port \"8080\""

msgid "Internal representation of clusterwide configuration"
msgstr "Внутреннее представление конфигурации на уровне кластера"

msgid ""
"In the file system, clusterwide configuration is represented by a **file "
"tree**. Inside ``workdir`` of any configured instance you can find the "
"following directory:"
msgstr ""
"В файловой системе конфигурация на уровне кластера показана в виде **дерева "
"файлов**. В ``workdir`` любого сконфигурированного экземпляра можно найти "
"каталог:"

msgid ""
"config/\n"
"├── auth.yml\n"
"├── topology.yml\n"
"└── vshard_groups.yml"
msgstr ""
"config/\n"
"├── auth.yml\n"
"├── topology.yml\n"
"└── vshard_groups.yml"

msgid ""
"This is the clusterwide configuration with three default **config sections**"
" -- ``auth``, ``topology``, and ``vshard_groups``."
msgstr ""
"Это конфигурация на уровне кластера с тремя **разделами config** по "
"умолчанию: ``auth``, ``topology`` и ``vshard_groups``."

msgid ""
"Due to historical reasons clusterwide configuration has two appearances:"
msgstr "Исторически сложилось так, что есть два вида кластерной конфигурация:"

msgid "old-style single-file ``config.yml`` with all sections combined, and"
msgstr ""
"один файл ``config.yml`` старого образца, в котором находятся все разделы, и"

msgid "modern multi-file representation mentioned above."
msgstr "представленное выше современное представление из нескольких файлов."

msgid ""
"Before cartridge v2.0 it used to look as follows, and this representation is"
" still used in HTTP API and ``luatest`` helpers."
msgstr ""
"Так конфигурация выглядела до версии Cartridge 2.0 и до сих используется в "
"таком виде в HTTP API и вспомогательных утилитах ``luatest``:"

msgid ""
"# config.yml\n"
"---\n"
"auth: {...}\n"
"topology: {...}\n"
"vshard_groups: {...}\n"
"..."
msgstr ""
"# config.yml\n"
"---\n"
"auth: {...}\n"
"topology: {...}\n"
"vshard_groups: {...}\n"
"..."

msgid ""
"Beyond these essential sections, clusterwide configuration may be used for "
"storing some other role-specific data. Clusterwide configuration supports "
"YAML as well as plain text sections. It can also be organized in nested "
"subdirectories."
msgstr ""
"Помимо основных разделов, в конфигурации на уровне кластера можно хранить "
"некоторые другие данные для конкретной роли. Конфигурация на уровне кластера"
" поддерживает YAML, а также обычные текстовые разделы. Используя вложенные "
"подкаталоги, можно упорядочить разделы."

msgid ""
"In Lua it's represented by the ``ClusterwideConfig`` object (a table with "
"metamethods). Refer to the ``cartridge.clusterwide-config`` module "
"documentation for more details."
msgstr ""
"В Lua конфигурация представлена в виде объекта ``ClusterwideConfig`` "
"(таблица с метаметодами). Для получения более подробной информации "
"обратитесь к документации модуля ``cartridge.clusterwide-config``."

msgid "Two-phase commit"
msgstr "Двухфазная фиксация транзакций"

msgid ""
"Cartridge manages clusterwide configuration to be identical everywhere using"
" the two-phase commit algorithm implemented in the ``cartridge.twophase`` "
"module. Changes in clusterwide configuration imply applying it on every "
"instance in the cluster."
msgstr ""
"Конфигурация на уровне кластера в Cartridge одинакова для всех экземпляров, "
"что достигается использованием двухфазного алгоритма фиксации транзакций, "
"который реализован в модуле ``cartridge.twophase``. Изменения в конфигурации"
" на уровне кластера подразумевают применение этих изменений к каждому "
"экземпляру в кластере."

msgid ""
"Almost every change in cluster parameters triggers a two-phase commit: "
"joining/expelling a server, editing replica set roles, managing users, "
"setting failover and vshard configuration."
msgstr ""
"Почти каждое изменение параметров кластера вызывает двухфазную фиксацию: "
"присоединение/исключение сервера, редактирование ролей наборов реплик, "
"управление пользователями, настройка восстановления после отказа и "
"конфигурация vshard."

msgid ""
"Two-phase commit requires all instances to be alive and healthy, otherwise "
"it returns an error."
msgstr ""
"Для двухфазной фиксации необходимо, чтобы все экземпляры были исправными и в"
" статусе alive, иначе вернется ошибка."

msgid ""
"For more details, please, refer to the "
"``cartridge.config_patch_clusterwide`` API reference."
msgstr ""
"Для получения более подробной информации, обратитесь к справочнику по API "
"``cartridge.config_patch_clusterwide``."

msgid "Managing role-specific data"
msgstr "Управление данными по конкретной роли"

msgid ""
"Beside system sections, clusterwide configuration may be used for storing "
"some other **role-specific data**. It supports YAML as well as plain text "
"sections. And it can also be organized in nested subdirectories."
msgstr ""
"Помимо системных разделов, в конфигурации на уровне кластера можно хранить "
"некоторые другие **данные для конкретной роли**. Конфигурация поддерживает "
"YAML, а также обычные текстовые разделы. Используя вложенные подкаталоги, "
"можно упорядочить разделы."

msgid ""
"Role-specific sections are used by some third-party roles, i.e. `sharded-"
"queue <https://github.com/tarantool/sharded-queue>`_ and `cartridge-"
"extensions <https://github.com/tarantool/cartridge-extensions>`_."
msgstr ""
"Некоторые сторонние роли (например, `sharded-queue "
"<https://github.com/tarantool/sharded-queue>`_ и `cartridge-extensions "
"<https://github.com/tarantool/cartridge-extensions>`_ также могут "
"использовать такие разделы для конкретных ролей."

msgid ""
"A user can influence clusterwide configuration in various ways. You can "
"alter configuration using Lua, HTTP or GraphQL API. Also there are `luatest "
"<https://github.com/tarantool/luatest>`_ helpers available."
msgstr ""
"Конфигурацию на уровне кластера можно изменять различными способами. Вносить"
" изменения можно с помощью API для Lua, HTTP или GraphQL. Кроме того, есть "
"вспомогательные утилиты `luatest <https://github.com/tarantool/luatest>`_."

msgid "HTTP API"
msgstr "HTTP API"

msgid ""
"It works with old-style single-file representation only. It's useful when "
"there are only few sections needed."
msgstr ""
"Этот API работает только с одним файлом конфигурации старого образца, что "
"полезно, когда нужны всего несколько разделов."

msgid "Example:"
msgstr "Пример:"

msgid ""
"cat > config.yml << CONFIG\n"
"---\n"
"custom_section: {}\n"
"...\n"
"CONFIG"
msgstr ""
"cat > config.yml << CONFIG\n"
"---\n"
"custom_section: {}\n"
"...\n"
"CONFIG"

msgid "Upload new config:"
msgstr "Загрузка новой конфигурации:"

msgid "curl -v \"localhost:8081/admin/config\" -X PUT --data-binary @config.yml"
msgstr "curl -v \"localhost:8081/admin/config\" -X PUT --data-binary @config.yml"

msgid "Download it:"
msgstr "Скачивание конфигурации:"

msgid "curl -v \"localhost:8081/admin/config\" -o config.yml"
msgstr "curl -v \"localhost:8081/admin/config\" -o config.yml"

msgid ""
"It's suitable for role-specific sections only. System sections "
"(``topology``, ``auth``, ``vshard_groups``, ``users_acl``) can be neither "
"uploaded nor downloaded."
msgstr ""
"Скачивать можно только разделы для ролей. Системные разделы (``topology``, "
"``auth``, ``vshard_groups``, ``users_acl``) нельзя ни загружать, ни "
"скачивать."

msgid ""
"If authorization is enabled, use the ``curl`` option ``--user "
"username:password``."
msgstr ""
"Если включена авторизация, следует использовать параметр ``curl``: ``--user "
"username:password``."

msgid ""
"GraphQL API, by contrast, is only suitable for managing plain-text sections "
"in the modern multi-file appearance. It is mostly used by WebUI, but "
"sometimes it's also helpful in tests:"
msgstr ""
"В свою очередь, GraphQL API подходит только для управления раздела с простым"
" текстом в современном виде конфигурации с множеством файлов. В основном "
"этот API используется в веб-интерфейсе, но иногда и в тестах:"

msgid ""
"g.cluster.main_server:graphql({query = [[\n"
"    mutation($sections: [ConfigSectionInput!]) {\n"
"        cluster {\n"
"            config(sections: $sections) {\n"
"                filename\n"
"                content\n"
"            }\n"
"        }\n"
"    }]],\n"
"    variables = {sections = {\n"
"      {\n"
"        filename = 'custom_section.yml',\n"
"        content = '---\\n{}\\n...',\n"
"      }\n"
"    }}\n"
"})"
msgstr ""
"g.cluster.main_server:graphql({query = [[\n"
"    mutation($sections: [ConfigSectionInput!]) {\n"
"        cluster {\n"
"            config(sections: $sections) {\n"
"                filename\n"
"                content\n"
"            }\n"
"        }\n"
"    }]],\n"
"    variables = {sections = {\n"
"      {\n"
"        filename = 'custom_section.yml',\n"
"        content = '---\\n{}\\n...',\n"
"      }\n"
"    }}\n"
"})"

msgid ""
"Unlike HTTP API, GraphQL affects only the sections mentioned in the query. "
"All the other sections remain unchanged."
msgstr ""
"В отличие от HTTP API, GraphQL API изменяет только те разделы, которые "
"указаны в запросе. Остальные разделы остаются без изменений."

msgid ""
"Similarly to HTTP API, GraphQL ``cluster {config}`` query isn't suitable for"
" managing system sections."
msgstr ""
"Как и HTTP API, запрос GraphQL ``cluster {config}`` не подойдет для "
"управления системными разделами."

msgid ""
"It's not the most convenient way to configure third-party role, but it may "
"be useful for role development. Please, refer to the corresponding API "
"reference:"
msgstr ""
"Это не самый удобный способ настройки сторонних ролей, но для разработки "
"ролей он может быть полезен. Обратите внимание на соответствующий справочник"
" по API:"

msgid "``cartridge.config_patch_clusterwide``"
msgstr "``cartridge.config_patch_clusterwide``"

msgid "``cartridge.config_get_deepcopy``"
msgstr "``cartridge.config_get_deepcopy``"

msgid "``cartridge.config_get_readonly``"
msgstr "``cartridge.config_get_readonly``"

msgid "Example (from ``sharded-queue``, simplified):"
msgstr "Упрощенный пример (из ``sharded-queue``):"

msgid ""
"function create_tube(tube_name, tube_opts)\n"
"    local tubes = cartridge.config_get_deepcopy('tubes') or {}\n"
"    tubes[tube_name] = tube_opts or {}\n"
"\n"
"    return cartridge.config_patch_clusterwide({tubes = tubes})\n"
"end\n"
"\n"
"local function validate_config(conf)\n"
"    local tubes = conf.tubes or {}\n"
"    for tube_name, tube_opts in pairs(tubes) do\n"
"        -- validate tube_opts\n"
"    end\n"
"    return true\n"
"end\n"
"\n"
"local function apply_config(conf, opts)\n"
"    if opts.is_master then\n"
"        local tubes = cfg.tubes or {}\n"
"        -- create tubes according to the configuration\n"
"    end\n"
"    return true\n"
"end"
msgstr ""
"function create_tube(tube_name, tube_opts)\n"
"    local tubes = cartridge.config_get_deepcopy('tubes') or {}\n"
"    tubes[tube_name] = tube_opts or {}\n"
"\n"
"    return cartridge.config_patch_clusterwide({tubes = tubes})\n"
"end\n"
"\n"
"local function validate_config(conf)\n"
"    local tubes = conf.tubes or {}\n"
"    for tube_name, tube_opts in pairs(tubes) do\n"
"        -- валидируйте tube_opts\n"
"    end\n"
"    return true\n"
"end\n"
"\n"
"local function apply_config(conf, opts)\n"
"    if opts.is_master then\n"
"        local tubes = cfg.tubes or {}\n"
"        -- создайте tubes в соответствии с конфигурацией\n"
"    end\n"
"    return true\n"
"end"

msgid "Luatest helpers"
msgstr "Вспомогательные утилиты Luatest"

msgid "Cartridge test helpers provide methods for configuration management:"
msgstr ""
"В Cartridge есть вспомогательные утилиты для тестирования, которые "
"предлагают методы управления настройками:"

msgid "``cartridge.test-helpers.cluster:upload_config``,"
msgstr "``cartridge.test-helpers.cluster:upload_config``,"

msgid "``cartridge.test-helpers.cluster:download_config``."
msgstr "``cartridge.test-helpers.cluster:download_config``."

msgid "Internally they wrap the HTTP API."
msgstr "Они реализованы путем оборачивания HTTP API."

msgid ""
"g.before_all(function()\n"
"    g.cluster = helpers.Cluster.new(...)\n"
"    g.cluster:upload_config({some_section = 'some_value'})\n"
"    t.assert_equals(\n"
"        g.cluster:download_config(),\n"
"        {some_section = 'some_value'}\n"
"    )\n"
"end)"
msgstr ""
"g.before_all(function()\n"
"    g.cluster = helpers.Cluster.new(...)\n"
"    g.cluster:upload_config({some_section = 'some_value'})\n"
"    t.assert_equals(\n"
"        g.cluster:download_config(),\n"
"        {some_section = 'some_value'}\n"
"    )\n"
"end)"

msgid "Deploying an application"
msgstr "Развертывание приложения"

msgid ""
"After you've developed your Tarantool Cartridge application locally, you can"
" deploy it to a test or production environment."
msgstr ""
"После того, как вы локально разработали приложение на Tarantool Cartridge, "
"вы можете развернуть его в тестовой или производственной среде."

msgid "Deploying includes:"
msgstr "Развертывание включает в себя:"

msgid "packing the application into a specific distribution format"
msgstr "упаковку приложения в специальный формат дистрибутива;"

msgid "installing it to the target server"
msgstr "установку его на целевой сервер;"

msgid "running the application."
msgstr "запуск приложения."

msgid "You have four options to deploy a Tarantool Cartridge application:"
msgstr ""
"Развернуть приложение на Tarantool Cartridge можно четырьмя способами:"

msgid "as an :ref:`RPM <cartridge-deploy-rpm>` package (for production)"
msgstr ""
"в виде :ref:`RPM <cartridge-deploy-rpm>`-пакета (для производственной "
"среды);"

msgid "as a :ref:`DEB <cartridge-deploy-deb>` package (for production)"
msgstr ""
"в виде :ref:`DEB <cartridge-deploy-deb>`-пакета (для производственной "
"среды);"

msgid ""
"as a :ref:`tar+gz <cartridge-deploy-tgz>` archive (for testing or as a "
"workaround for production if root access is unavailable)"
msgstr ""
"в виде архива :ref:`tar.gz <cartridge-deploy-tgz>` (для тестирования или как обходной путь\n"
"для производственной среды, если отсутствует доступ уровня root);"

msgid ":ref:`from sources <cartridge-deploy-rock>` (for local testing only)."
msgstr ""
":ref:`из исходных файлов <cartridge-deploy-rock>` (только для локального "
"тестирования)."

msgid "Deploying as an RPM or DEB package"
msgstr "Развертывание приложения в виде RPM- или DEB-пакета"

msgid ""
"The choice between DEB and RPM depends on the package manager of the target "
"OS. DEB is used for Debian Linux and its derivatives, and RPM—for "
"CentOS/RHEL and other RPM-based `Linux distributions "
"<https://en.wikipedia.org/wiki/List_of_Linux_distributions>`_."
msgstr ""
"Выбор между DEB- и RPM-пакетами зависит от пакетного менеджера целевой ОС. "
"DEB используется для Debian Linux и его производных, а RPM — для CentOS/RHEL"
" и других основанных на RPM `дистрибутивов Linux "
"<https://en.wikipedia.org/wiki/List_of_Linux_distributions>`_."

msgid ""
"If you use the `Tarantool Community Edition "
"<https://www.tarantool.io/en/developers/>`_ while packing the application, "
"the package will have a dependency on this version of Tarantool."
msgstr ""
"Если при упаковке приложения вы используете `Tarantool Community Edition "
"<https://www.tarantool.io/en/developers/>`_, то эта версия Tarantool будет "
"среди зависимостей приложения."

msgid ""
"In this case, on a target server, add the Tarantool repository for the "
"version equal or later than the one used for packing the application. This "
"lets a package manager install the dependency correctly. See details for "
"your OS on the `Download <https://www.tarantool.io/en/download/>`_ page."
msgstr ""
"В этом случае на целевом сервере добавьте репозиторий Tarantool с той же "
"версией, что использовалась при упаковке приложения, или более новой. Это "
"позволит пакетному менеджеру корректно установить зависимости. Чтобы "
"получить подробную информацию для вашей ОС, см. `страницу загрузки "
"<https://www.tarantool.io/en/download/>`_."

msgid ""
"For a production environment, it is recommended to use the ``systemd`` "
"subsystem for managing the application instances and accessing log entries."
msgstr ""
"В производственной среде для управления экземплярами приложения и доступа к "
"записям журнала рекомендуется использовать подсистему ``systemd``."

msgid "To deploy your Tarantool Cartridge application:"
msgstr ""
"Чтобы развернуть приложение на Tarantool Cartridge, выполните следующие "
"шаги:"

msgid "Pack the application into a deliverable:"
msgstr "Упакуйте приложения в распространяемый пакет:"

msgid ""
"$ cartridge pack rpm [APP_PATH] [--use-docker]\n"
"$ # -- OR --\n"
"$ cartridge pack deb [APP_PATH] [--use-docker]"
msgstr ""
"$ cartridge pack rpm [APP_PATH] [--use-docker]\n"
"$ # -- ИЛИ --\n"
"$ cartridge pack deb [APP_PATH] [--use-docker]"

msgid "where"
msgstr "где"

msgid ""
"``APP_PATH``—a path to the application directory. Defaults to ``.`` (the "
"current directory)."
msgstr ""
"``APP_PATH`` — путь к директории приложения. Значение по умолчанию — ``.`` "
"(текущая директория)."

msgid ""
"``--use-docker``---the flag to use if packing the application on a different"
" Linux distribution or on macOS. It ensures the resulting artifact contains "
"the Linux compatible external modules and executables."
msgstr ""
"``--use-docker`` — флаг, который нужно использовать при упаковке приложения "
"на различных листрибутивах Linux или на macOS. Он гарантирует что "
"результирующий артефакт содержит совместимые с Linux модули и исполняемые "
"файлы."

msgid ""
"This creates an RPM or DEB package with the following naming: "
"``<APP_NAME>-<VERSION>.{rpm,deb}``. For example, "
"``./my_app-0.1.0-1-g8c57dcb.rpm`` or ``./my_app-0.1.0-1-g8c57dcb.deb``. For "
"more details on the format and usage of the ``cartridge pack`` command, "
"refer to the `command description "
"<https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_cli/#packing-"
"an-application>`_."
msgstr ""
"В результате создается RPM- или DEB-пакет со следующим способом именования: "
"``<APP_NAME>-<VERSION>.{rpm,deb}``. Например, "
"``./my_app-0.1.0-1-g8c57dcb.rpm`` или ``./my_app-0.1.0-1-g8c57dcb.deb``. "
"Чтобы больше узнать о формате и использовании команды ``cartridge pack``, "
"прочитайте `ее описание "
"<https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_cli/#packing-"
"an-application>`_."

msgid "Upload the generated package to a target server."
msgstr "Загрузите сгенерированный пакет на целевой сервер."

msgid "Install the application:"
msgstr "Установите приложение:"

msgid ""
"$ sudo yum install <APP_NAME>-<VERSION>.rpm\n"
"$ # -- OR --\n"
"$ sudo dpkg -i <APP_NAME>-<VERSION>.deb"
msgstr ""
"$ sudo yum install <APP_NAME>-<VERSION>.rpm\n"
"$ # -- ИЛИ --\n"
"$ sudo dpkg -i <APP_NAME>-<VERSION>.deb"

msgid "Configure the application instances."
msgstr "Настройте экземпляры приложения."

msgid ""
"The configuration is stored in the ``/etc/tarantool/conf.d/instances.yml`` "
"file. Create the file and specify parameters of the instances. For details, "
"refer to :ref:`cartridge-config`."
msgstr ""
"Конфигурация хранится в файле ``/etc/tarantool/conf.d/instances.yml``. "
"Создайте этот файл и укажите параметры экземпляров. Подробности читайте в "
":ref:`cartridge-config`."

msgid ""
"my_app:\n"
"  cluster_cookie: secret-cookie\n"
"\n"
"my_app.router:\n"
"  advertise_uri: localhost:3301\n"
"  http_port: 8081\n"
"\n"
"my_app.storage-master:\n"
"  advertise_uri: localhost:3302\n"
"  http_port: 8082\n"
"\n"
"my_app.storage-replica:\n"
"  advertise_uri: localhost:3303\n"
"  http_port: 8083"
msgstr ""
"my_app:\n"
"  cluster_cookie: secret-cookie\n"
"\n"
"my_app.router:\n"
"  advertise_uri: localhost:3301\n"
"  http_port: 8081\n"
"\n"
"my_app.storage-master:\n"
"  advertise_uri: localhost:3302\n"
"  http_port: 8082\n"
"\n"
"my_app.storage-replica:\n"
"  advertise_uri: localhost:3303\n"
"  http_port: 8083"

msgid ""
"Do not specify working directories of the instances in this configuration. "
"They are defined via the ``TARANTOOL_WORKDIR`` environmental variable in the"
" instantiated unit file (``/etc/systemd/system/<APP_NAME>@.service``)."
msgstr ""
"Не указывайте среди этих настроек рабочие директории экземпляров. "
"Используйте для этого переменную окружения ``TARANTOOL_WORKDIR`` в юнит-"
"файле для каждого из соответствующих экземпляров "
"(``/etc/systemd/system/<APP_NAME>@.service``)."

msgid "Start the application instances by using ``systemctl``."
msgstr "Запустите экземпляры приложения с помощью команды ``systemctl``."

msgid "For more details, see :ref:`cartridge-run-systemctl`."
msgstr "Подробности читайте на странице :ref:`cartridge-run-systemctl`."

msgid ""
"$ sudo systemctl start my_app@router\n"
"$ sudo systemctl start my_app@storage-master\n"
"$ sudo systemctl start my_app@storage-replica"
msgstr ""
"$ sudo systemctl start my_app@router\n"
"$ sudo systemctl start my_app@storage-master\n"
"$ sudo systemctl start my_app@storage-replica"

msgid ""
"In case of a cluster-aware application, proceed to :ref:`deploying the "
"cluster <cartridge-deployment>`."
msgstr ""
"Если ваше приложение поддерживает кластеры, переходите к :ref:`развертыванию"
" кластера <cartridge-deployment>`."

msgid ""
"If you're migrating your application from local test environment to "
"production, you can re-use your test configuration at this step:"
msgstr ""
"При переносе приложения из локальной среды тестирования на рабочий сервер на"
" этом этапе можно переиспользовать тестовые настройки:"

msgid ""
"In the cluster web interface of the test environment, click **Configuration "
"files > Download** to save the test configuration."
msgstr ""
"В веб-интерфейсе кластера тестовой среды нажмите **Configuration files > "
"Download**, чтобы сохранить тестовую конфигурацию."

msgid ""
"In the cluster web interface of the production environment, click "
"**Configuration files > Upload** to upload the saved configuration."
msgstr ""
"В веб-интерфейсе кластера на рабочем сервере нажмите **Configuration files >"
" Upload**, чтобы загрузить сохраненную конфигурацию."

msgid ""
"You can further manage the running instances by using the standard "
"operations of the ``systemd`` utilities:"
msgstr ""
"Вы можете затем управлять работающими экземплярами, используя стандартные "
"операции утилит ``systemd``:"

msgid ""
"``systemctl`` for stopping, re-starting, checking the status of the "
"instances, and so on"
msgstr ""
"``systemctl`` — для остановки, перезапуска, проверки статуса экземпляров и "
"т. д.;"

msgid "``journalctl`` for collecting logs of the instances."
msgstr "``journalctl`` для работы с журналами экземпляров."

msgid "Entities created during installation"
msgstr "Сущности, создаваемые во время установки"

msgid ""
"During the installation of a Tarantool Cartridge application, the following "
"entities are additionally created:"
msgstr ""
"Во время установки приложения на Tarantool Cartridge дополнительно создаются"
" следующие сущности:"

msgid "The ``tarantool`` user group."
msgstr "Группа (user group) ``tarantool``."

msgid ""
"The ``tarantool`` system user. All the application instances start under "
"this user. The ``tarantool`` user group is the main group for the "
"``tarantool`` user. The user is created with the option ``-s "
"/sbin/nologin``."
msgstr ""
"Системный пользователь ``tarantool``. Все экземпляры приложения запускаются "
"от имени этого пользователя. Группа ``tarantool`` — основная группа "
"пользователя ``tarantool``. Пользователь создается с параметром ``-s "
"/sbin/nologin``."

msgid ""
"Directories and files listed in the table below (``<APP_NAME>`` is the "
"application name, ``%i`` is the instance name):"
msgstr ""
"Директории и файлы, перечисленные в таблице ниже (<APP_NAME> — имя "
"приложения, ``%i`` — имя экземпляра):"

msgid "Path"
msgstr "Путь"

msgid "Access Rights"
msgstr "Права доступа"

msgid "Owner:Group"
msgstr "Владелец:Группа"

msgid "Description"
msgstr "Описание"

msgid "``/etc/systemd/system/<APP_NAME>.service``"
msgstr "``/etc/systemd/system/<APP_NAME>.service``"

msgid "``-rw-r--r--``"
msgstr "``-rw-r--r--``"

msgid "``root:root``"
msgstr "``root:root``"

msgid "systemd unit file for the <APP_NAME> service"
msgstr "юнит-файл systemd для сервиса <APP_NAME>"

msgid "``/etc/systemd/system/<APP_NAME>@.service``"
msgstr "``/etc/systemd/system/<APP_NAME>@.service``"

msgid "systemd instantiated unit file for the <APP_NAME> service"
msgstr ""
"юнит-файл systemd, позволяющий запускать экземпляры сервиса <APP_NAME>"

msgid "``/usr/share/tarantool/<APP_NAME>/``"
msgstr "``/usr/share/tarantool/<APP_NAME>/``"

msgid "``drwxr-xr-x``"
msgstr "``drwxr-xr-x``"

msgid "Directory. Contains executable files of the application."
msgstr "Директория. Содержит исполняемые файлы приложения."

msgid "``/etc/tarantool/conf.d/``"
msgstr "``/etc/tarantool/conf.d/``"

msgid ""
"Directory for YAML files with the configuration of the application "
"instances, such as ``instances.yml``."
msgstr ""
"Директория для YAML-файлов с конфигурацией экземпляров приложений, таких как"
" ``instances.yml``."

msgid "``/var/lib/tarantool/<APP_NAME>.%i/``"
msgstr "``/var/lib/tarantool/<APP_NAME>.%i/``"

msgid "``tarantool:tarantool``"
msgstr "``tarantool:tarantool``"

msgid ""
"Working directories of the application instances. Each directory contains "
"the instance data, namely, the WAL and snapshot files, and also the "
"application configuration YAML files."
msgstr ""
"Рабочие директории экземпляров приложения. Каждая директория содержит данные"
" экземпляра, а именно: файлы WAL и файлы-снимки, а также файлы конфигурации "
"приложения в формате YAML."

msgid "``/var/run/tarantool/``"
msgstr "``/var/run/tarantool/``"

msgid ""
"Directory. Contains the following files for each instance: "
"``<APP_NAME>.%i.pid`` and ``<APP_NAME>.%i.control``."
msgstr ""
"Директория. Содержит следующие файлы для каждого экземпляра: "
"``<APP_NAME>.%i.pid`` и ``<APP_NAME>.%i.control``."

msgid "``/var/run/tarantool/<APP_NAME>.%i.pid``"
msgstr "``/var/run/tarantool/<APP_NAME>.%i.pid``"

msgid "Contains the process ID."
msgstr "Содержит ID процесса."

msgid "``/var/run/tarantool/<APP_NAME>.%i.control``"
msgstr "``/var/run/tarantool/<APP_NAME>.%i.control``"

msgid "``srwxr-xr-x``"
msgstr "``srwxr-xr-x``"

msgid ""
"Unix socket to connect to the instance via the `tarantoolctl "
"<https://www.tarantool.io/en/doc/latest/reference/tarantoolctl/>`_ utility."
msgstr ""
"Unix-сокет для подключения к экземпляру с помощью утилиты `tarantoolctl "
"<https://www.tarantool.io/en/doc/latest/reference/tarantoolctl/>`_."

msgid "Deploying as a tar+gz archive"
msgstr "Развертывание архива tar+gz"

msgid "Pack the application into a distributable:"
msgstr "Упакуйте файлы приложения в распространяемый пакет:"

msgid "$ cartridge pack tgz APP_NAME"
msgstr "$ cartridge pack tgz APP_NAME"

msgid "This will create a tar+gz archive (e.g. ``./my_app-0.1.0-1.tgz``)."
msgstr "Будет создан архив tar+gz (например, ``./my_app-0.1.0-1.tgz``)."

msgid ""
"Upload the archive to target servers, with ``tarantool`` and (optionally) "
":ref:`cartridge-cli <cartridge-install-dev>` installed."
msgstr ""
"Загрузите архив на серверы, на которых установлены ``tarantool`` и "
"(необязательно) :ref:`cartridge-cli <cartridge-install-dev>`."

msgid "Extract the archive:"
msgstr "Распакуйте архив:"

msgid "$ tar -xzvf APP_NAME-VERSION.tgz"
msgstr "$ tar -xzvf APP_NAME-VERSION.tgz"

msgid ""
"Configure the instance(s). Create a file called "
"``/etc/tarantool/conf.d/instances.yml``. For example:"
msgstr ""
"Настройте экземпляр(ы). Создайте файл под названием "
"``/etc/tarantool/conf.d/instances.yml``. Например:"

msgid ""
"my_app:\n"
" cluster_cookie: secret-cookie\n"
"\n"
"my_app.instance-1:\n"
" http_port: 8081\n"
" advertise_uri: localhost:3301\n"
"\n"
"my_app.instance-2:\n"
" http_port: 8082\n"
" advertise_uri: localhost:3302"
msgstr ""
"my_app:\n"
" cluster_cookie: secret-cookie\n"
"\n"
"my_app.instance-1:\n"
" http_port: 8081\n"
" advertise_uri: localhost:3301\n"
"\n"
"my_app.instance-2:\n"
" http_port: 8082\n"
" advertise_uri: localhost:3302"

msgid "See details :ref:`here <cartridge-config>`."
msgstr "См. описание :ref:`здесь <cartridge-config>`."

msgid "Start Tarantool instance(s). You can do it using:"
msgstr "Запустите экземпляры Tarantool. Это можно сделать, используя:"

msgid ":ref:`tarantool <cartridge-run-tarantool>`, for example:"
msgstr ":ref:`tarantoolctl <cartridge-run-tarantool>`, например:"

msgid "$ tarantool init.lua # starts a single instance"
msgstr "$ tarantool init.lua # запускает один экземпляр"

msgid "or :ref:`cartridge <cartridge-run-cartridge>`, for example:"
msgstr "или :ref:`cartridge <cartridge-run-cartridge>`, например:"

msgid ""
"$ # in application directory\n"
"$ cartridge start # starts all instances\n"
"$ cartridge start .router_1 # starts a single instance\n"
"\n"
"$ # in multi-application environment\n"
"$ cartridge start my_app # starts all instances of my_app\n"
"$ cartridge start my_app.router # starts a single instance"
msgstr ""
"$ # в директории приложения\n"
"$ cartridge start # запускает все экземпляры\n"
"$ cartridge start .router_1 # запускает один экземпляр\n"
"\n"
"$ # в среде с несколькими приложениями \n"
"$ cartridge start my_app # запускает все экземпляры приложения my_app\n"
"$ cartridge start my_app.router # запускает один экземпляр"

msgid ""
"In case it is a cluster-aware application, proceed to :ref:`deploying the "
"cluster <cartridge-deployment>`."
msgstr ""
"Если это приложение с поддержкой кластеров, далее переходите к "
":ref:`развертыванию кластера <cartridge-deployment>`."

msgid "Deploying from sources"
msgstr "Развертывание из исходных файлов"

msgid "This deployment method is intended for local testing only."
msgstr ""
"Такой метод развертывания предназначен только для локального тестирования."

msgid "Pull all dependencies to the ``.rocks`` directory:"
msgstr "Вытяните все зависимости в каталог ``.rocks``:"

msgid "$ tarantoolctl rocks make"
msgstr "$ tarantoolctl rocks make"

msgid "Starting/stopping instances"
msgstr "Запуск/остановка экземпляров"

msgid ""
"Depending on your :ref:`deployment method <cartridge-deploy>`, you can "
"start/stop the instances using :ref:`tarantool <cartridge-run-tarantool>`, "
":ref:`cartridge CLI <cartridge-run-cartridge>`, or :ref:`systemctl "
"<cartridge-run-systemctl>`."
msgstr ""
"В зависимости от :ref:`способа развертывания <cartridge-deploy>` вы можете "
"запускать/останавливать экземпляры, используя :ref:`tarantool <cartridge-"
"run-tarantool>`, :ref:`интерфейс командной строки cartridge <cartridge-run-"
"cartridge>` или :ref:`systemctl <cartridge-run-systemctl>`."

msgid "Start/stop using tarantool"
msgstr "Запуск и остановка с помощью tarantool"

msgid "With ``tarantool``, you can start only a single instance:"
msgstr "С помощью ``tarantool`` можно запустить только один экземпляр:"

msgid ""
"# the simplest command\n"
"$ tarantool init.lua"
msgstr ""
"# простейшая команда\n"
"$ tarantool init.lua"

msgid ""
"You can also :ref:`specify more options <cartridge-config-tarantool>` on the"
" command line or in environment variables."
msgstr ""
"Можно также :ref:`задать дополнительные параметры <cartridge-config-"
"tarantool>` в командной строке или в переменных окружения."

msgid "To stop the instance, use Ctrl+C."
msgstr "Чтобы остановить экземпляр, используйте Ctrl+C."

msgid "Start/stop using cartridge CLI"
msgstr "Запуск и остановка с помощью CLI в cartridge"

msgid "With ``cartridge`` CLI, you can start one or multiple instances:"
msgstr ""
"С помощью интерфейса командной строки ``cartridge``, можно запустить один "
"или несколько экземпляров:"

msgid "$ cartridge start [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr "$ cartridge start [APP_NAME[.INSTANCE_NAME]] [options]"

msgid "The options are:"
msgstr "Возможные параметры:"

msgid "``--script FILE``"
msgstr "``--script FILE``"

msgid "Application's entry point. Defaults to:"
msgstr "Точка входа в приложение. По умолчанию:"

msgid "``TARANTOOL_SCRIPT``, or"
msgstr "``TARANTOOL_SCRIPT``, либо"

msgid "``./init.lua`` when running from the app's directory, or"
msgstr "``./init.lua``, если запуск идет из каталога приложения, или же"

msgid "``:apps_path/:app_name/init.lua`` in a multi-app environment."
msgstr ""
"``:путь_к_приложениям/:имя_приложения/init.lua`` в среде с несколькими "
"приложениями."

msgid "``--apps_path PATH``"
msgstr "``--apps_path PATH``"

msgid ""
"Path to apps directory when running in a multi-app environment. Defaults to "
"``/usr/share/tarantool``."
msgstr ""
"Путь к каталогу с приложениями при запуске из среды с несколькими "
"приложениями. По умолчанию: ``/usr/share/tarantool``."

msgid "``--run_dir DIR``"
msgstr "``--run_dir DIR``"

msgid ""
"Directory with pid and sock files. Defaults to ``TARANTOOL_RUN_DIR`` or "
"``/var/run/tarantool``."
msgstr ""
"Каталог с файлами pid и sock. По умолчанию: ``TARANTOOL_RUN_DIR`` или "
"``/var/run/tarantool``."

msgid "``--cfg FILE``"
msgstr "``--cfg FILE``"

msgid ""
"Cartridge instances YAML configuration file. Defaults to ``TARANTOOL_CFG`` "
"or ``./instances.yml``. The ``instances.yml`` file contains "
"``cartridge.cfg()`` parameters described in the :ref:`configuration section "
"<cartridge-config-basic>` of this guide."
msgstr ""
"Файл конфигурации в формате YAML для экземпляра Cartridge. По умолчанию: "
"``TARANTOOL_CFG`` или ``./instances.yml``. Файл ``instances.yml`` содержит "
"параметры ``cartridge.cfg()``, которые описаны в :ref:`разделе о "
"конфигурации <cartridge-config-basic>`."

msgid "``--foreground``"
msgstr "``--foreground``"

msgid "Do not daemonize."
msgstr "Не в фоне."

msgid ""
"$ cartridge start my_app --cfg demo.yml --run_dir ./tmp/run --foreground"
msgstr ""
"$ cartridge start my_app --cfg demo.yml --run_dir ./tmp/run --foreground"

msgid ""
"It starts all ``tarantool`` instances specified in ``cfg`` file, in "
"foreground, with enforced :ref:`environment variables <cartridge-config>`."
msgstr ""
"Это запустит все экземпляры Tarantool, указанные в файле ``cfg``, не в "
"фоновом режиме с принудительным использованием :ref:`переменных окружения "
"<cartridge-config>`."

msgid ""
"When ``APP_NAME`` is not provided, ``cartridge`` parses it from "
"``./*.rockspec`` filename."
msgstr ""
"Если ``APP_NAME`` не указано, ``cartridge`` выделит его из имени файла "
"``./*.rockspec``."

msgid ""
"When ``INSTANCE_NAME`` is not provided, ``cartridge`` reads ``cfg`` file and"
" starts all defined instances:"
msgstr ""
"Если ``ИМЯ_ЭКЗЕМПЛЯРА`` не указывается, ``cartridge`` прочитает файл ``cfg``"
" и запустит все указанные экземпляры:"

msgid "To stop the instances, run:"
msgstr "Чтобы остановить экземпляры, выполните команду:"

msgid "$ cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr "$ cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]"

msgid "These options from the ``cartridge start`` command are supported:"
msgstr "Поддерживаются следующие параметры из команды ``cartridge start``:"

msgid "Start/stop using systemctl"
msgstr "Запуск и остановка с помощью systemctl"

msgid "To run a single instance:"
msgstr "Чтобы запустить отдельный экземпляр:"

msgid "$ systemctl start APP_NAME"
msgstr "$ systemctl start APP_NAME"

msgid ""
"This will start a  ``systemd`` service that will listen to the port "
"specified in :ref:`instance configuration <cartridge-run-systemctl-config>` "
"(``http_port`` parameter)."
msgstr ""
"Это запустит службу ``systemd``, которая будет прослушивать порт, указанный "
"в :ref:`конфигурации экземпляра <cartridge-run-systemctl-config>` (параметр "
"``http_port``)."

msgid "To run multiple instances on one or multiple servers:"
msgstr ""
"Чтобы запустить несколько экземпляров на одном или нескольких серверах:"

msgid ""
"$ systemctl start APP_NAME@INSTANCE_1\n"
"$ systemctl start APP_NAME@INSTANCE_2\n"
"...\n"
"$ systemctl start APP_NAME@INSTANCE_N"
msgstr ""
"$ systemctl start APP_NAME@INSTANCE_1\n"
"$ systemctl start APP_NAME@INSTANCE_2\n"
"...\n"
"$ systemctl start APP_NAME@INSTANCE_N"

msgid ""
"where ``APP_NAME@INSTANCE_N`` is the instantiated service name for "
"``systemd`` with an incremental ``N`` -- a number, unique for every "
"instance, added to the port the instance will listen to (e.g., ``3301``, "
"``3302``, etc.)"
msgstr ""
"где ``APP_NAME@INSTANCE_N`` -- это имя экземпляра сервиса ``systemd`` с "
"инкрементным числом N (уникальным для каждого экземпляра), которое следует "
"добавить к порту ``3300`` для настройки прослушивания (например, ``3301``, "
"``3302`` и т.д.)."

msgid ""
"To stop all services on a server, use the ``systemctl stop`` command and "
"specify instance names one by one. For example:"
msgstr ""
"Чтобы остановить все сервисы на сервере, используйте команду ``systemctl "
"stop`` и укажите имена экземпляров по одному. Например:"

msgid ""
"$ systemctl stop APP_NAME@INSTANCE_1 APP_NAME@INSTANCE_2 ... "
"APP_NAME@INSTANCE_<N>"
msgstr ""
"$ systemctl stop APP_NAME@INSTANCE_1 APP_NAME@INSTANCE_2 ... "
"APP_NAME@INSTANCE_<N>"

msgid ""
"When running instances with ``systemctl``, keep these practices in mind:"
msgstr ""
"При запуске экземпляров с помощью ``systemctl`` следует помнить о следующих "
"правилах:"

msgid "You can specify *instance configuration* in a YAML file."
msgstr "Можно задать *конфигурацию экземпляра* в YAML-файле."

msgid ""
"This file can contain `these options "
"<https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_api/modules/cartridge.argparse/#tables>`_;"
" see an example `here "
"<https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_cli/#usage-"
"example>`_)."
msgstr ""
"В этом файле могут быть `эти параметры "
"<https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_api/modules/cartridge.argparse/#tables>`_;"
" см. пример `здесь "
"<https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_cli/#usage-"
"example>`_)."

msgid ""
"Save this file to ``/etc/tarantool/conf.d/`` (the default ``systemd`` path) "
"or to a location set in the ``TARANTOOL_CFG`` environment variable (if "
"you've edited the application's ``systemd`` unit file). The file name "
"doesn't matter: it can be ``instances.yml`` or anything else you like."
msgstr ""
"Сохраните этот файл в ``/etc/tarantool/conf.d/`` (путь по умолчанию для "
"``systemd``) или в место, указанное в переменной окружения ``TARANTOOL_CFG``"
" (если вы отредактировали файл ``systemd`` в своем приложении). Имя файла не"
" имеет значения — может быть ``instances.yml`` или любое другое, которое вам"
" нравится."

msgid "Here's what ``systemd`` is doing further:"
msgstr "Вот что ``systemd`` делает дальше:"

msgid ""
"obtains ``app_name`` (and ``instance_name``, if specified) from the name of "
"the application's ``systemd`` unit file (e.g. ``APP_NAME@default`` or "
"``APP_NAME@INSTANCE_1``);"
msgstr ""
"получает ``app_name`` (и ``instance_name``, если оно указано) из имени файла"
" ``systemd`` (например, ``APP_NAME@default`` или ``APP_NAME@INSTANCE_1``);"

msgid ""
"sets default console socket (e.g. "
"``/var/run/tarantool/APP_NAME@INSTANCE_1.control``), PID file (e.g. "
"``/var/run/tarantool/APP_NAME@INSTANCE_1.pid``) and ``workdir`` (e.g. "
"``/var/lib/tarantool/<APP_NAME>.<INSTANCE_NAME>``). "
"``Environment=TARANTOOL_WORKDIR=${workdir}.%i``"
msgstr ""
"задает значения по умолчанию для сокета консоли (например, "
"``/var/run/tarantool/APP_NAME@INSTANCE_1.control``), PID-файла (например, "
"``/var/run/tarantool/APP_NAME@INSTANCE_1.pid``) и параметра ``workdir`` "
"(например, ``/var/lib/tarantool/<APP_NAME>.<INSTANCE_NAME>``). "
"``Environment=TARANTOOL_WORKDIR=${workdir}.%i``"

msgid ""
"Finally, ``cartridge`` looks across all YAML files in "
"``/etc/tarantool/conf.d`` for a section with the appropriate name (e.g. "
"``app_name`` that contains common configuration for all instances, and "
"``app_name.instance_1`` that contain instance-specific configuration). As a "
"result, Cartridge options ``workdir``, ``console_sock``, and ``pid_file`` in"
" the YAML file `cartridge.cfg "
"<https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_api/modules/cartridge/#cfg-"
"opts-box-opts>`_ become useless, because ``systemd`` overrides them."
msgstr ""
"Наконец, ``cartridge`` ищет раздел с соответстующим названием (например, "
"``app_name``, который содержит общую конфигурацию для всех экземпляров, и "
"``app_name.instance_1``, который содержит конфигурацию для конкретного "
"экземпляра) по всем YAML-файлам в ``/etc/tarantool/conf.d``. В результате "
"параметры Cartridge ``workdir``, ``console_sock`` и ``pid_file`` в YAML-"
"файле `cartridge.cfg "
"<https://www.tarantool.io/en/doc/latest/book/cartridge/cartridge_api/modules/cartridge/#cfg-"
"opts-box-opts>`_ будут бесполезны, потому что ``systemd`` переопределит их."

msgid ""
"The default tool for querying logs is `journalctl "
"<https://www.freedesktop.org/software/systemd/man/journalctl.html>`_. For "
"example:"
msgstr ""
"Для запросов по журналам по умолчанию используется `journalctl "
"<https://www.freedesktop.org/software/systemd/man/journalctl.html>`_. "
"Например:"

msgid ""
"$ # show log messages for a systemd unit named APP_NAME.INSTANCE_1\n"
"$ journalctl -u APP_NAME.INSTANCE_1\n"
"\n"
"$ # show only the most recent messages and continuously print new ones\n"
"$ journalctl -f -u APP_NAME.INSTANCE_1"
msgstr ""
"$ # показать журнал сообщений для юнит-файла systemd с именем APP_NAME.INSTANCE_1\n"
"$ journalctl -u APP_NAME.INSTANCE_1\n"
"\n"
"$ # показать только самые последние сообщения и затем продолжать выводить новые\n"
"$ journalctl -f -u APP_NAME.INSTANCE_1"

msgid ""
"If really needed, you can change logging-related ``box.cfg`` options in the "
"YAML configuration file: see `log "
"<https://www.tarantool.io/en/doc/2.3/reference/configuration/#confval-log>`_"
" and other related options."
msgstr ""
"Если действительно нужно, можно изменить связанные с журналированием "
"параметры ``box.cfg`` в конфигурационном YAML-файле: см. `log "
"<https://www.tarantool.io/en/doc/2.3/reference/configuration/#confval-log>`_"
" и другие необходимые параметры."

msgid "Error handling guidelines"
msgstr "Рекомендации по обработке ошибок"

msgid ""
"Almost all errors in Cartridge follow the ``return nil, err`` style, where "
"``err`` is an error object produced by Tarantool's `errors "
"<https://github.com/tarantool/errors>`_ module. Cartridge doesn't raise "
"errors except for bugs and functions contracts mismatch. Developing new "
"roles should follow these guidelines as well."
msgstr ""
"Почти все ошибки в Cartridge создаются по формату ``return nil, err``, где "
"``err`` — объект ошибки, созданный модулем `errors "
"<https://github.com/tarantool/errors>`_. Cartridge не выдает ошибки, за "
"исключением ошибок кода и несоответствия контрактов функций. При разработке "
"новых ролей также нужно следовать этим рекомендациям."

msgid "Error objects in Lua"
msgstr "Объекты ошибок в Lua"

msgid ""
"Error classes help to locate the problem's source. For this purpose, an "
"error object contains its class, stack traceback, and a message."
msgstr ""
"Классы ошибок помогают обнаружить источник проблемы. Для этого объект ошибки"
" содержит имя своего класса, трассировку стека и сообщение."

msgid ""
"local errors = require('errors')\n"
"local DangerousError = errors.new_class(\"DangerousError\")\n"
"\n"
"local function some_fancy_function()\n"
"\n"
"    local something_bad_happens = true\n"
"\n"
"    if something_bad_happens then\n"
"        return nil, DangerousError:new(\"Oh boy\")\n"
"    end\n"
"\n"
"    return \"success\" -- not reachable due to the error\n"
"end\n"
"\n"
"print(some_fancy_function())"
msgstr ""
"local errors = require('errors')\n"
"local DangerousError = errors.new_class(\"DangerousError\")\n"
"\n"
"local function some_fancy_function()\n"
"\n"
"    local something_bad_happens = true\n"
"\n"
"    if something_bad_happens then\n"
"        return nil, DangerousError:new(\"Oh boy\")\n"
"    end\n"
"\n"
"    return \"success\" -- недостижимо из-за ошибки\n"
"end\n"
"\n"
"print(some_fancy_function())"

msgid ""
"nil DangerousError: Oh boy\n"
"stack traceback:\n"
"    test.lua:9: in function 'some_fancy_function'\n"
"    test.lua:15: in main chunk"
msgstr ""
"nil DangerousError: Oh boy\n"
"stack traceback:\n"
"    test.lua:9: in function 'some_fancy_function'\n"
"    test.lua:15: in main chunk"

msgid "For uniform error handling, ``errors`` provides the ``:pcall`` API:"
msgstr "Для равномерной обработки ошибок в ``errors`` есть API ``:pcall``:"

msgid ""
"local ret, err = DangerousError:pcall(some_fancy_function)\n"
"print(ret, err)"
msgstr ""
"local ret, err = DangerousError:pcall(some_fancy_function)\n"
"print(ret, err)"

msgid ""
"nil DangerousError: Oh boy\n"
"stack traceback:\n"
"    test.lua:9: in function <test.lua:4>\n"
"    [C]: in function 'xpcall'\n"
"    .rocks/share/tarantool/errors.lua:139: in function 'pcall'\n"
"    test.lua:15: in main chunk"
msgstr ""
"nil DangerousError: Oh boy\n"
"stack traceback:\n"
"    test.lua:9: in function <test.lua:4>\n"
"    [C]: in function 'xpcall'\n"
"    .rocks/share/tarantool/errors.lua:139: in function 'pcall'\n"
"    test.lua:15: in main chunk"

msgid "print(DangerousError:pcall(error, 'what could possibly go wrong?'))"
msgstr "print(DangerousError:pcall(error, 'what could possibly go wrong?'))"

msgid ""
"nil DangerousError: what could possibly go wrong?\n"
"stack traceback:\n"
"    [C]: in function 'xpcall'\n"
"    .rocks/share/tarantool/errors.lua:139: in function 'pcall'\n"
"    test.lua:15: in main chunk"
msgstr ""
"nil DangerousError: what could possibly go wrong?\n"
"stack traceback:\n"
"    [C]: in function 'xpcall'\n"
"    .rocks/share/tarantool/errors.lua:139: in function 'pcall'\n"
"    test.lua:15: in main chunk"

msgid ""
"For ``errors.pcall`` there is no difference between the ``return nil, err`` "
"and ``error()`` approaches."
msgstr ""
"Для ``errors.pcall`` нет никакой разницы между ``return nil, err`` и "
"``error()``."

msgid ""
"Note that ``errors.pcall`` API differs from the vanilla Lua `pcall "
"<https://www.lua.org/pil/8.4.html>`_. Instead of ``true`` the former returns"
" values returned from the call. If there is an error, it returns ``nil`` "
"instead of ``false``, plus an error message."
msgstr ""
"Обратите внимание, что API ``errors.pcall`` отличается от ванильного `pcall "
"<https://www.lua.org/pil/8.4.html>`_ в Lua. Вместо ``true`` первый "
"возвращает значения, полученные в результате вызова. Если произошла ошибка, "
"то вместо ``false`` вернется ``nil`` и сообщение об ошибке."

msgid ""
"Remote ``net.box`` calls keep no stack trace from the remote. In that case, "
"``errors.netbox_eval`` comes to the rescue. It will find a stack trace from "
"local and remote hosts and restore metatables."
msgstr ""
"Удаленные вызовы ``net.box`` не сохраняют трассировку стека от удаленного "
"устройства. В этом случае на помощь придет ``errors.netbox_eval``. Он найдет"
" трассировку стека с локального и удаленного хостов и восстановит "
"метатаблицы."

msgid ""
"> conn = require('net.box').connect('localhost:3301')\n"
"> print( errors.netbox_eval(conn, 'return nil, DoSomethingError:new(\"oops\")') )\n"
"nil     DoSomethingError: oops\n"
"stack traceback:\n"
"        eval:1: in main chunk\n"
"during net.box eval on localhost:3301\n"
"stack traceback:\n"
"        [string \"return print( errors.netbox_eval(\"]:1: in main chunk\n"
"        [C]: in function 'pcall'"
msgstr ""
"> conn = require('net.box').connect('localhost:3301')\n"
"> print( errors.netbox_eval(conn, 'return nil, DoSomethingError:new(\"oops\")') )\n"
"nil     DoSomethingError: oops\n"
"stack traceback:\n"
"        eval:1: in main chunk\n"
"during net.box eval on localhost:3301\n"
"stack traceback:\n"
"        [string \"return print( errors.netbox_eval(\"]:1: in main chunk\n"
"        [C]: in function 'pcall'"

msgid ""
"However, ``vshard`` implemented in Tarantool doesn't utilize the ``errors`` "
"module. Instead it uses `its own errors "
"<https://github.com/tarantool/vshard/blob/master/vshard/error.lua>`_. Keep "
"this in mind when working with ``vshard`` functions."
msgstr ""
"Тем не мене, реализованный в Tarantool ``vshard`` не использует модуль "
"``errors``. Вместо этого он использует `собственные ошибки "
"<https://github.com/tarantool/vshard/blob/master/vshard/error.lua>`_. Имейте"
" это в виду при работе с функциями ``vshard``."

msgid ""
"Data included in an error object (class name, message, traceback) may be "
"easily converted to string using the ``tostring()`` function."
msgstr ""
"Данные, включенные в объект ошибки (имя класса, сообщение, обратная "
"трассировка), можно легко преобразовать в строку с помощью функции "
"``tostring()``."

msgid "GraphQL"
msgstr "GraphQL"

msgid ""
"GraphQL implementation in Cartridge wraps the ``errors`` module, so a "
"typical error response looks as follows:"
msgstr ""
"В реализации GraphQL в Cartridge оборачивается модуль ``errors``, поэтому "
"обычно ответ на ошибку выглядит следующим образом:"

msgid ""
"{\n"
"    \"errors\":[{\n"
"        \"message\":\"what could possibly go wrong?\",\n"
"        \"extensions\":{\n"
"            \"io.tarantool.errors.stack\":\"stack traceback: ...\",\n"
"            \"io.tarantool.errors.class_name\":\"DangerousError\"\n"
"        }\n"
"    }]\n"
"}"
msgstr ""
"{\n"
"    \"errors\":[{\n"
"        \"message\":\"what could possibly go wrong?\",\n"
"        \"extensions\":{\n"
"            \"io.tarantool.errors.stack\":\"stack traceback: ...\",\n"
"            \"io.tarantool.errors.class_name\":\"DangerousError\"\n"
"        }\n"
"    }]\n"
"}"

msgid ""
"Read more about errors in the `GraphQL specification "
"<http://spec.graphql.org/draft/#sec-Errors.Error-result-format>`_."
msgstr ""
"Подробнее об ошибках читайте в `спецификации GraphQL "
"<http://spec.graphql.org/draft/#sec-Errors.Error-result-format>`_."

msgid ""
"If you're going to implement a GraphQL handler, you can add your own "
"extension like this:"
msgstr ""
"Если вы собираетесь реализовать обработчик GraphQL, то можете добавить свое "
"расширение таким образом:"

msgid ""
"local err = DangerousError:new('I have extension')\n"
"err.graphql_extensions = {code = 403}"
msgstr ""
"local err = DangerousError:new('I have extension')\n"
"err.graphql_extensions = {code = 403}"

msgid "It will lead to the following response:"
msgstr "Ответ будет таким:"

msgid ""
"{\n"
"    \"errors\":[{\n"
"        \"message\":\"I have extension\",\n"
"        \"extensions\":{\n"
"            \"io.tarantool.errors.stack\":\"stack traceback: ...\",\n"
"            \"io.tarantool.errors.class_name\":\"DangerousError\",\n"
"            \"code\":403\n"
"        }\n"
"    }]\n"
"}"
msgstr ""
"{\n"
"    \"errors\":[{\n"
"        \"message\":\"I have extension\",\n"
"        \"extensions\":{\n"
"            \"io.tarantool.errors.stack\":\"stack traceback: ...\",\n"
"            \"io.tarantool.errors.class_name\":\"DangerousError\",\n"
"            \"code\":403\n"
"        }\n"
"    }]\n"
"}"

msgid "HTTP"
msgstr "HTTP"

msgid ""
"In a nutshell, an ``errors`` object is a table. This means that it can be "
"swiftly represented in JSON. This approach is used by Cartridge to handle "
"errors via http:"
msgstr ""
"Если кратко, то объект ``errors`` представляет собой таблицу, то есть его "
"можно быстро представить в JSON. В Cartridge это используется для обработки "
"ошибок через HTTP:"

msgid ""
"local err = DangerousError:new('Who would have thought?')\n"
"\n"
"local resp = req:render({\n"
"    status = 500,\n"
"    headers = {\n"
"        ['content-type'] = \"application/json; charset=utf-8\"\n"
"    },\n"
"    json = json.encode(err),\n"
"})"
msgstr ""
"local err = DangerousError:new('Who would have thought?')\n"
"\n"
"local resp = req:render({\n"
"    status = 500,\n"
"    headers = {\n"
"        ['content-type'] = \"application/json; charset=utf-8\"\n"
"    },\n"
"    json = json.encode(err),\n"
"})"

msgid ""
"{\n"
"    \"line\":27,\n"
"    \"class_name\":\"DangerousError\",\n"
"    \"err\":\"Who would have thought?\",\n"
"    \"file\":\".../app/roles/api.lua\",\n"
"    \"stack\":\"stack traceback:...\"\n"
"}"
msgstr ""
"{\n"
"    \"line\":27,\n"
"    \"class_name\":\"DangerousError\",\n"
"    \"err\":\"Who would have thought?\",\n"
"    \"file\":\".../app/roles/api.lua\",\n"
"    \"stack\":\"stack traceback:...\"\n"
"}"
