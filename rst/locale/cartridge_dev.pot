
msgid "Tarantool Cartridge developer's guide"
msgstr ""

msgid "For a quick start, skip the details below and jump right away to this detailed `guide <https://github.com/tarantool/cartridge-cli/blob/master/examples/getting-started-app/README.md>`_ to creating a cluster-aware Tarantool application."
msgstr ""

msgid "For a deep dive into what you can do with Tarantool Cartridge, go on with this section."
msgstr ""

msgid "To develop and start an application, in short, you need to go through the following steps:"
msgstr ""

msgid ":ref:`Install <cartridge-install>` Tarantool Cartridge and other components of the development environment."
msgstr ""

msgid "Choose a :ref:`template <cartridge-templates>` for the application and create a project."
msgstr ""

msgid "Develop the application. In case it is a cluster-aware application, implement its logic in a custom (user-defined) :ref:`cluster role <cartridge-roles>` to initialize the database in a cluster environment."
msgstr ""

msgid ":ref:`Deploy <cartridge-deploy>` the application to target server(s). This includes :ref:`configuring <cartridge-config>` and :ref:`starting <cartridge-run>` the instance(s)."
msgstr ""

msgid "In case it is a cluster-aware application, :ref:`deploy the cluster <cartridge-deployment>`."
msgstr ""

msgid "The following sections provide details for each of these steps."
msgstr ""

msgid "Installing Tarantool Cartridge"
msgstr ""

msgid "Install ``catridge-cli``, a command-line tool for developing, deploying, and managing Tarantool applications:"
msgstr ""

msgid "$ tarantoolctl rocks install cartridge-cli"
msgstr ""

msgid "The Cartridge framework will come as a dependency when you create your project."
msgstr ""

msgid "Everything will be installed to ``.rocks/bin``, so for convenient usage add ``.rocks/bin`` to the executable path:"
msgstr ""

msgid "$ export PATH=$PWD/.rocks/bin/:$PATH"
msgstr ""

msgid "Install ``git``, a version control system."
msgstr ""

msgid "Install ``npm``, a package manager for ``node.js``."
msgstr ""

msgid "Install the ``unzip`` utility."
msgstr ""

msgid "Application templates"
msgstr ""

msgid "Tarantool Cartridge provides you with two templates that help instantly set up the application development environment:"
msgstr ""

msgid "``plain``, for developing an application that runs on a single or multiple independent Tarantool instances (e.g. acting as a proxy to third-party databases) -- that's what you could do before, :ref:`without Tarantool Cartridge <app_server-creating_app>`, but now it's more convenient."
msgstr ""

msgid "``cartridge``, for developing a cluster-aware application -- this is an exclusive feature of Tarantool Cartridge."
msgstr ""

msgid "To create a project based on either template, in any directory say:"
msgstr ""

msgid "# plain application\n"
"$ plain create --name <app_name> /path/to/\n"
"\n"
"# - OR -\n"
"\n"
"# cluster application\n"
"$ cartridge create --name <app_name> /path/to/"
msgstr ""

msgid "This will automatically set up a Git repository in a new ``/path/to/<app_name>/`` directory, tag it with :ref:`version <cartridge-versioning>` ``0.1.0``, and put the necessary files into it (read about default files for each template below)."
msgstr ""

msgid "In this Git repository, you can develop the application (by simply editing the default files provided by the template), plug the necessary modules, and then easily pack everything to deploy on your server(s)."
msgstr ""

msgid "Plain template"
msgstr ""

msgid "The plain template creates the ``<app_name>/`` directory with the following contents:"
msgstr ""

msgid "``<app_name>-scm-1.rockspec`` file where you can specify the application dependencies."
msgstr ""

msgid "``deps.sh`` script that resolves dependencies from the ``.rockspec`` file."
msgstr ""

msgid "``init.lua`` file which is the entry point for your application."
msgstr ""

msgid "``.git`` file necessary for a Git repository."
msgstr ""

msgid "``.gitignore`` file to ignore the unnecessary files."
msgstr ""

msgid "Cluster template"
msgstr ""

msgid "In addition to the files listed in the plain template section, the cluster template contains the following:"
msgstr ""

msgid "``env.lua`` file that sets common rock paths so that the application can be started from any directory."
msgstr ""

msgid "``custom-role.lua`` file that is a placeholder for a custom (user-defined) :ref:`cluster role <cartridge-roles>`."
msgstr ""

msgid "The entry point file (``init.lua``) of the cluster template differs from the plain one. Among other things, it loads the ``cartridge`` module and calls its initialization function:"
msgstr ""

msgid "...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"-- cartridge options example\n"
"  workdir = '/var/lib/tarantool/app',\n"
"  advertise_uri = 'localhost:3301',\n"
"  cluster_cookie = 'super-cluster-cookie',\n"
"  ...\n"
"}, {\n"
"-- box options example\n"
"  memtx_memory = 1000000000,\n"
"  ... })\n"
" ..."
msgstr ""

msgid "The ``cartridge.cfg()`` call renders the instance operable via the administrative console but does not call ``box.cfg()`` to configure instances."
msgstr ""

msgid "Calling the ``box.cfg()`` function is forbidden."
msgstr ""

msgid "The cluster itself will do it for you when it is time to:"
msgstr ""

msgid "bootstrap the current instance once you:"
msgstr ""

msgid "run ``cartridge.bootstrap()`` via the administrative console, or"
msgstr ""

msgid "click **Create** in the web interface;"
msgstr ""

msgid "join the instance to an existing cluster once you:"
msgstr ""

msgid "run ``cartridge.join_server({uri = 'other_instance_uri'})`` via the console, or"
msgstr ""

msgid "click **Join** (an existing replica set) or **Create** (a new replica set) in the web interface."
msgstr ""

msgid "Notice that you can specify a cookie for the cluster (``cluster_cookie`` parameter) if you need to run several clusters in the same network. The cookie can be any string value."
msgstr ""

msgid "Before developing a cluster-aware application, familiarize yourself with the notion of :ref:`cluster roles <cartridge-roles>` and make sure to define a custom role to initialize the database for the cluster application."
msgstr ""

msgid "Cluster roles"
msgstr ""

msgid "A Tarantool Cartridge cluster segregates instance functionality in a role-based way. **Cluster roles** are Lua modules that implement some instance-specific functions and/or logic."
msgstr ""

msgid "Since all instances running cluster applications use the same source code and are aware of all the defined roles (and plugged modules), multiple different roles can be dynamically enabled and disabled on any number of instances without restarts even during cluster operation."
msgstr ""

msgid "Built-in roles"
msgstr ""

msgid "The ``cartridge`` module comes with two *built-in* roles that implement automatic sharding:"
msgstr ""

msgid "``vshard-router`` that handles the ``vshard``'s *compute-intensive* workload: routes requests to storage nodes."
msgstr ""

msgid "``vshard-storage`` that handles the ``vshard``'s *transaction-intensive* workload: stores and manages a subset of a dataset."
msgstr ""

msgid "For more information on sharding, see the :ref:`vshard module documentation <vshard>`."
msgstr ""

msgid "With the built-in and custom roles, Tarantool Cartridge allows you to develop applications with separated compute and transaction handling. Later, the relevant workload-specific roles can be enabled on different instances running on physical servers with workload-dedicated hardware."
msgstr ""

msgid "Neither ``vshard-router`` nor ``vshard-storage`` manage spaces, indexes, or formats. To start developing an application, edit the ``custom-role.lua`` placeholder file: add a ``box.schema.space.create()`` call to your first cluster role."
msgstr ""

msgid "Additionally, you can implement several such roles to:"
msgstr ""

msgid "define stored procedures;"
msgstr ""

msgid "implement functionality on top of ``vshard``;"
msgstr ""

msgid "go without ``vshard`` at all;"
msgstr ""

msgid "implement one or multiple supplementary services such as e-mail notifier, replicator, etc."
msgstr ""

msgid "Custom roles"
msgstr ""

msgid "To implement a *custom* cluster role, do the following:"
msgstr ""

msgid "Register the new role in the cluster by modifying the ``cartridge.cfg()`` call in the ``init.lua`` entry point file:"
msgstr ""

msgid "...\n"
"local cartridge = require('cartridge')\n"
"...\n"
"cartridge.cfg({\n"
"  workdir = ...,\n"
"  advertise_uri = ...,\n"
"  roles = {'custom-role'},\n"
"})\n"
"..."
msgstr ""

msgid "where ``custom-role`` is the name of the Lua module to be loaded."
msgstr ""

msgid "Implement the role in a file with the appropriate name (``custom-role.lua``). For example:"
msgstr ""

msgid "#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"local role_name = 'custom-role'\n"
"\n"
"local function init()\n"
"...\n"
"end\n"
"\n"
"local function stop()\n"
"...\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    init = init,\n"
"    stop = stop,\n"
"}"
msgstr ""

msgid "Where the ``role_name`` may differ from the module name passed to the ``cartridge.cfg()`` function. If the ``role_name`` variable is not specified, the module name is the default value."
msgstr ""

msgid "Role names must be unique as it is impossible to register multiple roles with the same name."
msgstr ""

msgid "The role module does not have required functions but the cluster may execute the following ones during the role's life cycle:"
msgstr ""

msgid "``init()`` is the role's *initialization* function."
msgstr ""

msgid "Inside the function's body you can call any ``box`` functions: create spaces, indexes, grant permissions, etc. Here is what the initialization function may look like:"
msgstr ""

msgid "local function init(opts)\n"
"    -- The cluster passes an 'opts' Lua table containing an 'is_master' flag.\n"
"    if opts.is_master then\n"
"        local customer = box.schema.space.create('customer',\n"
"            { if_not_exists = true }\n"
"        )\n"
"        customer:format({\n"
"            {'customer_id', 'unsigned'},\n"
"            {'bucket_id', 'unsigned'},\n"
"            {'name', 'string'},\n"
"        })\n"
"        customer:create_index('customer_id', {\n"
"            parts = {'customer_id'},\n"
"            if_not_exists = true,\n"
"        })\n"
"    end\n"
"end"
msgstr ""

msgid "The function's body is wrapped in a conditional statement that lets you call ``box`` functions on masters only. This protects against replication collisions as data propagates to replicas automatically."
msgstr ""

msgid "``stop()`` is the role's *termination* function. Implement it if initialization starts a fiber that has to be stopped or does any job that has to be undone on termination."
msgstr ""

msgid "``validate_config()`` and ``apply_config()`` are *validation* and *application* functions that make custom roles configurable. Implement them if some configuration data has to be stored cluster-wide."
msgstr ""

msgid "Next, get a grip on the :ref:`role's life cycle <cartridge-role-lifecycle>` to implement the necessary functions."
msgstr ""

msgid "Defining role dependencies"
msgstr ""

msgid "You can instruct the cluster to apply some other roles if your custom role is enabled."
msgstr ""

msgid "For example:"
msgstr ""

msgid "-- Role dependencies defined in custom-role.lua\n"
"local role_name = 'custom-role'\n"
"...\n"
"return {\n"
"    role_name = role_name,\n"
"    dependencies = {'cartridge.roles.vshard-router'},\n"
"    ...\n"
"}"
msgstr ""

msgid "Here ``vshard-router`` role will be initialized automatically for every instance with ``custom-role`` enabled."
msgstr ""

msgid "Using multiple vshard storage groups"
msgstr ""

msgid "Replica sets with ``vshard-storage`` roles can belong to different *groups*. For example, ``hot`` or ``cold`` groups meant to independently process hot and cold data."
msgstr ""

msgid "Groups are specified in the cluster's configuration:"
msgstr ""

msgid "cartridge.cfg({\n"
"    vshard_groups = {'hot', 'cold'},\n"
"    ...\n"
"})"
msgstr ""

msgid "If no groups are specified, the cluster assumes that all replica sets belong to the ``default`` group."
msgstr ""

msgid "With multiple groups enabled, every replica set with a ``vshard-storage`` role enabled must be assigned to a particular group. The assignment can never be changed."
msgstr ""

msgid "Another limitation is that you cannot add groups dynamically (this will become available in future)."
msgstr ""

msgid "Finally, mind the new syntax for router access. Every instance with a ``vshard-router`` role enabled initializes multiple routers. All of them are accessible through the role:"
msgstr ""

msgid "local router_role = cartridge.service_get('vshard-router')\n"
"router_role.get('hot'):call(...)"
msgstr ""

msgid "If you have no roles specified, you can access a static router as before:"
msgstr ""

msgid "local vhsard = require('vshard')\n"
"vshard.router.call(...)"
msgstr ""

msgid "However, when using the new API, you must call a static router with a colon:"
msgstr ""

msgid "local router_role = cartridge.service_get('vshard-router')\n"
"local default_router = router_role.get() -- or router_role.get('default')\n"
"default_router:call(...)"
msgstr ""

msgid "Role's life cycle and the order of function execution"
msgstr ""

msgid "The cluster displays all custom role names along with the built-in ``vshard`` ones in the web interface. Cluster administrators can enable and disable them for particular instances either via the web interface or cluster public API. For example:"
msgstr ""

msgid "cartridge.admin.edit_replicaset('replicaset-uuid', {roles = {'vshard-router', 'custom-role'}})"
msgstr ""

msgid "If multiple roles are enabled on an instance at the same time, the cluster first initializes the built-in roles (if any) and then the custom ones (if any) in the order the latter were listed in ``cartridge.cfg()``."
msgstr ""

msgid "If a custom role has dependent roles, the dependencies are registered and validated first, prior to the role itself."
msgstr ""

msgid "The cluster calls the role's functions in the following circumstances:"
msgstr ""

msgid "The ``init()`` function, typically, once: either when the role is enabled by the administrator or at the instance restart. Enabling a role once is normally enough."
msgstr ""

msgid "The ``stop()`` function -- only when the administrator disables the role, not on instance termination."
msgstr ""

msgid "The ``validate_config()`` function, first, before the automatic ``box.cfg()`` call (database initialization), then -- upon every configuration update."
msgstr ""

msgid "The ``apply_config()`` function upon every configuration update."
msgstr ""

msgid "Hence, if the cluster is tasked with performing the following actions, it will execute the functions listed in the following order:"
msgstr ""

msgid "Join an instance or create a replica set, both with an enabled role:"
msgstr ""

msgid "``validate_config()``"
msgstr ""

msgid "``init()``"
msgstr ""

msgid "``apply_config()``"
msgstr ""

msgid "Restart an instance with an enabled role:"
msgstr ""

msgid "Disable role: ``stop()``."
msgstr ""

msgid "Upon the ``cartridge.confapplier.patch_clusterwide()`` call:"
msgstr ""

msgid "Upon a triggered failover:"
msgstr ""

msgid "Considering the described behavior:"
msgstr ""

msgid "The ``init()`` function may:"
msgstr ""

msgid "Call ``box`` functions."
msgstr ""

msgid "Start a fiber and, in this case, the ``stop()`` function should take care of the fiber's termination."
msgstr ""

msgid "Configure the built-in :ref:`HTTP server <cartridge-httpd-instance>`."
msgstr ""

msgid "Execute any code related to the role's initialization."
msgstr ""

msgid "The ``stop()`` functions must undo any job that has to be undone on role's termination."
msgstr ""

msgid "The ``validate_config()`` function must validate any configuration change."
msgstr ""

msgid "The ``apply_config()`` function may execute any code related to a configuration change, e.g., take care of an ``expirationd`` fiber."
msgstr ""

msgid "The validation and application functions together allow you to customize the cluster-wide configuration as described in the :ref:`next section <cartridge-role-config>`."
msgstr ""

msgid "Configuring custom roles"
msgstr ""

msgid "You can:"
msgstr ""

msgid "Store configurations for your custom roles as sections in cluster-wide configuration, for example:"
msgstr ""

msgid "# YAML configuration file\n"
"my_role:\n"
"  notify_url: \"https://localhost:8080\""
msgstr ""

msgid "-- init.lua file\n"
"local notify_url = 'http://localhost'\n"
"function my_role.apply_config(conf, opts)\n"
"  local conf = conf['my_role'] or {}\n"
"  notify_url = conf.notify_url or 'default'\n"
"end"
msgstr ""

msgid "Download and upload cluster-wide configuration using :ref:`cluster UI <cartridge-ui-configuration>` or API (via GET/PUT queries to ``admin/config`` endpoint like ``curl localhost:8081/admin/config`` and ``curl -X PUT -d \"{'my_parameter': 'value'}\" localhost:8081/admin/config``)."
msgstr ""

msgid "Utilize it in your role ``apply_config()`` function."
msgstr ""

msgid "Every instance in the cluster stores a copy of the configuration file in its working directory (configured by ``cartridge.cfg({workdir = ...})``):"
msgstr ""

msgid "``/var/lib/tarantool/<instance_name>/config.yml`` for instances deployed from RPM packages and managed by ``systemd``."
msgstr ""

msgid "``/home/<username>/tarantool_state/var/lib/tarantool/config.yml`` for instances deployed from archives."
msgstr ""

msgid "The cluster's configuration is a Lua table, downloaded and uploaded as YAML. If some application-specific configuration data, e.g., a database schema as defined by DDL (data definition language), has to be stored on every instance in the cluster, you can implement your own API by adding a custom section to the table. The cluster will help you spread it safely across all instances."
msgstr ""

msgid "Such section goes in parallel (in the same file) with the topology-specific and ``vshard``-specific ones the cluster automatically generates. Unlike the generated, the custom section's modification, validation, and application logic has to be defined."
msgstr ""

msgid "The common way is to define two functions:"
msgstr ""

msgid "``validate_config(conf_new, conf_old)`` to validate changes made in the new configuration (``conf_new``) versus the old configuration (``conf_old``)."
msgstr ""

msgid "``apply_config(conf, opts)`` to execute any code related to a configuration change. As input, this function takes the configuration to apply (``conf``, which is actually the new configuration that you validated earlier with ``validate_config()``) and options (the ``opts`` argument that includes ``is_master``, a Boolean flag described later)."
msgstr ""

msgid "The ``validate_config()`` function must detect all configuration problems that may lead to ``apply_config()`` errors. For more information, see the :ref:`next section <cartridge-role-config-apply>`."
msgstr ""

msgid "When implementing validation and application functions that call ``box`` ones for some reason, the following precautions apply:"
msgstr ""

msgid "Due to the :ref:`role's life cycle <cartridge-role-lifecycle>`, the cluster does not guarantee an automatic ``box.cfg()`` call prior to calling ``validate_config()``."
msgstr ""

msgid "If the validation function is to call any ``box`` functions (e.g., to check a format), make sure the calls are wrapped in a protective conditional statement that checks if ``box.cfg()`` has already happened:"
msgstr ""

msgid "-- Inside the validation function:\n"
"\n"
"if type(box.cfg) == 'table' then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""

msgid "Unlike the validation and similar to initialization function, ``apply_config()`` can call ``box`` functions freely as the cluster applies custom configuration after the automatic ``box.cfg()`` call."
msgstr ""

msgid "However, creating spaces, users, etc., can cause replication collisions when performed on both master and replica instances simultaneously. The appropriate way is to call such ``box`` functions on masters only and let the changes propagate to replicas automatically."
msgstr ""

msgid "Upon the ``apply_config(conf, opts)`` execution, the cluster passes an ``is_master`` flag in the ``opts`` table which you can use to wrap collision-inducing ``box`` functions in a protective conditional statement:"
msgstr ""

msgid "-- Inside the configuration application function:\n"
"\n"
"if opts.is_master then\n"
"\n"
"    -- Here you can call box functions\n"
"\n"
"end"
msgstr ""

msgid "Custom configuration example"
msgstr ""

msgid "Consider the following code as part of the role's module (``custom-role.lua``) implementation:"
msgstr ""

msgid "#!/usr/bin/env tarantool\n"
"-- Custom role implementation\n"
"\n"
"local cartridge = require('cartridge')\n"
"\n"
"local role_name = 'custom-role'\n"
"\n"
"-- Modify the config by implementing some setter (an alternative to HTTP PUT)\n"
"local function set_secret(secret)\n"
"    local custom_role_cfg = cartridge.confapplier.get_deepcopy(role_name) or {}\n"
"    custom_role_cfg.secret = secret\n"
"    cartridge.confapplier.patch_clusterwide({\n"
"        [role_name] = custom_role_cfg,\n"
"    })\n"
"end\n"
"-- Validate\n"
"local function validate_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    if custom_role_cfg.secret ~= nil then\n"
"        assert(type(custom_role_cfg.secret) == 'string', 'custom-role.secret must be a string')\n"
"    end\n"
"    return true\n"
"end\n"
"-- Apply\n"
"local function apply_config(cfg)\n"
"    local custom_role_cfg = cfg[role_name] or {}\n"
"    local secret = custom_role_cfg.secret or 'default-secret'\n"
"    -- Make use of it\n"
"end\n"
"\n"
"return {\n"
"    role_name = role_name,\n"
"    set_secret = set_secret,\n"
"    validate_config = validate_config,\n"
"    apply_config = apply_config,\n"
"}"
msgstr ""

msgid "Once the configuration is customized, do one of the following:"
msgstr ""

msgid "continue developing your application and pay attention to its :ref:`versioning <cartridge-versioning>`;"
msgstr ""

msgid "(optional) :ref:`enable authorization <cartridge-auth-enable>` in the web interface."
msgstr ""

msgid "in case the cluster is already deployed, :ref:`apply the configuration <cartridge-role-config-apply>` cluster-wide."
msgstr ""

msgid "Applying custom role's configuration"
msgstr ""

msgid "With the implementation showed by the :ref:`example <cartridge-role-config-example>`, you can call the ``set_secret()`` function to apply the new configuration via the administrative console or an HTTP endpoint if the role exports one."
msgstr ""

msgid "The ``set_secret()`` function calls ``cartridge.confapplier.patch_clusterwide()`` which performs a two-phase commit:"
msgstr ""

msgid "It patches the active configuration in memory: copies the table and replaces the ``\"custom-role\"`` section in the copy with the one given by the ``set_secret()`` function."
msgstr ""

msgid "The cluster checks if the new configuration can be applied on all instances except disabled and expelled. All instances subject to update must be healthy and ``alive`` according to the `membership module <https://www.tarantool.io/en/doc/1.10/reference/reference_rock/membership/>`_."
msgstr ""

msgid "(**Preparation phase**) The cluster propagates the patched configuration. Every instance validates it with the ``validate_config()`` function of every registered role. Depending on the validation's result:"
msgstr ""

msgid "If successful (i.e., returns ``true``), the instance saves the new configuration to a temporary file named ``config.prepare.yml`` within the working directory."
msgstr ""

msgid "(**Abort phase**) Otherwise, the instance reports an error and all other instances roll back the update: remove the file they may have already prepared."
msgstr ""

msgid "(**Commit phase**) Upon successful preparation of all instances, the cluster commits the changes. Every instance:"
msgstr ""

msgid "Creates the active configuration's hard-link."
msgstr ""

msgid "Atomically replaces the active one with the prepared. The atomic replacement is indivisible -- it can either succeed or fail entirely, never partially."
msgstr ""

msgid "Calls the ``apply_config()`` function of every registered role."
msgstr ""

msgid "If any of these steps fail, an error pops up in the web interface next to the corresponding instance. The cluster does not handle such errors automatically, they require manual repair."
msgstr ""

msgid "You will avoid the repair if the ``validate_config()`` function can detect all configuration problems that may lead to ``apply_config()`` errors."
msgstr ""

msgid "Using the built-in HTTP server"
msgstr ""

msgid "The cluster launches an ``httpd`` server instance during initialization (``cartridge.cfg()``). You can bind a port to the instance via an environmental variable:"
msgstr ""

msgid "-- Get the port from an environmental variable or the default one:\n"
"local http_port = os.getenv('HTTP_PORT') or '8080'\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"   ...\n"
"   -- Pass the port to the cluster:\n"
"   http_port = http_port,\n"
"   ...\n"
"})"
msgstr ""

msgid "To make use of the ``httpd`` instance, access it and configure routes inside the ``init()`` function of some role, e.g. a role that exposes API over HTTP:"
msgstr ""

msgid "local function init(opts)\n"
"\n"
"...\n"
"\n"
"   -- Get the httpd instance:\n"
"   local httpd = cartridge.service_get('httpd')\n"
"   if httpd ~= nil then\n"
"       -- Configure a route to, for example, metrics:\n"
"       httpd:route({\n"
"               method = 'GET',\n"
"               path = '/metrics',\n"
"               public = true,\n"
"           },\n"
"           function(req)\n"
"               return req:render({json = stat.stat()})\n"
"           end\n"
"       )\n"
"   end\n"
"end"
msgstr ""

msgid "For more information on the usage of Tarantool's HTTP server, see `its documentation <https://github.com/tarantool/http>`_."
msgstr ""

msgid "Implementing authorization in the web interface"
msgstr ""

msgid "To implement authorization in the web interface of every instance in Tarantool cluster:"
msgstr ""

msgid "Implement a new, say, ``auth`` module with a ``check_password`` function. It should check the credentials of any user trying to log in to the web interface."
msgstr ""

msgid "The ``check_password`` function accepts a username and password and returns an authentication success or failure."
msgstr ""

msgid "-- auth.lua\n"
"\n"
"-- Add a function to check the credentials\n"
"local function check_password(username, password)\n"
"\n"
"    -- Check the credentials any way you like\n"
"\n"
"    -- Return an authentication success or failure\n"
"    if not ok then\n"
"        return false\n"
"    end\n"
"    return true\n"
"end\n"
"..."
msgstr ""

msgid "Pass the implemented ``auth`` module name as a parameter to ``cartridge.cfg()``, so the cluster can use it:"
msgstr ""

msgid "-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    -- The cluster will automatically call 'require()' on the 'auth' module.\n"
"    ...\n"
"})"
msgstr ""

msgid "This adds a **Log in** button to the upper right corner of the web interface but still lets the unsigned users interact with the interface. This is convenient for testing."
msgstr ""

msgid "Also, to authorize requests to cluster API, you can use the HTTP basic authorization header."
msgstr ""

msgid "To require the authorization of every user in the web interface even before the cluster bootstrap, add the following line:"
msgstr ""

msgid "-- init.lua\n"
"\n"
"local ok, err = cartridge.cfg({\n"
"    auth_backend_name = 'auth',\n"
"    auth_enabled = true,\n"
"    ...\n"
"})"
msgstr ""

msgid "With the authentication enabled and the ``auth`` module implemented, the user will not be able to even bootstrap the cluster without logging in. After the successful login and bootstrap, the authentication can be enabled and disabled cluster-wide in the web interface and the ``auth_enabled`` parameter is ignored."
msgstr ""

msgid "Application versioning"
msgstr ""

msgid "Tarantool Cartridge understands semantic versioning as described at `semver.org <https://semver.org>`_. When developing an application, create new Git branches and tag them appropriately. These tags are used to calculate version increments for subsequent packaging."
msgstr ""

msgid "For example, if your application has version 1.2.1, tag your current branch with ``1.2.1`` (annotated or not)."
msgstr ""

msgid "To retrieve the current version from Git, say:"
msgstr ""

msgid "$ git describe --long --tags\n"
"1.2.1-12-g74864f2"
msgstr ""

msgid "This output shows that we are 12 commits after the version 1.2.1. If we are to package the application at this point, it will have a full version of ``1.2.1-12`` and its package will be named ``<app_name>-1.2.1-12.rpm``."
msgstr ""

msgid "Non-semantic tags are prohibited. You will not be able to create a package from a branch with the latest tag being non-semantic."
msgstr ""

msgid "Once you :ref:`package <cartridge-deploy>` your application, the version is saved in a ``VERSION`` file in the package root."
msgstr ""

msgid "Using .cartridge.ignore files"
msgstr ""

msgid "You can add a ``.cartridge.ignore`` file to your application repository to exclude particular files and/or directories from package builds."
msgstr ""

msgid "For the most part, the logic is similar to that of ``.gitignore`` files. The major difference is that in ``.cartridge.ignore`` files the order of exceptions relative to the rest of the templates does not matter, while in ``.gitignore`` files the order does matter."
msgstr ""

msgid "**.cartridge.ignore** entry"
msgstr ""

msgid "ignores every..."
msgstr ""

msgid "``target/``"
msgstr ""

msgid "**folder** (due to the trailing ``/``) named ``target``, recursively"
msgstr ""

msgid "``target``"
msgstr ""

msgid "**file or folder** named ``target``, recursively"
msgstr ""

msgid "``/target``"
msgstr ""

msgid "**file or folder** named ``target`` in the top-most directory (due to the leading ``/``)"
msgstr ""

msgid "``/target/``"
msgstr ""

msgid "**folder** named ``target`` in the top-most directory (leading and trailing ``/``)"
msgstr ""

msgid "``*.class``"
msgstr ""

msgid "every **file or folder** ending with ``.class``, recursively"
msgstr ""

msgid "``#comment``"
msgstr ""

msgid "nothing, this is a comment (the first character is a ``#``)"
msgstr ""

msgid "``\\#comment``"
msgstr ""

msgid "every **file or folder** with name ``#comment`` (``\\`` for escaping)"
msgstr ""

msgid "``target/logs/``"
msgstr ""

msgid "every **folder** named ``logs`` which is a subdirectory of a folder named ``target``"
msgstr ""

msgid "``target/*/logs/``"
msgstr ""

msgid "every **folder** named ``logs`` two levels under a folder named ``target`` (``*`` doesn’t include ``/``)"
msgstr ""

msgid "``target/**/logs/``"
msgstr ""

msgid "every **folder** named ``logs`` somewhere under a folder named ``target`` (``**`` includes ``/``)"
msgstr ""

msgid "``*.py[co]``"
msgstr ""

msgid "every **file or folder** ending in ``.pyc`` or ``.pyo``; however, it doesn’t match ``.py!``"
msgstr ""

msgid "``*.py[!co]``"
msgstr ""

msgid "every **file or folder** ending in anything other than ``c`` or ``o``"
msgstr ""

msgid "``*.file[0-9]``"
msgstr ""

msgid "every **file or folder** ending in digit"
msgstr ""

msgid "``*.file[!0-9]``"
msgstr ""

msgid "every **file or folder** ending in anything other than digit"
msgstr ""

msgid "``*``"
msgstr ""

msgid "**every**"
msgstr ""

msgid "``/*``"
msgstr ""

msgid "**everything** in the top-most directory (due to the leading ``/``)"
msgstr ""

msgid "``**/*.tar.gz``"
msgstr ""

msgid "every ``*.tar.gz`` file or folder which is **one or more** levels under the starting folder"
msgstr ""

msgid "``!file``"
msgstr ""

msgid "every **file or folder** will be ignored even if it matches other patterns"
msgstr ""

msgid "Deploying an application"
msgstr ""

msgid "You have four options to deploy a Tarantool Cartridge application:"
msgstr ""

msgid "as an :ref:`rpm <cartridge-deploy-rpm>` package (for production);"
msgstr ""

msgid "as a :ref:`deb <cartridge-deploy-deb>` package (for production);"
msgstr ""

msgid "as a :ref:`tar+gz <cartridge-deploy-tgz>` archive (for testing, or as a workaround for production if root access is unavailable)."
msgstr ""

msgid ":ref:`from sources <cartridge-deploy-rock>` (for local testing only)."
msgstr ""

msgid "Deploying as an rpm or deb package"
msgstr ""

msgid "Pack the application into a distributable:"
msgstr ""

msgid "$ cartridge pack rpm APP_NAME\n"
"# -- OR --\n"
"$ cartridge pack deb APP_NAME"
msgstr ""

msgid "This will create an RPM package (e.g. ``./my_app-0.1.0-1.rpm``) or a DEB package (e.g. ``./my_app-0.1.0-1.deb``)."
msgstr ""

msgid "Upload the package to target servers, with ``systemctl`` supported."
msgstr ""

msgid "Install:"
msgstr ""

msgid "$ yum install APP_NAME-VERSION.rpm\n"
"# -- OR --\n"
"$ dpkg -i APP_NAME-VERSION.deb"
msgstr ""

msgid ":ref:`Configure the instance(s) <cartridge-config>`."
msgstr ""

msgid "Start Tarantool instances with the corresponding services. You can do it using :ref:`systemctl <cartridge-run-systemctl>`, for example:"
msgstr ""

msgid "# starts a single instance\n"
"$ systemctl start my_app\n"
"\n"
"# starts multiple instances\n"
"$ systemctl start my_app@router\n"
"$ systemctl start my_app@storage_A\n"
"$ systemctl start my_app@storage_B"
msgstr ""

msgid "In case it is a cluster-aware application, proceed to :ref:`deploying the cluster <cartridge-deployment>`."
msgstr ""

msgid "Deploying as a tar+gz archive"
msgstr ""

msgid "$ cartridge pack tgz APP_NAME"
msgstr ""

msgid "This will create a tar+gz archive (e.g. ``./my_app-0.1.0-1.tgz``)."
msgstr ""

msgid "Upload the archive to target servers, with ``tarantool`` and (optionally) :ref:`cartridge-cli <cartridge-install>` installed."
msgstr ""

msgid "Extract the archive:"
msgstr ""

msgid "$ tar -xzvf APP_NAME-VERSION.tgz"
msgstr ""

msgid "Start Tarantool instance(s). You can do it using:"
msgstr ""

msgid ":ref:`tarantool <cartridge-run-tarantool>`, for example:"
msgstr ""

msgid "$ tarantool init.lua # starts a single instance"
msgstr ""

msgid "or :ref:`cartridge <cartridge-run-cartridge>`, for example:"
msgstr ""

msgid "# in application directory\n"
"$ cartridge start # starts all instances\n"
"$ cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"$ cartridge start my_app # starts all instances of my_app\n"
"$ cartridge start my_app.router # starts a single instance"
msgstr ""

msgid "Deploying from sources"
msgstr ""

msgid "This deployment method is intended for local testing only."
msgstr ""

msgid "Pull all dependencies to the ``.rocks`` directory:"
msgstr ""

msgid "$ tarantoolctl rocks make"
msgstr ""

msgid "# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # starts a single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # starts a single instance"
msgstr ""

msgid "Configuring instances"
msgstr ""

msgid "Instance configuration includes two sets of parameters:"
msgstr ""

msgid "`cartridge.cfg() parameters <https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse/#cluster-opts>`_;"
msgstr ""

msgid "`box.cfg() parameters <https://www.tarantool.io/en/rocks/cartridge/1.0/modules/cartridge.argparse/#box-opts>`_."
msgstr ""

msgid "You can set any of these parameters in:"
msgstr ""

msgid "Command line arguments."
msgstr ""

msgid "Environment variables."
msgstr ""

msgid "YAML configuration file."
msgstr ""

msgid "``init.lua`` file."
msgstr ""

msgid "The order here indicates the priority: command-line arguments override environment variables, and so forth."
msgstr ""

msgid "No matter how you :ref:`start the instances <cartridge-run>`, you need to set the following ``cartridge.cfg()`` parameters for each instance:"
msgstr ""

msgid "``advertise_uri`` -- either ``<HOST>:<PORT>``, or ``<HOST>:``, or ``<PORT>``. Used by other instances to connect to the current one. **DO NOT** specify ``0.0.0.0`` -- this must be an external IP address, not a socket bind."
msgstr ""

msgid "``http_port`` -- port to open administrative web interface and API on. Defaults to ``8081``. To disable it, specify ``\"http_enabled\": False``."
msgstr ""

msgid "``workdir`` -- a directory where all data will be stored: snapshots, wal logs, and ``cartridge`` configuration file. Defaults to ``.``."
msgstr ""

msgid "If you start instances using ``cartridge`` CLI or ``systemctl``, save the configuration as a YAML file, for example:"
msgstr ""

msgid "my_app.router: {\"advertise_uri\": \"localhost:3301\", \"http_port\": 8080}\n"
"my_app.storage_A: {\"advertise_uri\": \"localhost:3302\", \"http_enabled\": False}\n"
"my_app.storage_B: {\"advertise_uri\": \"localhost:3303\", \"http_enabled\": False}"
msgstr ""

msgid "With ``cartridge`` CLI, you can pass the path to this file as the ``--cfg`` command-line argument to the ``cartridge start`` command -- or specify the path in ``cartridge`` CLI configuration (in ``./.cartridge.yml`` or ``~/.cartridge.yml``):"
msgstr ""

msgid "cfg: cartridge.yml\n"
"run_dir: tmp/run\n"
"apps_path: /usr/local/share/tarantool"
msgstr ""

msgid "With ``systemctl``, save the YAML file to ``/etc/tarantool/conf.d/`` (the default ``systemd`` path) or to a location set in the ``TARANTOOL_CFG`` environment variable."
msgstr ""

msgid "If you start instances with ``tarantool init.lua``, you need to pass other configuration options as command-line parameters and environment variables, for example:"
msgstr ""

msgid "$ tarantool init.lua --alias router --memtx-memory 100 --workdir \"~/db/3301\" --advertise_uri \"localhost:3301\" --http_port \"8080\""
msgstr ""

msgid "Starting/stopping instances"
msgstr ""

msgid "Depending on your :ref:`deployment method <cartridge-deploy>`, you can start/stop the instances using :ref:`tarantool <cartridge-run-tarantool>`, :ref:`cartridge CLI <cartridge-run-cartridge>`, or :ref:`systemctl <cartridge-run-systemctl>`."
msgstr ""

msgid "Start/stop using ``tarantool``"
msgstr ""

msgid "With ``tarantool``, you can start only a single instance:"
msgstr ""

msgid "$ tarantool init.lua # the simplest command"
msgstr ""

msgid "You can also :ref:`specify more options <cartridge-config-tarantool>` on the command line or in environment variables."
msgstr ""

msgid "To stop the instance, use Ctrl+C."
msgstr ""

msgid "Start/stop using ``cartridge`` CLI"
msgstr ""

msgid "With ``cartridge`` CLI, you can start one or multiple instances:"
msgstr ""

msgid "$ cartridge start [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr ""

msgid "The options are:"
msgstr ""

msgid "``--script FILE``"
msgstr ""

msgid "Application's entry point. Defaults to:"
msgstr ""

msgid "``TARANTOOL_SCRIPT``, or"
msgstr ""

msgid "``./init.lua`` when running from the app's directory, or"
msgstr ""

msgid "``:apps_path/:app_name/init.lua`` in a multi-app environment."
msgstr ""

msgid "``--apps_path PATH``"
msgstr ""

msgid "Path to apps directory when running in a multi-app environment. Defaults to ``/usr/share/tarantool``."
msgstr ""

msgid "``--run_dir DIR``"
msgstr ""

msgid "Directory with pid and sock files. Defaults to ``TARANTOOL_RUN_DIR`` or ``/var/run/tarantool``."
msgstr ""

msgid "``--cfg FILE``"
msgstr ""

msgid "Cartridge instances YAML configuration file. Defaults to ``TARANTOOL_CFG`` or ``./instances.yml``."
msgstr ""

msgid "``--foreground``"
msgstr ""

msgid "Do not daemonize."
msgstr ""

msgid "cartridge start my_app --cfg demo.yml --run_dir ./tmp/run --foreground"
msgstr ""

msgid "It starts all ``tarantool`` instances specified in ``cfg`` file, in foreground, with enforced :ref:`environment variables <cartridge-config>`."
msgstr ""

msgid "When ``APP_NAME`` is not provided, ``cartridge`` parses it from ``./*.rockspec`` filename."
msgstr ""

msgid "When ``INSTANCE_NAME`` is not provided, ``cartridge`` reads ``cfg`` file and starts all defined instances:"
msgstr ""

msgid "# in application directory\n"
"cartridge start # starts all instances\n"
"cartridge start .router_1 # start single instance\n"
"\n"
"# in multi-application environment\n"
"cartridge start my_app # starts all instances of my_app\n"
"cartridge start my_app.router # start a single instance"
msgstr ""

msgid "To stop the instances, say:"
msgstr ""

msgid "$ cartridge stop [APP_NAME[.INSTANCE_NAME]] [options]"
msgstr ""

msgid "These options from the ``cartridge start`` command are supported:"
msgstr ""

msgid "Start/stop using ``systemctl``"
msgstr ""

msgid "To run a single instance:"
msgstr ""

msgid "$ systemctl start APP_NAME"
msgstr ""

msgid "This will start a  ``systemd`` service that will listen to the port specified in :ref:`instance configuration <cartridge-config>` (``http_port`` parameter)."
msgstr ""

msgid "To run multiple instances on one or multiple servers:"
msgstr ""

msgid "$ systemctl start APP_NAME@INSTANCE_1\n"
"$ systemctl start APP_NAME@INSTANCE_2\n"
"...\n"
"$ systemctl start APP_NAME@INSTANCE_N"
msgstr ""

msgid "where ``APP_NAME@INSTANCE_N`` is the instantiated service name for ``systemd`` with an incremental ``N`` -- a number, unique for every instance, added to the port the instance will listen to (e.g., ``3301``, ``3302``, etc.)"
msgstr ""

msgid "To stop all services on a server, use the ``systemctl stop`` command and specify instance names one by one. For example:"
msgstr ""

msgid "$ systemctl stop APP_NAME@INSTANCE_1 APP_NAME@INSTANCE_2 ... APP_NAME@INSTANCE_<N>"
msgstr ""

