# source: http://localhost:8081/admin/api
# timestamp: Fri Aug 02 2019 10:40:53 GMT+0300 (Москва, стандартное время)

"""Cluster management"""
type Apicluster {
  """Get current server"""
  self: ServerShortInfo

  """Get current failover state."""
  failover: Boolean!

  """Virtual buckets count in cluster"""
  vshard_bucket_count: Int!

  """List authorized users"""
  users(username: String): [User!]

  """Get list of all registered roles and their dependencies."""
  known_roles: [Role!]!

  """Get list of known vshard storage groups."""
  vshard_known_groups: [String!]!
  vshard_groups: [VshardGroup!]!
  auth_params: UserManagementAPI!

  """Whether it is reasonble to call bootstrap_vshard mutation"""
  can_bootstrap_vshard: Boolean!
}

"""Cluster server label"""
type Label {
  name: String!
  value: String!
}

"""Cluster server label"""
input LabelInput {
  name: String!
  value: String!
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values from -(2^52) to 2^52 - 1, inclusive.
"""
scalar Long

type Mutation {
  """Cluster management"""
  cluster: MutationApicluster
  edit_server(uuid: String!, uri: String, labels: [LabelInput]): Boolean
  probe_server(uri: String!): Boolean
  edit_replicaset(weight: Float, vshard_group: String, roles: [String!], uuid: String!, all_rw: Boolean, master: [String!]): Boolean
  join_server(replicaset_uuid: String, uri: String!, labels: [LabelInput], roles: [String!], instance_uuid: String, timeout: Float, vshard_group: String): Boolean
  bootstrap_vshard: Boolean
  expel_server(uuid: String!): Boolean
}

"""Cluster management"""
type MutationApicluster {
  auth_params(enabled: Boolean): UserManagementAPI!

  """Remove user"""
  remove_user(username: String!): User

  """Edit an existing user"""
  edit_user(password: String, username: String!, fullname: String, email: String): User

  """Enable or disable automatic failover. Returns new state."""
  failover(enabled: Boolean!): Boolean!

  """Create a new user"""
  add_user(password: String!, username: String!, fullname: String, email: String): User

  """Disable listed servers by uuid"""
  disable_servers(uuids: [String!]): [Server]
}

type Query {
  """Cluster management"""
  cluster: Apicluster
  servers(uuid: String): [Server]
  replicasets(uuid: String): [Replicaset]
}

"""Group of servers replicating the same data"""
type Replicaset {
  """
  Vshard replica set weight. Null for replica sets with vshard-storage role disabled.
  """
  weight: Float

  """The leader according to the configuration."""
  master: Server!

  """
  The replica set health. It is "healthy" if all instances have status "healthy". Otherwise "unhealthy".
  """
  status: String!

  """All instances in replica set are rw"""
  all_rw: Boolean!

  """
  Vshard storage group name. Meaningful only when multiple vshard groups are configured.
  """
  vshard_group: String

  """
  The active leader. It may differ from "master" if failover is enabled and configured leader isn't healthy.
  """
  active_master: Server!

  """The replica set uuid"""
  uuid: String!

  """Servers in the replica set."""
  servers: [Server!]!

  """The role set enabled on every instance in the replica set"""
  roles: [String!]
}

"""Statistics for an instance in the replica set."""
type ReplicaStatus {
  downstream_status: String
  id: Int
  upstream_peer: String
  upstream_idle: Float
  upstream_message: String
  lsn: Long
  upstream_lag: Float
  upstream_status: String
  uuid: String!
  downstream_message: String
}

type Role {
  name: String!
  dependencies: [String!]
}

"""A server participating in tarantool cluster"""
type Server {
  statistics: ServerStat
  boxinfo: ServerInfo
  status: String!
  uuid: String!
  replicaset: Replicaset
  uri: String!
  alias: String
  disabled: Boolean
  message: String!

  """Failover priority within the replica set"""
  priority: Int
  labels: [Label]
}

"""Server information and configuration."""
type ServerInfo {
  network: ServerInfoNetwork!
  general: ServerInfoGeneral!
  replication: ServerInfoReplication!
  storage: ServerInfoStorage!
}

type ServerInfoGeneral {
  """A globally unique identifier of the instance"""
  instance_uuid: String!

  """Current read-only state"""
  ro: Boolean!

  """A directory where vinyl files or subdirectories will be stored"""
  vinyl_dir: String

  """
  The maximum number of threads to use during execution of certain internal
  processes (currently socket.getaddrinfo() and coio_call())
  """
  worker_pool_threads: Int

  """Current working directory of a process"""
  work_dir: String

  """The number of seconds since the instance started"""
  uptime: Float!

  """A directory where write-ahead log (.xlog) files are stored"""
  wal_dir: String

  """The Tarantool version"""
  version: String!

  """The binary protocol URI"""
  listen: String

  """The process ID"""
  pid: Int!

  """The UUID of the replica set"""
  replicaset_uuid: String!

  """A directory where memtx stores snapshot (.snap) files"""
  memtx_dir: String
}

type ServerInfoNetwork {
  io_collect_interval: Float
  readahead: Long
  net_msg_max: Long
}

type ServerInfoReplication {
  replication_connect_quorum: Int
  replication_connect_timeout: Float
  replication_sync_timeout: Float
  replication_skip_conflict: Boolean
  replication_sync_lag: Float

  """
  Statistics for all instances in the replica set in regard to the current instance
  """
  replication_info: [ReplicaStatus!]

  """The vector clock of replication log sequence numbers"""
  vclock: [Long]
  replication_timeout: Float
}

type ServerInfoStorage {
  wal_max_size: Long
  vinyl_run_count_per_level: Int
  rows_per_wal: Long
  vinyl_cache: Long
  vinyl_range_size: Long
  vinyl_timeout: Float
  memtx_min_tuple_size: Long
  vinyl_bloom_fpr: Float
  vinyl_page_size: Long
  memtx_max_tuple_size: Long
  vinyl_run_size_ratio: Float
  wal_mode: String
  memtx_memory: Long
  vinyl_memory: Long
  too_long_threshold: Float
  vinyl_max_tuple_size: Long
  vinyl_write_threads: Int
  vinyl_read_threads: Int
  wal_dir_rescan_delay: Float
}

"""A short server information"""
type ServerShortInfo {
  uri: String!
  uuid: String
  alias: String
}

"""
Slab allocator statistics. This can be used to monitor the total memory usage (in bytes) and memory fragmentation.
"""
type ServerStat {
  """
  The total amount of memory (including allocated, but currently free slabs) used only for tuples, no indexes
  """
  items_size: Long!

  """
  = items_used / slab_count * slab_size (these are slabs used only for tuples, no indexes)
  """
  items_used_ratio: String!

  """
  The maximum amount of memory that the slab allocator can use for both tuples
  and indexes (as configured in the memtx_memory parameter)
  """
  quota_size: Long!

  """The amount of memory that is already distributed to the slab allocator"""
  quota_used: Long!

  """= arena_used / arena_size"""
  arena_used_ratio: String!

  """
  The efficient amount of memory (omitting allocated, but currently free slabs) used only for tuples, no indexes
  """
  items_used: Long!

  """= quota_used / quota_size"""
  quota_used_ratio: String!

  """
  The total memory used for tuples and indexes together (including allocated, but currently free slabs)
  """
  arena_size: Long!

  """
  The efficient memory used for storing tuples and indexes together (omitting allocated, but currently free slabs)
  """
  arena_used: Long!
}

"""A single user account information"""
type User {
  username: String!
  fullname: String
  email: String
}

"""User managent parameters and available operations"""
type UserManagementAPI {
  implements_remove_user: Boolean!
  implements_add_user: Boolean!
  implements_edit_user: Boolean!

  """Number of seconds until the authentication cookie expires."""
  cookie_max_age: Long!

  """Number of seconds to keep in cache cookie validation result."""
  cookie_caching_time: Long!
  implements_list_users: Boolean!
  implements_get_user: Boolean!

  """Whether authentication is enabled."""
  enabled: Boolean!

  """Active session username."""
  username: String
  implements_check_password: Boolean!
}

"""Group of replicasets sharding the same dataset"""
type VshardGroup {
  """Virtual buckets count in the group"""
  bucket_count: Int!

  """Group name"""
  name: String!

  """Whethe the group is ready to operate"""
  bootstrapped: Boolean!
}
